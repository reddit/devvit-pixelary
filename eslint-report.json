[
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ActiveEffectsBadge.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ActiveEffectsBadge.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 20,
        "column": 36,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 20,
        "endColumn": 51,
        "fix": { "range": [760, 775], "text": "{ setIsOpen(true); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 21,
        "column": 37,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 21,
        "endColumn": 53,
        "fix": { "range": [818, 834], "text": "{ setIsOpen(false); }" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { Text } from '@components/PixelFont';\nimport { Button } from '@components/Button';\nimport { Modal } from '@components/Modal';\nimport { useActiveEffects } from '@hooks/useActiveEffects';\nimport { getConsumableConfig } from '@shared/consumables';\nimport { useState, useMemo, useCallback } from 'react';\nimport {\n  formatSecondsShort,\n  formatSecondsTwoUnits,\n} from '@shared/utils/numbers';\nimport { Multiplier } from './illustrations';\n\nexport function ActiveEffectsBadge() {\n  const { currentEffect, secondsRemaining } = useActiveEffects();\n  const [isOpen, setIsOpen] = useState(false);\n  const config = useMemo(\n    () => (currentEffect ? getConsumableConfig(currentEffect.itemId) : null),\n    [currentEffect]\n  );\n  const onOpen = useCallback(() => setIsOpen(true), []);\n  const onClose = useCallback(() => setIsOpen(false), []);\n\n  if (!currentEffect) return null;\n\n  const formatted = formatSecondsShort(secondsRemaining);\n  const formattedLong = formatSecondsTwoUnits(secondsRemaining);\n\n  const badge = (\n    <div\n      className=\"absolute top-4 left-4 z-50 flex flex-col items-center cursor-pointer gap-1\"\n      onClick={onOpen}\n      role=\"button\"\n      tabIndex={0}\n      data-testid=\"active-effects-badge\"\n    >\n      <Multiplier\n        size={24}\n        variant={\n          currentEffect.effect.kind === 'score_multiplier' &&\n          currentEffect.effect.multiplier >= 3\n            ? 'triple'\n            : 'double'\n        }\n      />\n      <div data-testid=\"active-effects-timer\" aria-label={formatted}>\n        <Text className=\"text-tertiary\">{formatted}</Text>\n      </div>\n    </div>\n  );\n\n  const modal = (\n    <Modal isOpen={isOpen} onClose={onClose}>\n      <div className=\"flex flex-col items-center justify-center gap-6\">\n        <Multiplier\n          size={48}\n          variant={\n            currentEffect.effect.kind === 'score_multiplier' &&\n            currentEffect.effect.multiplier >= 3\n              ? 'triple'\n              : 'double'\n          }\n        />\n\n        <div className=\"flex flex-col items-center justify-center gap-2\">\n          <Text className=\"text-primary\">{config?.label ?? ''}</Text>\n          <Text className=\"text-tertiary\">{`${formattedLong} left`}</Text>\n        </div>\n\n        <Button onClick={onClose}>Okay</Button>\n      </div>\n    </Modal>\n  );\n\n  return (\n    <>\n      {badge}\n      {modal}\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Background.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Button.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 6,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 6,
        "endColumn": 22,
        "fix": { "range": [210, 232], "text": "type ButtonProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { Text, Icon } from './PixelFont';\nimport { type SupportedGlyph } from './PixelFont';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport type { TelemetryEventType } from '@shared/types';\n\ninterface ButtonProps {\n  children?: string;\n  onClick?: () => void;\n  variant?: 'primary' | 'secondary' | 'white';\n  size?: 'small' | 'medium' | 'large';\n  disabled?: boolean;\n  leadingIcon?: SupportedGlyph;\n  trailingIcon?: SupportedGlyph;\n  className?: string;\n  title?: string;\n  telemetryEvent?: TelemetryEventType;\n}\n\nexport function Button({\n  children,\n  onClick,\n  variant = 'primary',\n  size = 'medium',\n  disabled = false,\n  leadingIcon,\n  trailingIcon,\n  className = '',\n  title,\n  telemetryEvent,\n}: ButtonProps) {\n  const { track } = useTelemetry();\n  const baseClasses =\n    'flex flex-row gap-2 items-center justify-center transition-all border-4';\n\n  const variantClasses = {\n    primary: disabled\n      ? 'bg-gray-300 text-gray-500 cursor-not-allowed border-transparent'\n      : 'bg-black text-white hover:bg-gray-800 cursor-pointer active:bg-gray-900 border-transparent',\n    secondary: disabled\n      ? 'bg-gray-200 border-4 border-gray-300 text-gray-500 cursor-not-allowed'\n      : 'bg-background border-4 border-black text-black hover:bg-background/90 cursor-pointer active:bg-background/80',\n    white: disabled\n      ? 'bg-gray-200 border-4 border-gray-300 text-gray-500 cursor-not-allowed'\n      : 'bg-white border-4 border-black text-black hover:bg-gray-100 cursor-pointer active:bg-gray-200',\n  };\n\n  const sizeClasses = {\n    small: 'px-2 py-[5px]',\n    medium: 'px-2 py-[9px]',\n    large: 'px-3 py-[13px]',\n  };\n\n  const fontScales = {\n    small: 2,\n    medium: 2,\n    large: 2,\n  };\n\n  const handleClick = () => {\n    // Track telemetry if provided\n    if (telemetryEvent) {\n      void track(telemetryEvent);\n    }\n\n    // Call original onClick\n    onClick?.();\n  };\n\n  return (\n    <button\n      onClick={disabled ? undefined : handleClick}\n      disabled={disabled}\n      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} hover:translate-x-[2px] hover:translate-y-[2px] active:translate-x-[4px] active:translate-y-[4px] shadow-pixel hover:shadow-pixel-sm active:shadow-none ${className}`}\n      title={title}\n    >\n      {leadingIcon && <Icon type={leadingIcon} />}\n      {children && <Text scale={fontScales[size]} children={children} />}\n      {trailingIcon && <Icon type={trailingIcon} />}\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Collision.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 3,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 3,
        "endColumn": 25,
        "fix": { "range": [54, 79], "text": "type CollisionProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 10,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 10,
        "endColumn": 28,
        "fix": { "range": [354, 382], "text": "type CollisionParticle = " }
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 68,
        "column": 16,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 68,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 205,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 205,
        "endColumn": 68,
        "fix": {
          "range": [6342, 6392],
          "text": "{ window.removeEventListener('resize', handleResize); }"
        }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'count', 'explosionSpeed', 'spawnHeight.max', and 'spawnHeight.min'. Either include them or remove the dependency array.",
        "line": 78,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 78,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [count, explosionSpeed, spawnHeight.max, spawnHeight.min]",
            "fix": {
              "range": [2402, 2404],
              "text": "[count, explosionSpeed, spawnHeight.max, spawnHeight.min]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import { useEffect, useRef, useState } from 'react';\n\ninterface CollisionProps {\n  count?: number; // Number of particles to spawn (default: 75)\n  spawnHeight?: { min: number; max: number }; // Vertical line spawn range\n  explosionSpeed?: number; // Base explosion speed (default: 200)\n  duration?: number; // Animation duration in ms (default: 1500)\n}\n\ninterface CollisionParticle {\n  x: number;\n  y: number;\n  vx: number; // horizontal velocity\n  vy: number; // vertical velocity\n  color: string;\n  width: number;\n  height: number;\n  life: number; // 0-1 life value\n}\n\nconst CONFETTI_COLORS = [\n  '#eb5757', // red\n  '#f2994a', // orange\n  '#f2c94c', // yellow\n  '#27ae60', // green\n  '#2f80ed', // blue\n  '#9b51e0', // purple\n];\n\nexport function Collision({\n  count = 40,\n  spawnHeight = { min: 0.3, max: 0.7 },\n  explosionSpeed = 400,\n  duration = 1500,\n}: CollisionProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationRef = useRef<number | undefined>(undefined);\n  const [particles, setParticles] = useState<CollisionParticle[]>([]);\n  const lastFrameTime = useRef<number>(0);\n  const isAnimatingRef = useRef(false);\n  const startTimeRef = useRef<number>(0);\n\n  // Spawn particles on mount\n  useEffect(() => {\n    startTimeRef.current = performance.now();\n\n    // Spawn all particles instantly in a vertical line at center\n    const centerX = window.innerWidth / 2;\n    const minY = window.innerHeight * spawnHeight.min;\n    const maxY = window.innerHeight * spawnHeight.max;\n\n    const initialParticles: CollisionParticle[] = [];\n    for (let i = 0; i < count; i++) {\n      const colorIndex = Math.floor(Math.random() * CONFETTI_COLORS.length);\n\n      // Spawn along vertical line\n      const y = minY + (maxY - minY) * (i / count);\n\n      // Calculate explosion direction and speed (radial outward)\n      const angle = Math.random() * Math.PI * 2; // 360 degrees\n      const speed = explosionSpeed * (0.5 + Math.random() * 0.5); // 50% to 100% of explosion speed\n\n      initialParticles.push({\n        x: centerX,\n        y: y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        color: CONFETTI_COLORS[colorIndex]!,\n        width: 8,\n        height: 24,\n        life: 1.0,\n      });\n    }\n\n    setParticles(initialParticles);\n    lastFrameTime.current = performance.now();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Only run once on mount\n\n  // Initialize canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || typeof window === 'undefined') return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set canvas size to match viewport\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n  }, []);\n\n  // Start animation when particles are set\n  useEffect(() => {\n    if (particles.length > 0 && !isAnimatingRef.current) {\n      isAnimatingRef.current = true;\n\n      const animate = (currentTime: number) => {\n        // Check duration timeout\n        if (currentTime - startTimeRef.current > duration) {\n          isAnimatingRef.current = false;\n          animationRef.current = undefined;\n          if (canvasRef.current) {\n            const ctx = canvasRef.current.getContext('2d');\n            if (ctx) {\n              ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n            }\n          }\n          return;\n        }\n\n        const canvas = canvasRef.current;\n        const ctx = canvas?.getContext('2d');\n\n        setParticles((prevParticles) => {\n          const deltaTime = lastFrameTime.current\n            ? (currentTime - lastFrameTime.current) / 1000\n            : 0.016;\n          lastFrameTime.current = currentTime;\n\n          const updatedParticles = prevParticles\n            .map((particle) => {\n              // Apply initial velocity (explosion)\n              particle.x += particle.vx * deltaTime;\n              particle.y += particle.vy * deltaTime;\n\n              // Add gravity after initial burst\n              particle.vy += 1500 * deltaTime; // gravity\n\n              // Fade out over time\n              particle.life = Math.max(0, particle.life - 0.003 * deltaTime);\n\n              return particle;\n            })\n            .filter((particle) => {\n              return (\n                particle.y < window.innerHeight + 50 &&\n                particle.x > -50 &&\n                particle.x < window.innerWidth + 50 &&\n                particle.life > 0\n              );\n            });\n\n          // Render particles\n          if (ctx && canvas && updatedParticles.length > 0) {\n            // Clear canvas\n            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            // Render each particle\n            updatedParticles.forEach((particle) => {\n              ctx.save();\n              ctx.translate(particle.x, particle.y);\n              ctx.globalAlpha = particle.life;\n              ctx.fillStyle = particle.color;\n              ctx.fillRect(\n                -particle.width / 2,\n                -particle.height / 2,\n                particle.width,\n                particle.height\n              );\n              ctx.restore();\n            });\n          }\n\n          // Continue animation if particles remain\n          if (updatedParticles.length > 0) {\n            animationRef.current = requestAnimationFrame(animate);\n          } else {\n            // Clear canvas when animation completes\n            if (ctx && canvas) {\n              ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n            }\n            isAnimatingRef.current = false;\n            animationRef.current = undefined;\n          }\n\n          return updatedParticles;\n        });\n      };\n\n      animationRef.current = requestAnimationFrame(animate);\n\n      return () => {\n        if (animationRef.current) {\n          cancelAnimationFrame(animationRef.current);\n        }\n        isAnimatingRef.current = false;\n      };\n    }\n  }, [particles.length, duration]);\n\n  // Handle window resize\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const handleResize = () => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Clean up animation on unmount\n  useEffect(() => {\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n      isAnimatingRef.current = false;\n    };\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"absolute inset-0 pointer-events-none z-40\"\n      data-testid=\"collision-canvas\"\n      style={{\n        imageRendering: 'pixelated',\n        width: '100vw',\n        height: '100vh',\n      }}\n    />\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Confetti.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Confetti.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 3,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 3,
        "endColumn": 24,
        "fix": { "range": [54, 78], "text": "type ConfettiProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 9,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 9,
        "endColumn": 27,
        "fix": { "range": [273, 300], "text": "type ConfettiParticle = " }
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 96,
        "column": 22,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 96,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 179,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 179,
        "endColumn": 68,
        "fix": {
          "range": [5140, 5190],
          "text": "{ window.removeEventListener('resize', handleResize); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import { useEffect, useRef, useState } from 'react';\n\ninterface ConfettiProps {\n  count?: number; // Number of particles to spawn (default: 100)\n  speed?: number; // Base falling speed (default: 3)\n  delay?: number; // Delay between particle spawns in ms (default: 200)\n}\n\ninterface ConfettiParticle {\n  x: number;\n  y: number;\n  vy: number;\n  color: string;\n  width: number;\n  height: number;\n  life: number; // 0-1 life value\n}\n\nconst CONFETTI_COLORS = [\n  '#eb5757', // red\n  '#f2994a', // orange\n  '#f2c94c', // yellow\n  '#27ae60', // green\n  '#2f80ed', // blue\n  '#9b51e0', // purple\n];\n\nexport function Confetti({\n  count = 100,\n  speed = 3,\n  delay = 20,\n}: ConfettiProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationRef = useRef<number | undefined>(undefined);\n  const [particles, setParticles] = useState<ConfettiParticle[]>([]);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [spawnedCount, setSpawnedCount] = useState(0);\n  const lastSpawnTime = useRef<number>(0);\n  const lastFrameTime = useRef<number>(0);\n\n  // Initialize canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || typeof window === 'undefined') return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set canvas size to match viewport\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n  }, []);\n\n  // Start animation on mount\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      setIsAnimating(true);\n    }\n  }, []);\n\n  // Animation loop\n  useEffect(() => {\n    if (!isAnimating) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = undefined;\n      }\n      return;\n    }\n\n    const animate = (currentTime: number) => {\n      setParticles((prevParticles) => {\n        const deltaTime = lastFrameTime.current\n          ? (currentTime - lastFrameTime.current) / 1000\n          : 0.016;\n        lastFrameTime.current = currentTime;\n        let newParticles = [...prevParticles];\n\n        // Spawn new particles gradually (every delay ms, up to count total)\n        if (\n          (spawnedCount < count || count === Infinity) &&\n          currentTime - lastSpawnTime.current >= delay\n        ) {\n          const spawnCount =\n            count === Infinity ? 1 : Math.min(1, count - spawnedCount); // Spawn 1 at a time\n          const additionalParticles: ConfettiParticle[] = [];\n\n          for (let i = 0; i < spawnCount; i++) {\n            const colorIndex = Math.floor(\n              Math.random() * CONFETTI_COLORS.length\n            );\n            additionalParticles.push({\n              x: Math.random() * window.innerWidth,\n              y: -20, // Start at the top\n              vy: (Math.random() * speed + speed) * 50, // Scale up for delta time (speed to speed*2) * 50\n              color: CONFETTI_COLORS[colorIndex]!,\n              width: 4,\n              height: 12,\n              life: 1.0,\n            });\n          }\n\n          newParticles = [...newParticles, ...additionalParticles];\n          setSpawnedCount((prev) => prev + spawnCount);\n          lastSpawnTime.current = currentTime;\n        }\n\n        const updatedParticles = newParticles\n          .map((particle) => {\n            particle.y += particle.vy * deltaTime; // Scale by delta time\n            particle.life = Math.max(0, particle.life - 0.002 * deltaTime); // Fade out over time\n\n            return particle;\n          })\n          .filter((particle) => {\n            return (\n              particle.y < window.innerHeight + 50 &&\n              particle.x > -50 &&\n              particle.x < window.innerWidth + 50 &&\n              particle.life > 0\n            );\n          });\n\n        return updatedParticles;\n      });\n\n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    animationRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [isAnimating, spawnedCount, count, speed, delay]);\n\n  // Render particles with 2D canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || particles.length === 0) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n    // Render each particle\n    particles.forEach((particle) => {\n      ctx.save();\n      ctx.translate(particle.x, particle.y);\n      ctx.globalAlpha = particle.life;\n      ctx.fillStyle = particle.color;\n      ctx.fillRect(\n        -particle.width / 2,\n        -particle.height / 2,\n        particle.width,\n        particle.height\n      );\n      ctx.restore();\n    });\n  }, [particles]);\n\n  // Handle window resize\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const handleResize = () => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Clean up animation on unmount\n  useEffect(() => {\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, []);\n\n  if (!isAnimating) {\n    return null;\n  }\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"absolute inset-0 pointer-events-none\"\n      data-testid=\"confetti-canvas\"\n      style={{\n        imageRendering: 'pixelated',\n        width: '100vw',\n        height: '100vh',\n      }}\n    />\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Counter.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 5,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 5,
        "endColumn": 30,
        "fix": {
          "range": [165, 284],
          "text": "type CounterProps = {\n  value: number | null | undefined;\n  fallback?: number;\n} & Omit<TextProps, 'children'>"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, { useState, useEffect, useRef } from 'react';\nimport { Text, getFontHeight } from './PixelFont';\nimport type { TextProps } from './PixelFont';\n\nexport interface CounterProps extends Omit<TextProps, 'children'> {\n  value: number | null | undefined;\n  fallback?: number;\n}\n\nexport function Counter({\n  value,\n  fallback = 0,\n  scale = 2,\n  ...pixelFontProps\n}: CounterProps) {\n  const [currentValue, setCurrentValue] = useState(value ?? fallback);\n  const [previousValue, setPreviousValue] = useState<number | null | undefined>(\n    null\n  );\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isIncreasing, setIsIncreasing] = useState(true); // Track direction\n  const animationTimeoutRef = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    const newValue = value ?? fallback;\n    if (newValue !== currentValue) {\n      // Clear any existing timeout\n      if (animationTimeoutRef.current) {\n        clearTimeout(animationTimeoutRef.current);\n      }\n\n      // Determine direction\n      setIsIncreasing(newValue > currentValue);\n\n      setPreviousValue(currentValue);\n      setCurrentValue(newValue);\n      setIsAnimating(true);\n\n      // Clean up previous value after animation completes\n      animationTimeoutRef.current = window.setTimeout(() => {\n        setPreviousValue(null);\n        setIsAnimating(false);\n      }, 400); // Match animation duration\n    }\n\n    return () => {\n      if (animationTimeoutRef.current) {\n        clearTimeout(animationTimeoutRef.current);\n      }\n    };\n  }, [value, currentValue, fallback]);\n\n  const fontHeight = getFontHeight() * scale;\n\n  const displayValue = (val: number | null | undefined) => {\n    return (val ?? fallback).toString();\n  };\n\n  // Outer wrapper for masking - allow width to change\n  const outerStyle: React.CSSProperties = {\n    height: fontHeight,\n    overflow: 'hidden',\n    position: 'relative',\n    display: 'inline-block',\n    transition: 'width 0.4s ease-out', // Smooth width transitions\n  };\n\n  // Inner flex container that animates vertically\n  const innerStyle: React.CSSProperties = {\n    display: 'flex',\n    flexDirection: 'column',\n    transition: 'transform 0.4s ease-out',\n    transform: isAnimating\n      ? isIncreasing\n        ? `translateY(-${fontHeight}px)`\n        : `translateY(${fontHeight}px)`\n      : 'translateY(0px)',\n  };\n\n  return (\n    <div style={outerStyle}>\n      <div style={innerStyle}>\n        {/* Previous value */}\n        {previousValue !== null && previousValue !== undefined && (\n          <Text scale={scale} {...pixelFontProps}>\n            {displayValue(previousValue)}\n          </Text>\n        )}\n        {/* Current value */}\n        <Text scale={scale} {...pixelFontProps}>\n          {displayValue(currentValue)}\n        </Text>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/CyclingMessage.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/CyclingMessage.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 4,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 4,
        "endColumn": 30,
        "fix": { "range": [82, 112], "text": "type CyclingMessageProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 32,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 32,
        "endColumn": 41,
        "fix": { "range": [794, 817], "text": "{ clearInterval(interval); }" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 39,
        "column": 49,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 39,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [968, 970], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-template-expression",
        "severity": 1,
        "message": "Template literal expression is unnecessary and can be simplified.",
        "line": 45,
        "column": 9,
        "nodeType": null,
        "messageId": "noUnnecessaryTemplateExpression",
        "endLine": 48,
        "endColumn": 1,
        "fix": {
          "range": [1073, 1229],
          "text": "isAnimating\n            ? 'opacity-0 translate-y-1/2'\n            : 'opacity-100 translate-y-0 transition-all duration-300 ease-in'"
        }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 50,
        "column": 39,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 50,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1277, 1279], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import { useState, useEffect } from 'react';\nimport { Text } from './PixelFont';\n\ninterface CyclingMessageProps {\n  messages: string[];\n  intervalMs?: number;\n  className?: string;\n}\n\nexport function CyclingMessage({\n  messages,\n  intervalMs = 3000,\n  className,\n}: CyclingMessageProps) {\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  useEffect(() => {\n    if (messages.length <= 1) return;\n\n    const interval = setInterval(() => {\n      setIsAnimating(true);\n\n      // Change content immediately\n      setCurrentIndex((prev) => (prev + 1) % messages.length);\n      // Small delay before starting slide up animation\n      setTimeout(() => {\n        setIsAnimating(false);\n      }, 50);\n    }, intervalMs);\n\n    return () => clearInterval(interval);\n  }, [messages.length, intervalMs]);\n\n  if (messages.length === 0) return null;\n\n  return (\n    <div\n      className={`relative h-[14px] ${className || ''}`}\n      aria-live=\"polite\"\n      aria-label=\"Cycling message\"\n    >\n      <div\n        className={`${\n          isAnimating\n            ? 'opacity-0 translate-y-1/2'\n            : 'opacity-100 translate-y-0 transition-all duration-300 ease-in'\n        }`}\n      >\n        <Text>{messages[currentIndex] || ''}</Text>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Drawing.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 5,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 5,
        "endColumn": 23,
        "fix": { "range": [173, 196], "text": "type DrawingProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 25,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 25,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, { useEffect, useRef } from 'react';\nimport { renderDrawingToCanvas } from '@shared/utils/drawing';\nimport type { DrawingData } from '@shared/schema/drawing';\n\ninterface DrawingProps {\n  data: DrawingData;\n  size?: number;\n  onClick?: () => void;\n  className?: string;\n  enableBreathing?: boolean;\n  isPaused?: boolean;\n}\n\nexport const Drawing = React.memo(function Drawing({\n  data,\n  size,\n  onClick,\n  className = '',\n  enableBreathing = false,\n  isPaused = false,\n}: DrawingProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (canvasRef.current && data) {\n      renderDrawingToCanvas(data, canvasRef.current);\n    }\n  }, [data]);\n\n  // Animation classes\n  const breathingClass =\n    enableBreathing && !isPaused ? 'animate-pixel-breathe' : '';\n\n  // If no size is provided, use auto-sizing\n  if (size === undefined) {\n    return (\n      <div\n        className={`w-full h-full flex items-center justify-center ${className}`}\n        onClick={onClick}\n      >\n        <div className={`relative ${breathingClass}`}>\n          <canvas\n            ref={canvasRef}\n            className=\"bg-white aspect-square w-full h-auto max-h-full\"\n            style={{\n              imageRendering: 'pixelated',\n            }}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  // Fixed size rendering\n  const clickableClasses = onClick\n    ? 'cursor-pointer shadow-pixel hover:shadow-pixel-sm active:shadow-none hover:translate-x-[2px] hover:translate-y-[2px] active:translate-x-[4px] active:translate-y-[4px] transition-all'\n    : 'shadow-pixel';\n\n  return (\n    <div className={`relative ${className}`} onClick={onClick}>\n      {/* Drawing */}\n      <div\n        className={`relative bg-white ${clickableClasses} ${breathingClass}`}\n        style={{ width: size, height: size }}\n      >\n        <canvas\n          ref={canvasRef}\n          className=\"w-full h-full\"\n          style={{ imageRendering: 'pixelated' }}\n        />\n      </div>\n    </div>\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Editor/Editor.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 14,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 14,
        "endColumn": 29,
        "fix": { "range": [675, 704], "text": "type DrawingEditorProps = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 76,
        "column": 45,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 76,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2732, 2734], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 77,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 77,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2774, 2776], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 105,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 105,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3631, 3633], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 127,
        "column": 36,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 127,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [4140, 4142], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 157,
        "column": 38,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 157,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [4997, 5035],
              "text": "(levelData?.level ?? userProfile?.level)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 157,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 157,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [5036, 5038], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 50,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 50,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1725, 1727], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useState, useEffect, useCallback, useRef } from 'react';\nimport { WordStep } from './_components/WordStep';\nimport { DrawStep } from './_components/DrawStep';\nimport { ReviewStep } from './_components/ReviewStep';\nimport { TournamentReviewStep } from './_components/TournamentReviewStep';\nimport { trpc } from '@client/trpc/client';\nimport { DRAWING_DURATION } from '@shared/constants';\nimport { DrawingData, DrawingUtils } from '@shared/schema/drawing';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport type { SlateAction } from '@shared/types';\nimport { context } from '@devvit/web/client';\nimport { getExtraDrawingTime } from '@shared/rewards';\n\ninterface DrawingEditorProps {\n  onClose: () => void;\n  onSuccess?: () => void;\n  mode?: 'post' | 'tournament-comment';\n  tournamentPostId?: string;\n  tournamentWord?: string;\n}\n\ntype Step = 'word' | 'draw' | 'review';\n\nexport function DrawingEditor({\n  onClose,\n  onSuccess,\n  mode = 'post',\n  tournamentPostId,\n  tournamentWord,\n}: DrawingEditorProps) {\n  // State management - skip word step if tournament word is provided\n  const [step, setStep] = useState<Step>(\n    mode === 'tournament-comment' && tournamentWord && tournamentPostId\n      ? 'draw'\n      : 'word'\n  );\n  const [time, setTime] = useState<number>(DRAWING_DURATION);\n  const [selectedWord, setSelectedWord] = useState<string | null>(null);\n  const [drawing, setDrawing] = useState<DrawingData>(\n    DrawingUtils.createBlank()\n  );\n  const [slateId, setSlateId] = useState<string | null>(null);\n\n  const { track } = useTelemetry();\n\n  // Track editor view on mount\n  useEffect(() => {\n    void track('view_editor');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // tRPC hooks - fetch level separately for instant access\n  const { data: levelData } = trpc.app.user.getLevel.useQuery(undefined, {\n    staleTime: 30000, // Use prefetched data\n  });\n  const { data: userProfile } = trpc.app.user.getProfile.useQuery(undefined, {\n    staleTime: 30000, // Use prefetched data\n  });\n  const { data: effectiveBonuses } =\n    trpc.app.rewards.getEffectiveBonuses.useQuery(undefined, {\n      enabled: !!context.userId,\n      staleTime: 5000,\n    });\n  const trackSlateActionMutation = trpc.app.slate.trackAction.useMutation();\n  const trackSlateActionRef = useRef(trackSlateActionMutation.mutateAsync);\n  const subredditNameRef = useRef(context.subredditName);\n\n  // Fetch slate data at Editor level to persist across step transitions\n  const {\n    data: slateData,\n    isLoading: isSlateLoading,\n    refetch: refreshCandidates,\n  } = trpc.app.dictionary.getCandidates.useQuery();\n\n  // Extract slateId and words from response\n  const currentSlateId = slateData?.slateId || null;\n  const words = slateData?.words || [null, null, null];\n\n  // Debug slate data\n  useEffect(() => {\n    // Slate data changed\n  }, [slateData, currentSlateId, isSlateLoading, slateId]);\n\n  // Set slateId when slate data loads\n  useEffect(() => {\n    if (currentSlateId && currentSlateId !== slateId) {\n      setSlateId(currentSlateId);\n    }\n  }, [currentSlateId, slateId]);\n\n  // Update refs when values change\n  useEffect(() => {\n    trackSlateActionRef.current = trackSlateActionMutation.mutateAsync;\n    subredditNameRef.current = context.subredditName;\n  }, [trackSlateActionMutation.mutateAsync]);\n\n  // Track slate action function\n  const trackSlateAction = useCallback(\n    async (\n      action: SlateAction,\n      word?: string,\n      metadata?: Record<string, string | number>\n    ) => {\n      // Use currentSlateId if slateId is not set yet\n      const effectiveSlateId = slateId || currentSlateId;\n\n      if (!effectiveSlateId) {\n        return;\n      }\n\n      await trackSlateActionRef.current({\n        slateId: effectiveSlateId,\n        action,\n        word,\n        metadata,\n      });\n    },\n    [slateId, currentSlateId]\n  );\n\n  // On load effect: prefer server-computed bonuses; fallback to level-only\n  useEffect(() => {\n    if (effectiveBonuses) {\n      setTime(DRAWING_DURATION + effectiveBonuses.extraDrawingTimeSeconds);\n      return;\n    }\n    const level = levelData?.level || userProfile?.level;\n    if (level) {\n      const extraTime = getExtraDrawingTime(level);\n      setTime(DRAWING_DURATION + extraTime);\n    }\n  }, [effectiveBonuses, levelData?.level, userProfile?.level]);\n\n  const handleOnComplete = useCallback((drawingData: DrawingData) => {\n    setDrawing(drawingData);\n    setStep('review');\n  }, []);\n\n  const selectCandidate = useCallback((word: string) => {\n    setSelectedWord(word);\n    setStep('draw');\n  }, []);\n\n  // Initialize tournament word on mount if provided\n  useEffect(() => {\n    if (\n      mode === 'tournament-comment' &&\n      tournamentWord &&\n      tournamentPostId &&\n      !selectedWord\n    ) {\n      setSelectedWord(tournamentWord);\n    }\n  }, [mode, tournamentWord, tournamentPostId, selectedWord]);\n\n  // Use prefetched level data for instant access, fallback to profile\n  const userLevel = levelData?.level || userProfile?.level || 1;\n\n  return (\n    <>\n      {/* Render current step */}\n      {step === 'word' && (\n        <WordStep\n          selectCandidate={selectCandidate}\n          slateId={slateId}\n          words={words}\n          isLoading={isSlateLoading}\n          refreshCandidates={refreshCandidates}\n          trackSlateAction={trackSlateAction}\n          userLevel={userLevel}\n        />\n      )}\n      {step === 'draw' && selectedWord && (\n        <DrawStep\n          word={selectedWord}\n          time={time}\n          onComplete={handleOnComplete}\n          slateId={slateId}\n          trackSlateAction={trackSlateAction}\n          userLevel={userLevel}\n        />\n      )}\n      {step === 'review' && selectedWord && (\n        <>\n          {mode === 'tournament-comment' && !!tournamentPostId ? (\n            <TournamentReviewStep\n              drawing={drawing}\n              onCancel={onClose}\n              {...(onSuccess && { onSuccess })}\n              tournamentPostId={tournamentPostId}\n            />\n          ) : (\n            <ReviewStep\n              word={selectedWord}\n              dictionary={`r/${subredditNameRef.current}`}\n              drawing={drawing}\n              onCancel={onClose}\n              onSuccess={onClose}\n              slateId={slateId}\n              trackSlateAction={trackSlateAction}\n            />\n          )}\n        </>\n      )}\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Editor/_components/DrawStep.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 14,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 14,
        "endColumn": 24,
        "fix": { "range": [663, 687], "text": "type DrawStepProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 78,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 78,
        "endColumn": 38,
        "fix": { "range": [2649, 2669], "text": "{ clearInterval(timer); }" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 126,
        "column": 56,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 126,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3921, 3923], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 369,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 369,
        "endColumn": 27,
        "fix": { "range": [11385, 11412], "text": "type ColorSwatchProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 380,
        "column": 22,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 380,
        "endColumn": 37,
        "fix": { "range": [11630, 11645], "text": "{ onSelect(color); }" }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 394,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 394,
        "endColumn": 37,
        "fix": {
          "range": [12168, 12205],
          "text": "type ColorPickerPlusButtonProps = "
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 411,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 411,
        "endColumn": 32,
        "fix": {
          "range": [12739, 12771],
          "text": "type ColorPickerModalProps = "
        }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 80,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 80,
        "endColumn": 41,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [startTime, time, onComplete, word, track]",
            "fix": {
              "range": [2736, 2771],
              "text": "[startTime, time, onComplete, word, track]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'drawingData.size' and 'track'. Either include them or remove the dependency array.",
        "line": 195,
        "column": 5,
        "nodeType": "ArrayExpression",
        "endLine": 195,
        "endColumn": 19,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [currentColor, drawingData.size, track]",
            "fix": {
              "range": [6224, 6238],
              "text": "[currentColor, drawingData.size, track]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'drawingData.size'. Either include it or remove the dependency array.",
        "line": 252,
        "column": 5,
        "nodeType": "ArrayExpression",
        "endLine": 252,
        "endColumn": 19,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [currentColor, drawingData.size]",
            "fix": {
              "range": [7790, 7804],
              "text": "[currentColor, drawingData.size]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'drawingData.size'. Either include it or remove the dependency array.",
        "line": 289,
        "column": 5,
        "nodeType": "ArrayExpression",
        "endLine": 289,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [isDrawing, drawingData.size, currentColor]",
            "fix": {
              "range": [8908, 8933],
              "text": "[isDrawing, drawingData.size, currentColor]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 6,
    "source": "import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Button } from '@components/Button';\nimport { Icon } from '@components/PixelFont';\nimport { DRAWING_COLORS, getAvailableExtendedColors } from '@client/constants';\nimport { DRAWING_DURATION } from '@shared/constants';\nimport { Text } from '@components/PixelFont';\nimport { DrawingData, DrawingUtils } from '@shared/schema/drawing';\nimport { getContrastColor } from '@shared/utils/color';\nimport type { HEX } from '@shared/types';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport type { SlateAction } from '@shared/types';\nimport { Modal } from '@components/Modal';\n\ninterface DrawStepProps {\n  word: string;\n  time: number;\n  onComplete: (drawing: DrawingData) => void;\n  slateId: string | null;\n  trackSlateAction: (\n    action: SlateAction,\n    word?: string,\n    metadata?: Record<string, string | number>\n  ) => Promise<void>;\n  userLevel: number;\n}\n\nexport function DrawStep(props: DrawStepProps) {\n  const { word, time, onComplete, slateId, trackSlateAction, userLevel } =\n    props;\n\n  const [startTime] = useState(Date.now());\n  const [elapsedTime, setElapsedTime] = useState(0);\n\n  const { track } = useTelemetry();\n\n  // Track draw step view on mount - use ref to ensure it only runs once\n  const hasTrackedView = useRef(false);\n  useEffect(() => {\n    if (!hasTrackedView.current) {\n      void track('view_draw_step');\n      void track('drawing_start');\n      hasTrackedView.current = true;\n    }\n  }, [track, trackSlateAction, word, slateId]);\n\n  // Canvas state\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [currentColor, setCurrentColor] = useState<HEX>('#000000');\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [drawingData, setDrawingData] = useState<DrawingData>(() =>\n    DrawingUtils.createBlank()\n  );\n  const hasTrackedFirstPixel = useRef(false);\n  const drawingDataRef = useRef<DrawingData>(DrawingUtils.createBlank());\n\n  // Color picker modal state\n  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n\n  const canvasInternalSize = 256;\n\n  // Keep drawingDataRef in sync with drawingData state\n  useEffect(() => {\n    drawingDataRef.current = drawingData;\n  }, [drawingData]);\n\n  // Timer effect\n  useEffect(() => {\n    const timer = setInterval(() => {\n      const currentElapsed = Date.now() - startTime;\n      setElapsedTime(currentElapsed);\n      const remainingTime = (time || DRAWING_DURATION) * 1000 - currentElapsed;\n      if (remainingTime <= 0) {\n        void track('drawing_done_auto');\n        onComplete(drawingDataRef.current);\n      }\n    }, 100);\n\n    return () => clearInterval(timer);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [startTime, time, onComplete, word]);\n\n  const secondsLeft = Math.max(\n    0,\n    Math.round((time || DRAWING_DURATION) - elapsedTime / 1000)\n  );\n\n  const handleDone = () => {\n    void track('click_done_drawing');\n    void track('drawing_done_manual');\n    onComplete(drawingData);\n  };\n\n  const handleOpenColorPicker = () => {\n    void track('click_color_picker_plus');\n    setIsColorPickerOpen(true);\n  };\n\n  const handleCloseColorPicker = () => {\n    setIsColorPickerOpen(false);\n  };\n\n  const handleSelectExtendedColor = (color: HEX) => {\n    void track('select_extended_color');\n    setCurrentColor(color);\n    setIsColorPickerOpen(false);\n  };\n\n  // Render canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set internal canvas resolution to 16x16\n    canvas.width = canvasInternalSize;\n    canvas.height = canvasInternalSize;\n\n    // Disable image smoothing for pixelated rendering\n    ctx.imageSmoothingEnabled = false;\n\n    ctx.clearRect(0, 0, canvasInternalSize, canvasInternalSize);\n\n    // Draw background\n    ctx.fillStyle = drawingData.colors[drawingData.bg] || '#FFFFFF';\n    ctx.fillRect(0, 0, canvasInternalSize, canvasInternalSize);\n\n    // Draw pixels (optimized rendering)\n    const pixelColors = DrawingUtils.getAllPixelColors(drawingData);\n    const pixelSize = canvasInternalSize / drawingData.size;\n\n    for (let pixelIndex = 0; pixelIndex < pixelColors.length; pixelIndex++) {\n      const color = pixelColors[pixelIndex];\n\n      if (color && color !== drawingData.colors[drawingData.bg]) {\n        ctx.fillStyle = color;\n        const pixelX = pixelIndex % drawingData.size;\n        const pixelY = Math.floor(pixelIndex / drawingData.size);\n        const x = pixelX * pixelSize;\n        const y = pixelY * pixelSize;\n\n        ctx.fillRect(x, y, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw checkerboard overlay\n    for (let x = 0; x < drawingData.size; x++) {\n      for (let y = 0; y < drawingData.size; y++) {\n        const isEven = (x + y) % 2 === 0;\n        ctx.fillStyle = isEven\n          ? 'rgba(255, 255, 255, 0.05)'\n          : 'rgba(0, 0, 0, 0.05)';\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n  }, [drawingData, canvasInternalSize]);\n\n  const handlePixelClick = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n\n      const rect = canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      // Convert to normalized coordinates (0-1)\n      const normalizedX = x / rect.width;\n      const normalizedY = y / rect.height;\n\n      const pixelX = Math.floor(normalizedX * drawingData.size);\n      const pixelY = Math.floor(normalizedY * drawingData.size);\n\n      if (\n        pixelX >= 0 &&\n        pixelX < drawingData.size &&\n        pixelY >= 0 &&\n        pixelY < drawingData.size\n      ) {\n        const index = pixelY * drawingData.size + pixelX;\n        setDrawingData((prev) =>\n          DrawingUtils.setPixel(prev, index, currentColor)\n        );\n\n        // Track first pixel drawn\n        if (!hasTrackedFirstPixel.current) {\n          void track('first_pixel_drawn');\n          void track('drawing_first_pixel');\n          hasTrackedFirstPixel.current = true;\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [currentColor]\n  );\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      setIsDrawing(true);\n      handlePixelClick(e);\n    },\n    [handlePixelClick]\n  );\n\n  const handleMouseMove = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!isDrawing) return;\n      handlePixelClick(e);\n    },\n    [isDrawing, handlePixelClick]\n  );\n\n  const handleMouseUp = useCallback(() => {\n    setIsDrawing(false);\n  }, []);\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent<HTMLCanvasElement>) => {\n      e.preventDefault();\n      setIsDrawing(true);\n      const touch = e.touches[0];\n      if (touch) {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const rect = canvas.getBoundingClientRect();\n        const x = touch.clientX - rect.left;\n        const y = touch.clientY - rect.top;\n\n        // Convert to normalized coordinates (0-1)\n        const normalizedX = x / rect.width;\n        const normalizedY = y / rect.height;\n\n        const pixelX = Math.floor(normalizedX * drawingData.size);\n        const pixelY = Math.floor(normalizedY * drawingData.size);\n\n        if (\n          pixelX >= 0 &&\n          pixelX < drawingData.size &&\n          pixelY >= 0 &&\n          pixelY < drawingData.size\n        ) {\n          const index = pixelY * drawingData.size + pixelX;\n          setDrawingData((prev) =>\n            DrawingUtils.setPixel(prev, index, currentColor)\n          );\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [currentColor]\n  );\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent<HTMLCanvasElement>) => {\n      if (!isDrawing) return;\n      e.preventDefault();\n      const touch = e.touches[0];\n      if (touch) {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const rect = canvas.getBoundingClientRect();\n        const x = touch.clientX - rect.left;\n        const y = touch.clientY - rect.top;\n\n        // Convert to normalized coordinates (0-1)\n        const normalizedX = x / rect.width;\n        const normalizedY = y / rect.height;\n\n        const pixelX = Math.floor(normalizedX * drawingData.size);\n        const pixelY = Math.floor(normalizedY * drawingData.size);\n\n        if (\n          pixelX >= 0 &&\n          pixelX < drawingData.size &&\n          pixelY >= 0 &&\n          pixelY < drawingData.size\n        ) {\n          const index = pixelY * drawingData.size + pixelX;\n          setDrawingData((prev) =>\n            DrawingUtils.setPixel(prev, index, currentColor)\n          );\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [isDrawing, currentColor]\n  );\n\n  const handleTouchEnd = useCallback(\n    (e: React.TouchEvent<HTMLCanvasElement>) => {\n      e.preventDefault();\n      setIsDrawing(false);\n    },\n    []\n  );\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-center p-6 gap-6\">\n      {/* Header */}\n      <header className=\"flex flex-row items-center justify-center h-min w-full gap-3\">\n        <div className=\"flex flex-col items-start justify-center gap-1 w-full h-full flex-1\">\n          <Text scale={2.5}>{word}</Text>\n          <div className=\"flex flex-row items-center gap-2 text-secondary\">\n            <Icon type=\"clock\" />\n            <Text scale={2}>{`${secondsLeft}s left`}</Text>\n          </div>\n        </div>\n\n        <Button onClick={handleDone} size=\"medium\">\n          DONE\n        </Button>\n      </header>\n\n      {/* Canvas */}\n      <div className=\"flex-1 flex items-center justify-center relative\">\n        <canvas\n          ref={canvasRef}\n          className=\"cursor-crosshair w-full h-full max-w-full max-h-full aspect-square pixel-shadow\"\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onTouchStart={handleTouchStart}\n          onTouchMove={handleTouchMove}\n          onTouchEnd={handleTouchEnd}\n        />\n        {DrawingUtils.isEmpty(drawingData) && (\n          <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n            <Text scale={2} className=\"text-tertiary\">\n              Tap to draw\n            </Text>\n          </div>\n        )}\n      </div>\n\n      {/* Color Palette */}\n      <div className=\"flex flex-row gap-2 items-center justify-center\">\n        {DRAWING_COLORS.map((color) => (\n          <ColorSwatch\n            key={color}\n            onSelect={() => {\n              void track('click_color_swatch');\n              setCurrentColor(color);\n            }}\n            color={color}\n            isSelected={currentColor === color}\n          />\n        ))}\n        {userLevel >= 2 && (\n          <ColorPickerPlusButton onClick={handleOpenColorPicker} />\n        )}\n      </div>\n\n      {/* Color Picker Modal */}\n      <ColorPickerModal\n        isOpen={isColorPickerOpen}\n        onClose={handleCloseColorPicker}\n        onSelectColor={handleSelectExtendedColor}\n        currentColor={currentColor}\n        userLevel={userLevel}\n      />\n    </main>\n  );\n}\n\ninterface ColorSwatchProps {\n  color: HEX;\n  isSelected: boolean;\n  onSelect: (color: HEX) => void;\n}\n\nfunction ColorSwatch(props: ColorSwatchProps) {\n  const { color, isSelected, onSelect } = props;\n\n  return (\n    <button\n      onClick={() => onSelect(color)}\n      className=\"w-8 h-8 border-4 border-black cursor-pointer transition-all flex items-center justify-center hover:translate-x-[2px] hover:translate-y-[2px] active:translate-x-[4px] active:translate-y-[4px] shadow-pixel hover:shadow-pixel-sm active:shadow-none\"\n      style={{ backgroundColor: color }}\n    >\n      <Icon\n        type=\"checkmark\"\n        scale={2}\n        color={getContrastColor(color)}\n        className={`transition-opacity ${isSelected ? 'opacity-100' : 'opacity-0'}`}\n      />\n    </button>\n  );\n}\n\ninterface ColorPickerPlusButtonProps {\n  onClick: () => void;\n}\n\nfunction ColorPickerPlusButton(props: ColorPickerPlusButtonProps) {\n  const { onClick } = props;\n\n  return (\n    <button\n      onClick={onClick}\n      className=\"w-8 h-8 border-4 border-black cursor-pointer transition-all flex items-center justify-center hover:translate-x-[2px] hover:translate-y-[2px] active:translate-x-[4px] active:translate-y-[4px] shadow-pixel hover:shadow-pixel-sm active:shadow-none bg-gray-200\"\n    >\n      <Icon type=\"plus\" scale={2} color=\"currentColor\" />\n    </button>\n  );\n}\n\ninterface ColorPickerModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSelectColor: (color: HEX) => void;\n  currentColor: HEX;\n  userLevel: number;\n}\n\nfunction ColorPickerModal(props: ColorPickerModalProps) {\n  const { isOpen, onClose, onSelectColor, currentColor, userLevel } = props;\n  const availableColors = getAvailableExtendedColors(userLevel);\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"Select a color\">\n      <div className=\"grid grid-cols-7 gap-2\">\n        {availableColors.map((color) => (\n          <ColorSwatch\n            key={color}\n            color={color}\n            isSelected={currentColor === color}\n            onSelect={onSelectColor}\n          />\n        ))}\n      </div>\n    </Modal>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Editor/_components/ReviewStep.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 15,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 15,
        "endColumn": 26,
        "fix": { "range": [631, 657], "text": "type ReviewStepProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 164,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 164,
        "endColumn": 51,
        "fix": {
          "range": [4835, 4862],
          "text": "{ setShowCancelConfirm(false); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 175,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 175,
        "endColumn": 39,
        "fix": {
          "range": [4963, 5002],
          "text": "type DeleteConfirmationModalProps = "
        }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 72,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 72,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [2272, 2274], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import { useState } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { Button } from '@components/Button';\nimport { Drawing } from '@components/Drawing';\nimport { Modal } from '@components/Modal';\nimport { trpc } from '@client/trpc/client';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { Text } from '@components/PixelFont';\nimport { navigateTo } from '@devvit/web/client';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { useEffect } from 'react';\nimport type { SlateAction } from '@shared/types';\nimport { renderDrawingToCanvas } from '@shared/utils/drawing';\n\ninterface ReviewStepProps {\n  word: string;\n  dictionary: string;\n  drawing: DrawingData;\n  onCancel: () => void;\n  onSuccess?: (result: {\n    success: boolean;\n    postId: string;\n    navigateTo?: string;\n  }) => void;\n  slateId: string | null;\n  trackSlateAction: (\n    action: SlateAction,\n    word?: string,\n    metadata?: Record<string, string | number>\n  ) => Promise<void>;\n}\n\n/**\n * Generate a PNG data URL from DrawingData\n * @param drawingData - The drawing data to convert to PNG\n * @returns Base64-encoded PNG data URL\n */\nfunction generatePNGFromDrawing(drawingData: DrawingData): string {\n  // Create an off-screen canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 256;\n  canvas.height = 256;\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return '';\n\n  // Disable image smoothing for crisp pixels\n  ctx.imageSmoothingEnabled = false;\n\n  // Create a temporary canvas for the original drawing\n  const tempCanvas = document.createElement('canvas');\n  renderDrawingToCanvas(drawingData, tempCanvas);\n\n  // Scale the drawing to 256x256\n  ctx.drawImage(tempCanvas, 0, 0, 256, 256);\n\n  // Convert to PNG data URL\n  return canvas.toDataURL('image/png');\n}\n\nexport function ReviewStep(props: ReviewStepProps) {\n  const { word, dictionary, drawing, onCancel, onSuccess, trackSlateAction } =\n    props;\n  const [showCancelConfirm, setShowCancelConfirm] = useState(false);\n  const queryClient = useQueryClient();\n  const { track } = useTelemetry();\n\n  // Track review step view on mount\n  useEffect(() => {\n    void track('view_review_step');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const submitDrawing = trpc.app.post.submitDrawing.useMutation({\n    onSuccess: () => {\n      // Invalidate relevant queries\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'user', 'drawings'],\n      });\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'leaderboard'],\n      });\n\n      // Optionally refetch user profile to update score\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'user', 'profile'],\n      });\n    },\n  });\n\n  const handlePost = async () => {\n    void track('click_post_drawing');\n\n    try {\n      // Generate PNG from drawing data\n      const imageData = generatePNGFromDrawing(drawing);\n\n      const result = await submitDrawing.mutateAsync({\n        word,\n        dictionary: dictionary,\n        drawing: drawing,\n        imageData,\n      });\n\n      if (result.success) {\n        // Track slate publish - await to ensure delivery before navigation\n        await trackSlateAction('slate_posted', word);\n\n        if (result.navigateTo) {\n          navigateTo(result.navigateTo);\n        } else if (onSuccess) {\n          onSuccess(result);\n        }\n      } else {\n        // Handle unsuccessful submission\n      }\n    } catch (error) {\n      // Handle submission error\n    }\n  };\n\n  const handleCancel = () => {\n    void track('click_cancel_drawing');\n    setShowCancelConfirm(true);\n  };\n\n  const confirmCancel = () => {\n    onCancel();\n    setShowCancelConfirm(false);\n  };\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-center h-full gap-6 p-6\">\n      {/* Header */}\n      <Text scale={3}>That's a wrap!</Text>\n\n      {/* Drawing Preview */}\n      <Drawing data={drawing} size={256} />\n\n      {/* Instructions */}\n      <div className=\"flex flex-col items-center justify-center gap-1 text-center text-secondary\">\n        <Text scale={2}>Post your drawing</Text>\n        <Text scale={2}>and earn points for</Text>\n        <Text scale={2}>every correct guess!</Text>\n      </div>\n\n      {/* Action Buttons */}\n      <div className=\"flex flex-row gap-3\">\n        <Button\n          variant=\"secondary\"\n          onClick={handleCancel}\n          disabled={submitDrawing.isPending}\n        >\n          DELETE\n        </Button>\n\n        <Button onClick={handlePost} disabled={submitDrawing.isPending}>\n          {submitDrawing.isPending ? 'POSTING...' : 'POST'}\n        </Button>\n      </div>\n\n      {/* Delete Confirmation Modal */}\n      <DeleteConfirmationModal\n        isOpen={showCancelConfirm}\n        onClose={() => setShowCancelConfirm(false)}\n        onDelete={confirmCancel}\n      />\n    </main>\n  );\n}\n\n/*\n * Delete Confirmation Modal\n */\n\ninterface DeleteConfirmationModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onDelete: () => void;\n}\n\nfunction DeleteConfirmationModal(props: DeleteConfirmationModalProps) {\n  const { isOpen, onClose, onDelete } = props;\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"Delete drawing?\">\n      {/* Body Copy - Concise and to the point. */}\n      <div className=\"flex flex-col gap-1 items-center justify-center w-full\">\n        <Text>You cannot undo</Text>\n        <Text>this action later</Text>\n      </div>\n\n      {/* Actions - The primary action has been placed on the left side and deemphasized to avoid accidental misclicks given the severity of the action.\n       */}\n      <div className=\"flex flex-row gap-3 items-center justify-center w-full\">\n        <Button variant=\"white\" onClick={onDelete}>\n          Delete\n        </Button>\n        <Button onClick={onClose}>Cancel</Button>\n      </div>\n    </Modal>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Editor/_components/TournamentReviewStep.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 12,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 12,
        "endColumn": 36,
        "fix": {
          "range": [497, 533],
          "text": "type TournamentReviewStepProps = "
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 135,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 135,
        "endColumn": 51,
        "fix": {
          "range": [3879, 3906],
          "text": "{ setShowCancelConfirm(false); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 142,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 142,
        "endColumn": 39,
        "fix": {
          "range": [3970, 4009],
          "text": "type DeleteConfirmationModalProps = "
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import { useState } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { Button } from '@components/Button';\nimport { Drawing } from '@components/Drawing';\nimport { Modal } from '@components/Modal';\nimport { trpc } from '@client/trpc/client';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { Text } from '@components/PixelFont';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { renderDrawingToCanvas } from '@shared/utils/drawing';\n\ninterface TournamentReviewStepProps {\n  drawing: DrawingData;\n  onCancel: () => void;\n  onSuccess?: () => void;\n  tournamentPostId: string;\n}\n\nfunction generatePNGFromDrawing(drawingData: DrawingData): string {\n  const canvas = document.createElement('canvas');\n  canvas.width = 256;\n  canvas.height = 256;\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return '';\n\n  ctx.imageSmoothingEnabled = false;\n\n  const tempCanvas = document.createElement('canvas');\n  renderDrawingToCanvas(drawingData, tempCanvas);\n\n  ctx.drawImage(tempCanvas, 0, 0, 256, 256);\n\n  return canvas.toDataURL('image/png');\n}\n\nexport function TournamentReviewStep(props: TournamentReviewStepProps) {\n  const { drawing, onCancel, onSuccess, tournamentPostId } = props;\n  const [showCancelConfirm, setShowCancelConfirm] = useState(false);\n  const queryClient = useQueryClient();\n  const { track } = useTelemetry();\n\n  const submitTournamentDrawing = trpc.app.tournament.submitDrawing.useMutation(\n    {\n      onSuccess: async () => {\n        // Invalidate and refetch all tournament queries\n        await queryClient.invalidateQueries({\n          queryKey: ['pixelary', 'app', 'tournament'],\n        });\n        // Refetch stats and submissions for the specific post\n        await queryClient.refetchQueries({\n          queryKey: ['pixelary', 'app', 'tournament', 'getStats'],\n          exact: false,\n        });\n        await queryClient.refetchQueries({\n          queryKey: [\n            'pixelary',\n            'app',\n            'tournament',\n            'getSubmissionsWithDrawings',\n          ],\n          exact: false,\n        });\n      },\n    }\n  );\n\n  const handlePost = async () => {\n    void track('click_post_drawing');\n\n    try {\n      const imageData = generatePNGFromDrawing(drawing);\n\n      console.log(\n        'TournamentReviewStep: Submitting with postId:',\n        tournamentPostId\n      );\n\n      await submitTournamentDrawing.mutateAsync({\n        postId: tournamentPostId,\n        drawing,\n        imageData,\n      });\n\n      console.log('TournamentReviewStep: Submission successful');\n\n      if (onSuccess) {\n        onSuccess();\n      }\n    } catch (error) {\n      console.error('Failed to submit tournament drawing:', error);\n    }\n  };\n\n  const handleCancel = () => {\n    void track('click_cancel_drawing');\n    setShowCancelConfirm(true);\n  };\n\n  const confirmCancel = () => {\n    onCancel();\n    setShowCancelConfirm(false);\n  };\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-center h-full gap-6 p-6\">\n      <Text scale={3}>That's a wrap!</Text>\n\n      <Drawing data={drawing} size={256} />\n\n      <div className=\"flex flex-col items-center justify-center gap-1 text-center text-secondary\">\n        <Text scale={2}>Submit your drawing</Text>\n        <Text scale={2}>to join tournament.</Text>\n      </div>\n\n      <div className=\"flex flex-row gap-3\">\n        <Button\n          variant=\"secondary\"\n          onClick={handleCancel}\n          disabled={submitTournamentDrawing.isPending}\n        >\n          DELETE\n        </Button>\n\n        <Button\n          onClick={handlePost}\n          disabled={submitTournamentDrawing.isPending}\n        >\n          {submitTournamentDrawing.isPending ? 'SUBMITTING...' : 'SUBMIT'}\n        </Button>\n      </div>\n\n      <DeleteConfirmationModal\n        isOpen={showCancelConfirm}\n        onClose={() => setShowCancelConfirm(false)}\n        onDelete={confirmCancel}\n      />\n    </main>\n  );\n}\n\ninterface DeleteConfirmationModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onDelete: () => void;\n}\n\nfunction DeleteConfirmationModal(props: DeleteConfirmationModalProps) {\n  const { isOpen, onClose, onDelete } = props;\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"Delete drawing?\">\n      <div className=\"flex flex-col gap-1 items-center justify-center w-full\">\n        <Text>You cannot undo</Text>\n        <Text>this action later</Text>\n      </div>\n\n      <div className=\"flex flex-row gap-3 items-center justify-center w-full\">\n        <Button variant=\"white\" onClick={onDelete}>\n          Delete\n        </Button>\n        <Button onClick={onClose}>Cancel</Button>\n      </div>\n    </Modal>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Editor/_components/WordStep.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 8,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 8,
        "endColumn": 24,
        "fix": { "range": [323, 347], "text": "type WordStepProps = " }
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 11,
        "column": 10,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 11,
        "endColumn": 27,
        "fix": { "range": [427, 444], "text": "Array<string | null>" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 83,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 83,
        "endColumn": 38,
        "fix": { "range": [2365, 2385], "text": "{ clearInterval(timer); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 114,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 114,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [3393, 3395], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 116,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 116,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3505, 3507], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Placing a void expression inside another expression is forbidden. Move it to its own statement instead.",
        "line": 150,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExpr",
        "endLine": 150,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 164,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 164,
        "endColumn": 29,
        "fix": { "range": [4718, 4747], "text": "type WordCandidateProps = " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 44,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 44,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1244, 1246], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'trackSlateAction'. Either include it or remove the dependency array.",
        "line": 66,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 66,
        "endColumn": 26,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [slateId, isLoading, trackSlateAction]",
            "fix": {
              "range": [1958, 1978],
              "text": "[slateId, isLoading, trackSlateAction]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import { useState, useEffect, useRef } from 'react';\nimport { CARD_DRAW_DURATION } from '@shared/constants';\nimport { getExtraWordTime } from '@shared/rewards';\nimport { Text, Icon } from '@components/PixelFont';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport type { SlateAction } from '@shared/types';\n\ninterface WordStepProps {\n  selectCandidate: (word: string) => void;\n  slateId: string | null;\n  words: (string | null)[];\n  isLoading: boolean;\n  refreshCandidates: () => void;\n  trackSlateAction: (\n    action: SlateAction,\n    word?: string,\n    metadata?: Record<string, string | number>\n  ) => Promise<void>;\n  userLevel: number;\n}\n\nexport function WordStep(props: WordStepProps) {\n  const {\n    selectCandidate,\n    slateId,\n    words,\n    isLoading,\n    refreshCandidates,\n    trackSlateAction,\n    userLevel,\n  } = props;\n\n  // State management\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const trackedSlateIdRef = useRef<string | null>(null);\n\n  const { track } = useTelemetry();\n\n  // Track word step view on mount\n  useEffect(() => {\n    void track('view_word_step');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Debug slate data\n  useEffect(() => {\n    // Slate data debug\n  }, [slateId, isLoading, words]);\n\n  // Track slate impression when slateId is available\n  useEffect(() => {\n    // Only proceed if we have a valid slateId and query is complete\n    if (slateId && !isLoading && slateId !== trackedSlateIdRef.current) {\n      trackedSlateIdRef.current = slateId;\n\n      // Track impression after ensuring context is updated\n      // Use setTimeout to ensure React state update has completed\n      setTimeout(() => {\n        trackSlateAction('slate_served').catch(() => {\n          // Failed to track slate served\n        });\n      }, 0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [slateId, isLoading]);\n\n  // Start timer when words load\n  useEffect(() => {\n    if (!isLoading && words.length > 0 && startTime === null) {\n      setStartTime(Date.now());\n    }\n  }, [isLoading, words, startTime]);\n\n  // Timer effect\n  useEffect(() => {\n    if (startTime === null) return;\n\n    const timer = setInterval(() => {\n      setElapsedTime(Date.now() - startTime);\n    }, 100);\n\n    return () => clearInterval(timer);\n  }, [startTime]);\n\n  // Calculate total word selection time with reward\n  const totalWordTime = CARD_DRAW_DURATION + getExtraWordTime(userLevel);\n\n  // Auto-select effect\n  useEffect(() => {\n    const remainingTime = totalWordTime * 1000 - elapsedTime;\n    if (remainingTime <= 0 && words.length > 0 && words[0]) {\n      // Track auto-select before selecting\n      void trackSlateAction('slate_picked', words[0], {\n        selectionType: 'auto',\n      });\n      selectCandidate(words[0]);\n    }\n  }, [elapsedTime, selectCandidate, words, trackSlateAction, totalWordTime]);\n\n  // Derived state\n  const secondsLeft = Math.max(\n    0,\n    Math.round(totalWordTime - elapsedTime / 1000)\n  );\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col gap-6 p-6 items-center justify-center\">\n      {/* Page Title */}\n      <Text scale={3}>Pick a word</Text>\n\n      {/* Word Candidates */}\n      <div className=\"flex flex-col gap-3 items-center justify-center h-full w-full max-w-xs flex-1\">\n        {words?.map((word: string | null, index: number) => (\n          <WordCandidate\n            key={`word-${index}-${word || 'loading'}`}\n            word={word}\n            index={index}\n            isLoading={isLoading}\n            onSelect={selectCandidate}\n            trackSlateAction={trackSlateAction}\n          />\n        ))}\n      </div>\n\n      {/* Timer */}\n      <div className=\"flex flex-row items-center justify-center gap-4\">\n        <Icon\n          scale={3}\n          type=\"arrow-right\"\n          className={secondsLeft > 2 ? 'text-tertiary' : 'text-orangered'}\n        />\n        <Text\n          scale={3}\n          className={secondsLeft > 2 ? 'text-primary' : 'text-orangered'}\n        >\n          {secondsLeft.toString()}\n        </Text>\n        <Icon\n          scale={3}\n          type=\"arrow-left\"\n          className={secondsLeft > 2 ? 'text-tertiary' : 'text-orangered'}\n        />\n      </div>\n\n      {/* Refresh Button */}\n      <button\n        onClick={() => {\n          void track('click_refresh_words');\n          void refreshCandidates();\n        }}\n        className=\"flex items-center hover:opacity-70 transition-opacity p-6 absolute right-0 bottom-0 cursor-pointer\"\n      >\n        <Icon scale={3} type=\"undo\" className=\"text-secondary\" />\n      </button>\n    </main>\n  );\n}\n\n/*\n * Word Candidate\n */\n\ninterface WordCandidateProps {\n  word: string | null;\n  index: number;\n  isLoading: boolean;\n  onSelect: (word: string) => void;\n  trackSlateAction: (\n    action: SlateAction,\n    word?: string,\n    metadata?: Record<string, string | number>\n  ) => Promise<void>;\n}\n\nfunction WordCandidate(props: WordCandidateProps) {\n  const { word, index, isLoading, onSelect, trackSlateAction } = props;\n  const { track } = useTelemetry();\n\n  return (\n    <button\n      onClick={() => {\n        if (word) {\n          void track('click_word_candidate');\n          void trackSlateAction('slate_picked', word, {\n            selectionType: 'manual',\n          });\n          onSelect(word);\n        }\n      }}\n      disabled={isLoading}\n      className=\"bg-white border-4 border-black shadow-pixel cursor-pointer w-full h-1/3 flex flex-col gap-2 items-center justify-center\"\n    >\n      {/* Word */}\n      <div className=\"flex flex-row items-center justify-center gap-2\">\n        {index === 0 && !isLoading && (\n          <Icon\n            scale={2}\n            type=\"arrow-right\"\n            color=\"currentColor\"\n            className=\"text-orangered animate-nudge-right\"\n          />\n        )}\n        {isLoading || !word ? (\n          <div className=\"w-16 h-3.5 skeleton\" />\n        ) : (\n          <Text scale={2}>{word}</Text>\n        )}\n        {index === 0 && !isLoading && (\n          <Icon\n            scale={2}\n            type=\"arrow-left\"\n            color=\"currentColor\"\n            className=\"text-orangered animate-nudge-left\"\n          />\n        )}\n      </div>\n\n      {/* Dictionary name - removed since we're just using strings now */}\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ErrorBoundary.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 6,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 6,
        "endColumn": 29,
        "fix": { "range": [158, 187], "text": "type ErrorBoundaryState = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 12,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 12,
        "endColumn": 29,
        "fix": { "range": [277, 306], "text": "type ErrorBoundaryProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { Component } from 'react';\nimport type { ErrorInfo, ReactNode } from 'react';\nimport { Text } from './PixelFont';\nimport { Button } from './Button';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | undefined;\n  errorInfo: ErrorInfo | undefined;\n}\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\n/**\n * Root-level error boundary that catches all unhandled React errors\n * Displays a full-page error screen with pixel art styling\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: undefined, errorInfo: undefined };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error, errorInfo: undefined };\n  }\n\n  override componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    this.setState({ errorInfo });\n    this.props.onError?.(error, errorInfo);\n  }\n\n  private handleReload = () => {\n    window.location.reload();\n  };\n\n  private handleRetry = () => {\n    this.setState({ hasError: false, error: undefined, errorInfo: undefined });\n  };\n\n  override render() {\n    if (this.state.hasError) {\n      const isDevelopment = import.meta.env.DEV;\n\n      return (\n        <div className=\"min-h-screen bg-gray-100 flex items-center justify-center p-4\">\n          <div className=\"max-w-2xl w-full\">\n            {/* Main Error Card */}\n            <div className=\"bg-white border-4 border-black shadow-pixel-lg p-8\">\n              {/* Error Icon */}\n              <div className=\"text-center mb-6\">\n                <div className=\"text-6xl mb-4\"></div>\n                <Text scale={3} className=\"text-error\">\n                  Oops! Something went wrong\n                </Text>\n              </div>\n\n              {/* Error Message */}\n              <div className=\"text-center mb-8\">\n                <Text scale={2} className=\"text-gray-700 mb-4\">\n                  The application encountered an unexpected error.\n                </Text>\n                {this.state.error && (\n                  <div className=\"bg-gray-100 border-2 border-gray-300 p-4 rounded\">\n                    <Text scale={1} className=\"text-error font-mono text-left\">\n                      {this.state.error.message}\n                    </Text>\n                  </div>\n                )}\n              </div>\n\n              {/* Action Buttons */}\n              <div className=\"flex flex-col sm:flex-row gap-4 justify-center\">\n                <Button onClick={this.handleRetry} variant=\"secondary\">\n                  Try Again\n                </Button>\n                <Button onClick={this.handleReload}>Reload Page</Button>\n              </div>\n\n              {/* Development Stack Trace */}\n              {isDevelopment && this.state.errorInfo && (\n                <details className=\"mt-8\">\n                  <summary className=\"cursor-pointer mb-4\">\n                    <Text scale={1} className=\"text-gray-600\">\n                      Show Error Details (Development)\n                    </Text>\n                  </summary>\n                  <div className=\"bg-gray-900 text-success p-4 rounded border-2 border-gray-600 font-mono text-xs overflow-auto max-h-64\">\n                    <div className=\"mb-2\">\n                      <strong>Error:</strong> {this.state.error?.toString()}\n                    </div>\n                    <div>\n                      <strong>Component Stack:</strong>\n                      <pre className=\"whitespace-pre-wrap mt-2\">\n                        {this.state.errorInfo.componentStack}\n                      </pre>\n                    </div>\n                  </div>\n                </details>\n              )}\n            </div>\n\n            {/* Footer */}\n            <div className=\"text-center mt-6\">\n              <Text scale={1} className=\"text-gray-500\">\n                If this problem persists, please contact support.\n              </Text>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/IconButton.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 6,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 6,
        "endColumn": 26,
        "fix": { "range": [204, 230], "text": "type IconButtonProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { Icon } from './PixelFont';\nimport type { SupportedGlyph } from './PixelFont';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport type { TelemetryEventType } from '@shared/types';\n\ninterface IconButtonProps {\n  symbol: SupportedGlyph;\n  onClick?: () => void;\n  variant?: 'primary' | 'secondary';\n  size?: 'small' | 'medium' | 'large';\n  disabled?: boolean;\n  className?: string;\n  telemetryEvent?: TelemetryEventType;\n}\n\nexport function IconButton({\n  symbol,\n  onClick,\n  variant = 'primary',\n  size = 'medium',\n  disabled = false,\n  className = '',\n  telemetryEvent,\n}: IconButtonProps) {\n  const { track } = useTelemetry();\n  const baseClasses =\n    'relative inline-flex items-center justify-center border-4 transition-all duration-150 shrink-0';\n\n  const variantClasses = {\n    primary: disabled\n      ? 'bg-gray-300 border-gray-300 text-gray-500 cursor-not-allowed'\n      : 'bg-black border-black text-white hover:bg-gray-800 cursor-pointer active:bg-gray-900',\n    secondary: disabled\n      ? 'bg-gray-200 border-gray-300 text-gray-500 cursor-not-allowed'\n      : 'bg-background border-black text-black hover:bg-background/90 cursor-pointer active:bg-background/80',\n  };\n\n  const sizeClasses = {\n    small: 'w-6 h-6',\n    medium: 'w-8 h-8',\n    large: 'w-10 h-10',\n  };\n\n  const fontScales = {\n    small: 1,\n    medium: 2,\n    large: 2.5,\n  };\n\n  const shadowClasses = disabled\n    ? ''\n    : 'hover:translate-x-[2px] hover:translate-y-[2px] active:translate-x-[4px] active:translate-y-[4px]';\n\n  const handleClick = () => {\n    // Track telemetry if provided\n    if (telemetryEvent) {\n      void track(telemetryEvent);\n    }\n\n    // Call original onClick\n    onClick?.();\n  };\n\n  return (\n    <button\n      onClick={disabled ? undefined : handleClick}\n      disabled={disabled}\n      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${shadowClasses} shadow-pixel hover:shadow-pixel-sm active:shadow-none ${className}`}\n    >\n      <Icon\n        type={symbol}\n        scale={fontScales[size]}\n        color={\n          variant === 'primary'\n            ? disabled\n              ? 'currentColor'\n              : 'currentColor'\n            : disabled\n              ? 'currentColor'\n              : 'currentColor'\n        }\n      />\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/LevelUpModal.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 11,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 11,
        "endColumn": 28,
        "fix": { "range": [393, 421], "text": "type LevelUpModalProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 67,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 67,
        "endColumn": 26,
        "fix": { "range": [1853, 1879], "text": "type RewardItemProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { Confetti } from './Confetti';\nimport { Text } from './PixelFont';\nimport { Button } from './Button';\nimport { Icon } from './PixelFont';\nimport { ModalScrim } from './ModalScrim';\nimport { ModalBody } from './ModalBody';\nimport { getRewardsByLevel, getRewardLabel } from '@shared/rewards';\nimport type { RewardType } from '@shared/rewards';\nimport { createPortal } from 'react-dom';\n\ninterface LevelUpModalProps {\n  level: number;\n  onClaim: () => void;\n}\n\n/**\n * Level up modal component\n */\n\nexport function LevelUpModal(props: LevelUpModalProps) {\n  const { level, onClaim } = props;\n  const rewards = getRewardsByLevel(level);\n  const rewardCount = rewards.length;\n\n  const content = (\n    <ModalScrim persistent>\n      {/* Continuous confetti */}\n      <Confetti count={Infinity} delay={10} speed={4} />\n\n      <ModalBody>\n        {/* Title */}\n        <Text scale={4} className=\"text-primary\">\n          {`Level ${level}!`}\n        </Text>\n\n        {/* Description */}\n        <div className=\"flex flex-col items-center gap-3\">\n          <Text scale={2} className=\"text-success\">\n            You leveled up,\n          </Text>\n          <Text scale={2} className=\"text-success\">\n            {`earning reward${rewardCount === 1 ? '' : 's'}!`}\n          </Text>\n        </div>\n\n        {/* Rewards */}\n        <div className=\"flex flex-col gap-3 w-full\">\n          {rewards.map((reward: RewardType) => (\n            <RewardItem key={reward} reward={reward} level={level} />\n          ))}\n        </div>\n\n        {/* Claim button */}\n        <Button onClick={onClaim} size=\"large\">\n          {`CLAIM REWARD${rewardCount === 1 ? '' : 'S'}`}\n        </Button>\n      </ModalBody>\n    </ModalScrim>\n  );\n\n  const portalRoot = document.getElementById('portal-root');\n  if (!portalRoot) return null;\n\n  return createPortal(content, portalRoot);\n}\n\ninterface RewardItemProps {\n  reward: RewardType;\n  level: number;\n}\n\n/**\n * Reward item component for the level up modal\n */\n\nfunction RewardItem(props: RewardItemProps) {\n  const { reward, level } = props;\n  const label = getRewardLabel(reward, level);\n  return (\n    <div className=\"flex items-center gap-3\">\n      <Icon type=\"checkmark\" className=\"text-success\" scale={2} />\n      <Text scale={2}>{label}</Text>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/LevelUpProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Lightbox.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 7,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 7,
        "endColumn": 24,
        "fix": { "range": [232, 256], "text": "type LightboxProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useEffect, type ReactNode } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Drawing } from './Drawing';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { Icon, Text } from './PixelFont';\n\ninterface LightboxProps {\n  isOpen: boolean;\n  onClose: () => void;\n  drawing: DrawingData;\n  author?: string | undefined;\n  children?: ReactNode;\n}\n\nexport function Lightbox({\n  isOpen,\n  onClose,\n  drawing,\n  author,\n  children,\n}: LightboxProps) {\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen, onClose]);\n\n  if (!isOpen) return null;\n\n  const lightboxContent = (\n    <div\n      className=\"absolute inset-0 flex flex-col p-6 gap-6 items-center justify-center bg-black-90\"\n      onClick={onClose}\n    >\n      {/* Drawing container */}\n      <Drawing data={drawing} size={288} />\n\n      <div className=\"flex flex-col items-center justify-center gap-2 text-white\">\n        {/* Author (built-in) */}\n        {author && <Text scale={3}>{`By u/${author}`}</Text>}\n\n        {/* Custom metadata */}\n        {children}\n      </div>\n\n      {/* Close button */}\n      <button\n        onClick={onClose}\n        className=\"absolute top-0 right-0 p-6 text-white hover:text-white/50 transition-colors cursor-pointer\"\n      >\n        <Icon type=\"X\" scale={3} />\n      </button>\n    </div>\n  );\n\n  // Render the lightbox as a portal to the dedicated portal container\n  const portalRoot = document.getElementById('portal-root');\n  if (!portalRoot) return null;\n\n  return createPortal(lightboxContent, portalRoot);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Logo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 1,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 1,
        "endColumn": 20,
        "fix": { "range": [0, 20], "text": "type LogoProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "interface LogoProps {\n  size?: number;\n  className?: string;\n}\n\nexport const Logo = ({ size = 64, className = '' }: LogoProps) => {\n  return (\n    <svg\n      width={size}\n      height={size}\n      viewBox=\"0 0 64 64\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      className={className}\n    >\n      <path\n        d=\"M36 12H40V16H44V20H48V24H52V28H48V32H44V36H40V40H36V44H32V48H28V52H24V56H20V52H16V48H12V44H8V40H12V36H16V32H20V28H24V24H28V20H32V16H36V12Z\"\n        fill=\"#F2C94C\"\n      />\n      <path\n        d=\"M44 4H52V8H56V12H60V20H56V24H52V20H48V16H44V12H40V8H44V4Z\"\n        fill=\"#EB5757\"\n      />\n      <path d=\"M4 44V56H8V60H20V52H16V48H12V44H4Z\" fill=\"#F2994A\" />\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M44 0H52V4H44V0Z M40 8V4H44V8H40Z M40 12V8H36V12H32V16H28V20H24V24H20V28H16V32H12V36H8V40H4V44H0V64H20V60H24V56H28V52H32V48H36V44H40V40H44V36H48V32H52V28H56V24H60V20H64V12H60V8H56V4H52V8H56V12H60V20H56V24H52V20H48V16H44V12H40ZM40 12V16H44V20H48V24H52V28H48V32H44V36H40V40H36V44H32V48H28V52H24V56H20V60H12V56H8V52H4V44H8V40H12V36H16V32H20V28H24V24H28V20H32V16H36V12H40Z\"\n        fill=\"black\"\n      />\n    </svg>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Modal.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 7,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 7,
        "endColumn": 21,
        "fix": { "range": [205, 226], "text": "type ModalProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, { useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Text } from './PixelFont';\nimport { ModalScrim } from './ModalScrim';\nimport { ModalBody } from './ModalBody';\n\ninterface ModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title?: string;\n  children: React.ReactNode;\n}\n\nexport function Modal({ isOpen, onClose, title, children }: ModalProps) {\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen, onClose]);\n\n  if (!isOpen) return null;\n\n  const modalContent = (\n    <ModalScrim onClick={onClose}>\n      <ModalBody>\n        {/* Header */}\n        {title && (\n          <div className=\"flex justify-start\" aria-label={title}>\n            <Text scale={2}>{title}</Text>\n          </div>\n        )}\n\n        {/* Content */}\n        <div className=\"flex flex-col items-start justify-start text-secondary gap-6\">\n          {children}\n        </div>\n      </ModalBody>\n    </ModalScrim>\n  );\n\n  // Render the modal as a portal to the dedicated portal container\n  const portalRoot = document.getElementById('portal-root');\n  if (!portalRoot) return null;\n\n  return createPortal(modalContent, portalRoot);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ModalBody.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 18,
        "column": 23,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 18,
        "endColumn": 42,
        "fix": { "range": [398, 417], "text": "{ e.stopPropagation(); }" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import type { ReactNode } from 'react';\n\n/**\n * Shared modal body with border decorations\n */\n\nexport function ModalBody({\n  children,\n  className = '',\n}: {\n  children: ReactNode;\n  className?: string;\n}) {\n  const borderClasses = 'absolute bg-black';\n  return (\n    <div\n      className={`bg-white flex flex-col gap-6 p-6 items-center justify-center relative ${className}`}\n      onClick={(e) => e.stopPropagation()}\n    >\n      {children}\n\n      {/* Border Decorations */}\n      <div className={`${borderClasses} -top-1 left-1 right-1 h-1`} />\n      <div className={`${borderClasses} -bottom-1 left-1 right-1 h-1`} />\n      <div className={`${borderClasses} top-1 -left-1 bottom-1 w-1`} />\n      <div className={`${borderClasses} top-1 -right-1 bottom-1 w-1`} />\n      <div className={`${borderClasses} top-0 left-0 w-1 h-1`} />\n      <div className={`${borderClasses} top-0 right-0 w-1 h-1`} />\n      <div className={`${borderClasses} bottom-0 left-0 w-1 h-1`} />\n      <div className={`${borderClasses} bottom-0 right-0 w-1 h-1`} />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ModalScrim.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PaginatedDrawingGrid.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 7,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 7,
        "endColumn": 36,
        "fix": {
          "range": [228, 264],
          "text": "type PaginatedDrawingGridProps = "
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 42,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 42,
        "endColumn": 71,
        "fix": {
          "range": [1455, 1508],
          "text": "{ window.removeEventListener('resize', calculateLayout); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 100,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 100,
        "endColumn": 60,
        "fix": {
          "range": [3309, 3339],
          "text": "{ onDrawingClick(drawing.postId); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 111,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 111,
        "endColumn": 59,
        "fix": {
          "range": [3618, 3649],
          "text": "{ setCurrentPage(currentPage - 1); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 126,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 126,
        "endColumn": 59,
        "fix": {
          "range": [4052, 4083],
          "text": "{ setCurrentPage(currentPage + 1); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 5,
    "source": "import React, { useState, useEffect } from 'react';\nimport { Drawing } from './Drawing';\nimport { IconButton } from './IconButton';\nimport { Text } from './PixelFont';\nimport type { DrawingData } from '@shared/schema/drawing';\n\ninterface PaginatedDrawingGridProps {\n  drawings: Array<{ postId: string; drawing: DrawingData }>;\n  onDrawingClick: (postId: string) => void;\n  isLoading?: boolean;\n}\n\nexport const PaginatedDrawingGrid = React.memo(function PaginatedDrawingGrid({\n  drawings,\n  onDrawingClick,\n  isLoading = false,\n}: PaginatedDrawingGridProps) {\n  const [currentPage, setCurrentPage] = useState(1);\n  const [tilesPerRow, setTilesPerRow] = useState(3);\n  const [tilesPerPage, setTilesPerPage] = useState(12);\n\n  // Calculate responsive layout\n  useEffect(() => {\n    const calculateLayout = () => {\n      const width = window.innerWidth;\n      const padding = 32; // 16px on each side\n      const tileSize = 87;\n      const gap = 12;\n\n      // Calculate maximum tiles per row based on screen width\n      const availableWidth = width - padding;\n      const maxTilesPerRow = Math.floor(availableWidth / (tileSize + gap));\n      setTilesPerRow(Math.max(1, maxTilesPerRow));\n\n      // Calculate tiles per page based on available space\n      // Use 4 rows as before, but allow fewer columns if needed\n      setTilesPerPage(maxTilesPerRow * 4);\n    };\n\n    calculateLayout();\n    window.addEventListener('resize', calculateLayout);\n    return () => window.removeEventListener('resize', calculateLayout);\n  }, [drawings.length]);\n\n  // Reset to page 1 when drawings change\n  useEffect(() => {\n    setCurrentPage(1);\n  }, [drawings.length]);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex w-full h-full flex-row gap-3 flex-wrap items-start justify-center\">\n        {Array.from({ length: 6 }).map((_, i) => (\n          <div\n            key={i}\n            className=\"w-[87px] h-[87px] bg-gray-200 animate-pulse\"\n          />\n        ))}\n      </div>\n    );\n  }\n\n  if (drawings.length === 0) {\n    return null; // Empty state handled by parent\n  }\n\n  const totalPages = Math.ceil(drawings.length / tilesPerPage);\n  const startIndex = (currentPage - 1) * tilesPerPage;\n  const endIndex = Math.min(startIndex + tilesPerPage, drawings.length);\n  const currentDrawings = drawings.slice(startIndex, endIndex);\n\n  const hasNextPage = currentPage < totalPages;\n  const hasPrevPage = currentPage > 1;\n\n  // Calculate actual columns needed for current page\n  const actualColumns = Math.min(tilesPerRow, currentDrawings.length);\n  const actualRows = Math.ceil(currentDrawings.length / tilesPerRow);\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Drawing Tiles */}\n      <div\n        className=\"flex-1 flex flex-col gap-3 justify-center items-center\"\n        style={{\n          minHeight: `${actualRows * (87 + 12) - 12}px`, // Account for gaps\n        }}\n      >\n        <div\n          className=\"grid gap-3 justify-center\"\n          style={{\n            gridTemplateColumns: `repeat(${actualColumns}, 87px)`,\n            gridTemplateRows: `repeat(${actualRows}, 87px)`,\n          }}\n        >\n          {currentDrawings.map((drawing) => (\n            <Drawing\n              key={drawing.postId}\n              data={drawing.drawing}\n              size={87}\n              onClick={() => onDrawingClick(drawing.postId)}\n            />\n          ))}\n        </div>\n      </div>\n\n      {/* Pagination Controls */}\n      <div className=\"shrink-0 w-full flex items-center justify-between mt-4\">\n        {hasPrevPage ? (\n          <IconButton\n            symbol=\"arrow-left\"\n            onClick={() => setCurrentPage(currentPage - 1)}\n            size=\"medium\"\n            variant=\"primary\"\n          />\n        ) : (\n          <div className=\"w-8 h-8\" />\n        )}\n\n        <div className=\"flex items-center justify-center flex-1 text-secondary\">\n          <Text>{`Page ${currentPage} of ${totalPages}`}</Text>\n        </div>\n\n        {hasNextPage ? (\n          <IconButton\n            symbol=\"arrow-right\"\n            onClick={() => setCurrentPage(currentPage + 1)}\n            size=\"medium\"\n            variant=\"primary\"\n          />\n        ) : (\n          <div className=\"w-8 h-8\" />\n        )}\n      </div>\n    </div>\n  );\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/Icon.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 4,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 4,
        "endColumn": 27,
        "fix": { "range": [86, 113], "text": "type PixelSymbolProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { getGlyph } from './glyphs';\nimport type { SupportedGlyph } from './glyphs';\n\ninterface PixelSymbolProps {\n  type: SupportedGlyph;\n  scale?: number;\n  color?: string;\n  className?: string;\n}\n\nexport function Icon({\n  type,\n  scale = 2,\n  color = 'currentColor',\n  className = '',\n}: PixelSymbolProps) {\n  const glyph = getGlyph(type);\n  if (!glyph) return null;\n\n  const height = glyph.height;\n  const width = glyph.width;\n  const scaledHeight = height * scale;\n  const scaledWidth = width * scale;\n\n  return (\n    <svg\n      width={scaledWidth}\n      height={scaledHeight}\n      viewBox={`0 0 ${width} ${height}`}\n      className={className}\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path d={glyph.path} fill={color} fillRule=\"evenodd\" clipRule=\"evenodd\" />\n    </svg>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/Text.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 4,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 4,
        "endColumn": 27,
        "fix": { "range": [116, 136], "text": "type TextProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, { useMemo } from 'react';\nimport { getGlyph, getStringWidth, getFontHeight } from './glyphs';\n\nexport interface TextProps {\n  children: string;\n  scale?: number;\n  color?: string;\n  backgroundColor?: string;\n  gap?: number;\n  shadow?: boolean;\n  shadowColor?: string;\n  shadowOffset?: { x: number; y: number };\n  className?: string;\n  onPress?: () => void;\n}\n\n/**\n * PixelFont component - renders as SVG for pixel-perfect text\n * Based on the old Pixelary approach with better developer ergonomics\n */\nexport function Text({\n  children,\n  scale = 2,\n  color = 'currentColor',\n  backgroundColor = 'transparent',\n  gap = 1,\n  shadow = false,\n  shadowColor = 'var(--color-shadow)',\n  shadowOffset = { x: 2, y: 2 },\n  className = '',\n  onPress,\n}: TextProps) {\n  // Calculate dimensions\n  const dimensions = useMemo(() => {\n    const width = getStringWidth(children, gap);\n    const height = getFontHeight();\n    return {\n      width: width * scale,\n      height: height * scale,\n      baseWidth: width,\n      baseHeight: height,\n    };\n  }, [children, gap, scale]);\n\n  // Generate SVG paths for each character\n  const svgPaths = useMemo(() => {\n    let xOffset = 0;\n    const paths: React.ReactNode[] = [];\n\n    for (const char of children) {\n      if (char === ' ') {\n        xOffset += 6 + gap;\n        continue;\n      }\n\n      const glyph = getGlyph(char);\n      if (!glyph) continue;\n\n      // Add shadow if enabled\n      if (shadow) {\n        paths.push(\n          <path\n            key={`shadow-${char}-${xOffset}`}\n            d={glyph.path}\n            transform={`translate(${xOffset + shadowOffset.x} ${shadowOffset.y})`}\n            fill={shadowColor}\n            fillRule=\"evenodd\"\n            clipRule=\"evenodd\"\n          />\n        );\n      }\n\n      // Add main character\n      paths.push(\n        <path\n          key={`char-${char}-${xOffset}`}\n          d={glyph.path}\n          transform={`translate(${xOffset} 0)`}\n          fill={color}\n          fillRule=\"evenodd\"\n          clipRule=\"evenodd\"\n        />\n      );\n\n      xOffset += glyph.width + gap;\n    }\n\n    return paths;\n  }, [children, color, gap, shadow, shadowColor, shadowOffset]);\n\n  // Render as SVG\n  return (\n    <svg\n      width={dimensions.width}\n      height={dimensions.height}\n      viewBox={`0 0 ${dimensions.baseWidth} ${dimensions.baseHeight}`}\n      className={`select-none image-rendering-pixelated ${className}`.trim()}\n      onClick={onPress}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      aria-label={children}\n    >\n      {backgroundColor !== 'transparent' && (\n        <rect\n          width={dimensions.baseWidth}\n          height={dimensions.baseHeight}\n          fill={backgroundColor}\n        />\n      )}\n      {svgPaths}\n    </svg>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/glyphs.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 6,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 6,
        "endColumn": 28,
        "fix": { "range": [143, 164], "text": "type PixelGlyph = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 357,
        "column": 70,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 357,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9102, 9104], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * Pixel font glyph data structure\n * Based on the original Pixelary glyph system but enhanced for better developer ergonomics\n */\n\nexport interface PixelGlyph {\n  path: string;\n  width: number;\n  height: number;\n}\n\n// Import the glyph data from the old pixelary system\nconst glyphData = {\n  '0': {\n    'path': 'M5 0H1V1H0V5H1V6H5V5H6V1H5V0ZM4 1H2V3H3V4H2V5H4V3H3V2H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  '1': { 'path': 'M4 0H2V1H1V2H2V5H0V6H6V5H4V0Z', 'width': 6, 'height': 7 },\n  '2': {\n    'path': 'M1 0H5V1H6V2H5V3H4V4H3V5H6V6H0V5H1V4H2V3H3V2H4V1H2V2H0V1H1V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '3': {\n    'path': 'M0 0H6V1H5V2H4V3H5V4H6V5H5V6H1V5H0V4H2V5H4V4H3V3H2V2H3V1H0V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '4': {\n    'path': 'M5 0H3V1H2V2H1V3H0V5H3V6H5V5H6V4H5V0ZM2 3V4H3V3H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  '5': {\n    'path': 'M6 0H0V3H4V5H2V4H0V5H1V6H5V5H6V3H5V2H2V1H6V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '6': {\n    'path': 'M1 0H5V1H2V2H5V3H6V5H5V6H1V5H0V1H1V0ZM2 5H4V3H2V5Z',\n    'width': 6,\n    'height': 7,\n  },\n  '7': {\n    'path': 'M0 0H6V2H5V3H4V4H3V6H1V4H2V3H3V2H4V1H0V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '8': {\n    'path':\n      'M5 0H1V1H0V2H1V3H0V5H1V6H5V5H6V3H5V2H6V1H5V0ZM4 5V3H2V5H4ZM4 2H2V1H4V2Z',\n    'width': 6,\n    'height': 7,\n  },\n  '9': {\n    'path': 'M1 0H5V1H6V4H5V5H4V6H1V5H3V4H4V3H1V2H0V1H1V0ZM2 2H4V1H2V2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'A': {\n    'path': 'M2 0H4V1H5V2H6V6H4V5H2V6H0V2H1V1H2V0ZM2 2V4H4V2H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'B': {\n    'path': 'M5 0H0V6H5V5H6V3H5V2H6V1H5V0ZM4 3H2V5H4V3ZM2 2V1H4V2H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'C': {\n    'path': 'M1 0H5V1H6V2H4V1H2V5H4V4H6V5H5V6H1V5H0V1H1V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'D': {\n    'path': 'M4 0H0V6H4V5H5V4H6V2H5V1H4V0ZM4 2H3V1H2V5H3V4H4V2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'E': { 'path': 'M6 0H0V6H6V5H2V3H5V2H2V1H6V0Z', 'width': 6, 'height': 7 },\n  'F': { 'path': 'M0 0H6V1H2V2H5V3H2V6H0V0Z', 'width': 6, 'height': 7 },\n  'G': {\n    'path': 'M1 0H6V1H2V5H4V4H3V3H6V6H1V5H0V1H1V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'H': { 'path': 'M0 0H2V2H4V0H6V6H4V3H2V6H0V0Z', 'width': 6, 'height': 7 },\n  'I': { 'path': 'M0 0H6V1H4V5H6V6H0V5H2V1H0V0Z', 'width': 6, 'height': 7 },\n  'J': { 'path': 'M6 0H4V5H2V4H0V5H1V6H5V5H6V0Z', 'width': 6, 'height': 7 },\n  'K': {\n    'path': 'M2 0H0V6H2V4H3V5H4V6H6V5H5V4H4V2H5V1H6V0H4V1H3V2H2V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'L': { 'path': 'M2 0H0V6H6V5H2V0Z', 'width': 6, 'height': 7 },\n  'M': {\n    'path': 'M0 0H2V1H3V2H4V1H5V0H7V6H5V3H4V4H3V3H2V6H0V0Z',\n    'width': 7,\n    'height': 7,\n  },\n  'N': {\n    'path': 'M0 0H2V1H3V2H4V0H6V6H4V5H3V4H2V6H0V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'O': {\n    'path': 'M5 0H1V1H0V5H1V6H5V5H6V1H5V0ZM4 1H2V5H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'P': {\n    'path': 'M0 0V6H2V4H5V3H6V1H5V0H0ZM2 1V3H4V1H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'Q': {\n    'path': 'M5 0H1V1H0V5H1V6H3V5H4V6H6V5H5V4H6V1H5V0ZM4 1H2V5H3V4H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'R': {\n    'path': 'M0 0V6H2V4H3V5H4V6H6V5H5V3H6V1H5V0H0ZM4 1H2V3H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'S': {\n    'path': 'M1 0H5V1H2V2H5V3H6V5H5V6H1V5H4V3H1V2H0V1H1V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'T': { 'path': 'M6 0H0V1H2V6H4V1H6V0Z', 'width': 6, 'height': 7 },\n  'U': { 'path': 'M0 0H2V5H4V0H6V6H0V0Z', 'width': 6, 'height': 7 },\n  'V': {\n    'path': 'M2 0H0V4H1V5H2V6H4V5H5V4H6V0H4V4H2V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'W': {\n    'path': 'M0 0H2V3H3V2H4V3H5V0H7V6H5V5H4V4H3V5H2V6H0V0Z',\n    'width': 7,\n    'height': 7,\n  },\n  'X': {\n    'path': 'M0 0H2V2H4V0H6V2H5V4H6V6H4V4H2V6H0V4H1V2H0V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'Y': {\n    'path': 'M2 0H0V2H1V3H2V6H4V3H5V2H6V0H4V2H2V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'Z': {\n    'path': 'M6 0H0V1H3V2H2V3H1V4H0V6H6V5H2V4H3V3H4V2H5V1H6V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'a': {\n    'path': 'M1 1H5V2H6V6H1V5H0V4H1V3H4V2H1V1ZM2 4V5H4V4H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'b': {\n    'path': 'M2 0H0V6H5V5H6V3H5V2H2V0ZM4 3H2V5H4V3Z',\n    'width': 6,\n    'height': 7,\n  },\n  'c': { 'path': 'M1 1H5V2H2V5H5V6H1V5H0V2H1V1Z', 'width': 5, 'height': 7 },\n  'd': {\n    'path': 'M6 0H4V2H1V3H0V5H1V6H6V0ZM2 5H4V3H2V5Z',\n    'width': 6,\n    'height': 7,\n  },\n  'e': {\n    'path': 'M1 1H5V2H6V4H2V5H5V6H1V5H0V2H1V1ZM2 3H4V2H2V3Z',\n    'width': 6,\n    'height': 7,\n  },\n  'f': {\n    'path': 'M5 0H2V1H1V2H0V3H1V6H3V3H5V2H3V1H5V0Z',\n    'width': 5,\n    'height': 7,\n  },\n  'g': {\n    'path': 'M1 1H6V6H5V7H0V6H4V5H1V4H0V2H1V1ZM2 4H4V2H2V4Z',\n    'width': 6,\n    'height': 7,\n  },\n  'h': { 'path': 'M0 0H2V2H5V3H6V6H4V3H2V6H0V0Z', 'width': 6, 'height': 7 },\n  'i': {\n    'path': 'M3 2V0H1V1H3V2H0V3H1V5H0V6H4V5H3V2Z',\n    'width': 4,\n    'height': 7,\n  },\n  'j': { 'path': 'M3 2V0H5V1H3V2H5V6H4V7H0V6H3V2Z', 'width': 5, 'height': 7 },\n  'k': {\n    'path': 'M0 0H2V3H3V2H5V3H4V4H5V5H6V6H4V5H3V4H2V6H0V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'l': { 'path': 'M0 0H3V5H4V6H0V5H1V1H0V0Z', 'width': 4, 'height': 7 },\n  'm': {\n    'path': 'M0 1H2V2H4V1H6V2H7V6H5V4H4V5H3V4H2V6H0V1Z',\n    'width': 7,\n    'height': 7,\n  },\n  'n': { 'path': 'M0 1H5V2H6V6H4V2H2V6H0V1Z', 'width': 6, 'height': 7 },\n  'o': {\n    'path': 'M1 1H5V2H6V5H5V6H1V5H0V2H1V1ZM2 5H4V2H2V5Z',\n    'width': 6,\n    'height': 7,\n  },\n  'p': {\n    'path': 'M0 1V7H2V5H5V4H6V2H5V1H0ZM2 2V4H4V2H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'q': {\n    'path': 'M6 1H1V2H0V4H1V5H4V7H6V1ZM2 2V4H4V2H2Z',\n    'width': 6,\n    'height': 7,\n  },\n  'r': { 'path': 'M0 1H5V2H6V3H4V2H2V6H0V1Z', 'width': 6, 'height': 7 },\n  's': {\n    'path': 'M1 1H6V2H2V3H5V4H6V5H5V6H0V5H4V4H1V3H0V2H1V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  't': {\n    'path': 'M4 0H2V1H0V2H2V5H3V6H6V5H4V2H6V1H4V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  'u': { 'path': 'M0 1H2V5H4V1H6V6H1V5H0V1Z', 'width': 6, 'height': 7 },\n  'v': {\n    'path': 'M2 1H0V4H1V5H2V6H4V5H5V4H6V1H4V4H2V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'w': {\n    'path': 'M0 1H2V3H3V2H4V3H5V1H7V4H6V6H4V5H3V6H1V4H0V1Z',\n    'width': 7,\n    'height': 7,\n  },\n  'x': {\n    'path': 'M0 1H2V2H4V1H6V2H5V3H4V4H5V5H6V6H4V5H2V6H0V5H1V4H2V3H1V2H0V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'y': {\n    'path': 'M0 1H2V4H4V1H6V5H5V6H4V7H0V6H3V5H1V4H0V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'z': {\n    'path': 'M0 1H6V2H5V3H4V4H3V5H6V6H0V5H1V4H2V3H3V2H0V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  '_': { 'path': 'M0 5V6H6V5H0Z', 'width': 6, 'height': 7 },\n  '-': { 'path': 'M0 3V4H6V3H0Z', 'width': 6, 'height': 7 },\n  '.': { 'path': 'M0 4V6H2V4H0Z', 'width': 2, 'height': 7 },\n  ',': { 'path': 'M3 4H1V6H0V7H2V6H3V4Z', 'width': 3, 'height': 7 },\n  '(': {\n    'path': 'M5 0H2V1H1V2H0V4H1V5H2V6H5V5H4V4H2V2H4V1H5V0Z',\n    'width': 5,\n    'height': 7,\n  },\n  ')': {\n    'path': 'M3 0H0V1H1V2H3V4H1V5H0V6H3V5H4V4H5V2H4V1H3V0Z',\n    'width': 5,\n    'height': 7,\n  },\n  '!': { 'path': 'M2 0H0V4V6H2V5H0V4H2V0Z', 'width': 2, 'height': 7 },\n  '+': { 'path': 'M2 1H4V3H6V4H4V6H2V4H0V3H2V1Z', 'width': 6, 'height': 7 },\n  '*': {\n    'path': 'M1 1H3V2H5V1H7V2H6V3H8V4H6V5H7V6H5V5H3V6H1V5H2V4H0V3H2V2H1V1Z',\n    'width': 8,\n    'height': 7,\n  },\n  '?': {\n    'path': 'M5 0H1V1H0V2H2V1H4V2H3V3H2V4V6H4V5H2V4H4V3H5V2H6V1H5V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '$': {\n    'path': 'M2 0H4V1H6V2H2V3H5V4H6V5H5V6H4V7H2V6H0V5H4V4H1V3H0V2H1V1H2V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  ':': { 'path': 'M0 2H2V4H0V5H2V7H0V2Z', 'width': 2, 'height': 7 },\n  '/': {\n    'path': 'M4 0H6V1H5V2H4V3H3V4H2V5H1V6H0V4H1V3H2V2H3V1H4V0Z',\n    'width': 6,\n    'height': 7,\n  },\n  '%': {\n    'path': 'M0 0H2V2H3V1H4V0H5V2H4V3H3V4H5V6H3V4H2V5H1V6H0V4H1V3H2V2H0V0Z',\n    'width': 5,\n    'height': 7,\n  },\n  \"'\": { 'path': 'M3 0H1V2H0V3H2V2H3V0Z', 'width': 3, 'height': 7 },\n  'arrow-left': {\n    'path': 'M4 1H2V2H1V3H0V4H1V5H2V6H4V5H3V4H6V3H3V2H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'arrow-right': {\n    'path': 'M4 1H2V2H3V3H0V4H3V5H2V6H4V5H5V4H6V3H5V2H4V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'checkmark': {\n    'path': 'M6 0H7V2H6V3H5V4H4V5H3V6H2V5H1V4H0V3H2V4H3V3H4V2H5V1H6V0Z',\n    'width': 7,\n    'height': 7,\n  },\n  'clock': {\n    'path': 'M5 0H1V1H0V5H1V6H5V5H6V1H5V0ZM3 1H2V4H4V3H3V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'star': {\n    'path': 'M3 0H4V1H5V2H7V3H6V4H5V5H6V6H4V5H3V6H1V5H2V4H1V3H0V2H2V1H3V0Z',\n    'width': 7,\n    'height': 7,\n  },\n  'leaderboard': {\n    'path': 'M6 1H8V6H0V5H2V6H3V3H5V6H6V1Z',\n    'width': 8,\n    'height': 7,\n  },\n  'undo': {\n    'path': 'M4 6H1V5H4V2H2V3H3V4H0V1H1V2H2V1H4V2H5V5H4V6Z',\n    'width': 5,\n    'height': 7,\n  },\n  'plus': {\n    'path': 'M2 1H4V3H6V4H4V6H2V4H0V3H2V1Z',\n    'width': 6,\n    'height': 7,\n  },\n  'menu': {\n    'path': 'M6 6H0V5H6V6ZM6 4H0V3H6V4ZM6 2H0V1H6V2Z',\n    'width': 6,\n    'height': 7,\n  },\n} as const;\n\nexport type SupportedGlyph = keyof typeof glyphData;\n\n/**\n * Get a glyph by character\n */\nexport function getGlyph(char: string): PixelGlyph | null {\n  return (glyphData as Record<string, PixelGlyph | undefined>)[char] || null;\n}\n\n/**\n * Get the width of a string in pixels\n */\nexport function getStringWidth(text: string, gap: number = 1): number {\n  let width = 0;\n  let isFirst = true;\n\n  for (const char of text) {\n    if (char === ' ') {\n      width += 6 + gap; // Space width\n      continue;\n    }\n\n    const glyph = getGlyph(char);\n    if (glyph) {\n      if (!isFirst) width += gap;\n      width += glyph.width;\n      isFirst = false;\n    }\n  }\n\n  return width;\n}\n\n/**\n * Get the height of the font\n */\nexport function getFontHeight(): number {\n  return 7; // Base height for pixel font\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/wrapText.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelFont/wrapText.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/PixelInput.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 14,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 14,
        "endColumn": 26,
        "fix": { "range": [271, 297], "text": "type PixelInputProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 25,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 25,
        "endColumn": 24,
        "fix": { "range": [575, 599], "text": "type PixelInputRef = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 137,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 137,
        "endColumn": 43,
        "fix": { "range": [3470, 3493], "text": "{ clearInterval(interval); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 203,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 203,
        "endColumn": 43,
        "fix": { "range": [5675, 5698], "text": "{ clearTimeout(timeoutId); }" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 281,
        "column": 23,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 281,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [8710, 8712], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import React, {\n  useRef,\n  useEffect,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n} from 'react';\nimport { Text, Icon } from './PixelFont';\n\n// Animation constants\nconst TYPE_SPEED = 150; // ms per character\nconst HOLD_DURATION = 1000; // ms to hold complete text\n\ninterface PixelInputProps {\n  value: string;\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  placeholderPhrases: string[];\n  autoFocus?: boolean;\n  className?: string;\n  disabled?: boolean;\n  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  showClearButton?: boolean;\n}\n\ninterface PixelInputRef {\n  focus: () => void;\n  blur: () => void;\n}\n\nexport const PixelInput = forwardRef<PixelInputRef, PixelInputProps>(\n  (\n    {\n      value,\n      onChange,\n      placeholderPhrases,\n      autoFocus = false,\n      className = '',\n      disabled = false,\n      onKeyDown,\n      showClearButton = false,\n    },\n    ref\n  ) => {\n    const inputRef = useRef<HTMLInputElement>(null);\n    const scrollContainerRef = useRef<HTMLDivElement>(null);\n    const [isFocused, setIsFocused] = useState(false);\n    const [showCursor, setShowCursor] = useState(true);\n\n    // Animation state - simple and clean\n    const [currentPhraseIndex, setCurrentPhraseIndex] = useState(0);\n    const [visibleChars, setVisibleChars] = useState(0);\n    const [isTyping, setIsTyping] = useState(true);\n\n    // Expose focus/blur methods\n    useImperativeHandle(ref, () => ({\n      focus: () => {\n        inputRef.current?.focus();\n      },\n      blur: () => {\n        inputRef.current?.blur();\n      },\n    }));\n\n    // Handle focus/blur\n    const handleFocus = () => {\n      setIsFocused(true);\n      setShowCursor(true);\n    };\n\n    const handleBlur = () => {\n      setIsFocused(false);\n      setShowCursor(false);\n    };\n\n    // Handle key events to prevent cursor movement and selection\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n      // Prevent arrow keys, home, end, etc.\n      if (\n        [\n          'ArrowLeft',\n          'ArrowRight',\n          'ArrowUp',\n          'ArrowDown',\n          'Home',\n          'End',\n        ].includes(e.key)\n      ) {\n        e.preventDefault();\n        return;\n      }\n\n      // Prevent Ctrl+A or Cmd+A (select all)\n      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {\n        e.preventDefault();\n        return;\n      }\n\n      // Prevent Ctrl+C, Ctrl+V, Ctrl+X (copy, paste, cut)\n      if (e.ctrlKey && ['c', 'v', 'x'].includes(e.key)) {\n        e.preventDefault();\n        return;\n      }\n\n      // Call the original onKeyDown if provided\n      onKeyDown?.(e);\n    };\n\n    // Handle container click to focus input\n    const handleContainerClick = (e: React.MouseEvent) => {\n      if (!disabled && e.target === e.currentTarget) {\n        inputRef.current?.focus();\n      }\n    };\n\n    // Handle clear button click\n    const handleClear = (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (inputRef.current) {\n        // Create a synthetic change event to clear the input\n        const syntheticEvent = {\n          target: { value: '' },\n          currentTarget: { value: '' },\n        } as React.ChangeEvent<HTMLInputElement>;\n        onChange(syntheticEvent);\n        inputRef.current.focus();\n      }\n    };\n\n    // Cursor blink animation\n    useEffect(() => {\n      if (!isFocused) return;\n\n      const interval = setInterval(() => {\n        setShowCursor((prev) => !prev);\n      }, 530);\n\n      return () => clearInterval(interval);\n    }, [isFocused]);\n\n    // Auto-scroll to keep the end of text visible\n    useEffect(() => {\n      if (!scrollContainerRef.current || !value) return;\n\n      const containerWidth = scrollContainerRef.current.clientWidth;\n      const padding = 16; // px-4 = 16px\n\n      // Calculate text width using simple estimation\n      const estimatedWidth = value.length * 8; // Rough estimate: 8px per character\n      const textWidth = estimatedWidth;\n\n      // Scroll to show the end of the text\n      if (textWidth + padding > containerWidth) {\n        const targetPosition = textWidth - containerWidth + padding + 8; // 8px for cursor space\n        scrollContainerRef.current.scrollTo({\n          left: Math.max(0, targetPosition),\n          behavior: 'smooth',\n        });\n      } else {\n        scrollContainerRef.current.scrollTo({\n          left: 0,\n          behavior: 'smooth',\n        });\n      }\n    }, [value]);\n\n    // Character-by-character typing animation\n    useEffect(() => {\n      // Early exit if user has typed or no phrases to animate\n      if (value || placeholderPhrases.length === 0) return;\n\n      const currentPhrase = placeholderPhrases[currentPhraseIndex];\n      if (!currentPhrase) return;\n\n      let timeoutId: ReturnType<typeof setTimeout>;\n\n      if (isTyping) {\n        // Typing phase - add characters one by one\n        if (visibleChars < currentPhrase.length) {\n          timeoutId = setTimeout(() => {\n            setVisibleChars((prev) => prev + 1);\n          }, TYPE_SPEED);\n        } else {\n          // Finished typing, hold for a moment\n          timeoutId = setTimeout(() => {\n            setIsTyping(false);\n          }, HOLD_DURATION);\n        }\n      } else {\n        // Erasing phase - remove characters one by one\n        if (visibleChars > 0) {\n          timeoutId = setTimeout(() => {\n            setVisibleChars((prev) => prev - 1);\n          }, TYPE_SPEED / 4); // Erase much faster than typing\n        } else {\n          // Finished erasing, move to next phrase\n          setCurrentPhraseIndex(\n            (prev) => (prev + 1) % placeholderPhrases.length\n          );\n          setIsTyping(true);\n        }\n      }\n\n      return () => clearTimeout(timeoutId);\n    }, [value, placeholderPhrases, currentPhraseIndex, visibleChars, isTyping]);\n\n    return (\n      <div\n        className={`\n         relative w-full bg-white border-4 border-black cursor-text\n         shadow-pixel\n         ${disabled ? 'opacity-50 cursor-not-allowed' : ''}\n         ${className}\n       `.trim()}\n        onClick={handleContainerClick}\n        style={{\n          // Mobile-specific styles\n          WebkitUserSelect: 'none', // Prevent container text selection\n          userSelect: 'none',\n          touchAction: 'manipulation', // Optimize touch interactions\n        }}\n        onMouseDown={(e) => {\n          // Ensure input gets focus on any click within container\n          if (!disabled && e.target !== inputRef.current) {\n            e.preventDefault();\n            inputRef.current?.focus();\n          }\n        }}\n      >\n        {/* Content area with proper layout */}\n        <div className=\"flex items-center h-[40px] pl-4 pr-1 relative\">\n          {/* Text content area with input overlay */}\n          <div\n            ref={scrollContainerRef}\n            className=\"flex items-center gap-1 flex-1 overflow-hidden relative\"\n          >\n            {/* Interactive input for keyboard handling - only covers text area */}\n            <input\n              ref={inputRef}\n              type=\"text\"\n              value={value}\n              onChange={onChange}\n              onKeyDown={handleKeyDown}\n              onFocus={handleFocus}\n              onBlur={handleBlur}\n              autoFocus={autoFocus}\n              disabled={disabled}\n              autoComplete=\"off\"\n              autoCorrect=\"off\"\n              autoCapitalize=\"off\"\n              spellCheck=\"false\"\n              inputMode=\"text\"\n              className=\"absolute inset-0 cursor-text\"\n              style={{\n                fontSize: '16px', // Prevent zoom on iOS\n                userSelect: 'none', // Disable text selection\n                WebkitUserSelect: 'none', // Safari\n                WebkitTouchCallout: 'none', // Disable iOS selection handles\n                color: 'transparent', // Hide text\n                background: 'transparent', // Transparent background\n                border: 'none', // Remove border\n                outline: 'none', // Remove focus outline\n                caretColor: 'transparent', // Hide cursor\n              }}\n            />\n            {value ? (\n              <>\n                <Text scale={2}>{value}</Text>\n                {/* Blinking cursor - always at the end */}\n                {isFocused && showCursor && (\n                  <div className=\"w-1 h-6 bg-orangered animate-pulse\" />\n                )}\n              </>\n            ) : (\n              <>\n                {/* Character-by-character animated placeholder */}\n                <div className=\"text-weak\">\n                  <Text scale={2}>\n                    {placeholderPhrases[currentPhraseIndex]?.slice(\n                      0,\n                      visibleChars\n                    ) || ''}\n                  </Text>\n                </div>\n              </>\n            )}\n          </div>\n\n          {/* Cursor for placeholder - positioned outside the clipped container */}\n          {!value && isFocused && showCursor && (\n            <div className=\"w-1 h-6 bg-orangered animate-pulse absolute left-4 top-1/2 transform -translate-y-1/2\" />\n          )}\n\n          {/* Clear button - only show when there's text and showClearButton is true */}\n          {value && showClearButton && (\n            <button\n              onClick={handleClear}\n              className=\"w-8 h-8 bg-black border-2 border-black flex items-center justify-center hover:bg-gray-800 transition-colors\"\n              type=\"button\"\n            >\n              <Icon type=\"X\" className=\"text-white\" scale={2} />\n            </button>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nPixelInput.displayName = 'PixelInput';\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ProgressBar.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 4,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 4,
        "endColumn": 27,
        "fix": { "range": [97, 124], "text": "type ProgressBarProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useEffect, useState } from 'react';\nimport { clamp } from '@src/shared/utils/numbers';\n\ninterface ProgressBarProps {\n  percentage: number;\n  width?: number;\n  height?: number;\n  className?: string;\n}\n\nexport function ProgressBar({\n  percentage,\n  width = 256,\n  height = 8,\n  className = '',\n}: ProgressBarProps) {\n  const [displayPercentage, setDisplayPercentage] = useState(0);\n\n  useEffect(() => {\n    const clampedPercentage = clamp(percentage, 0, 100);\n    setDisplayPercentage(clampedPercentage);\n  }, [percentage]);\n\n  return (\n    <div\n      className={`relative ${className}`}\n      style={{ width: `${width}px`, height: `${height}px` }}\n    >\n      {/* Background */}\n      <div\n        className=\"absolute inset-0 bg-black-20\"\n        style={{\n          height: `${height}px`,\n        }}\n      />\n\n      {/* Progress fill */}\n      <div\n        className=\"absolute left-0 top-0 bottom-0 transition-all duration-600 ease-in bg-orangered\"\n        style={{\n          width: `${displayPercentage}%`,\n        }}\n      />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Providers.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Shimmer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Toast.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/Toast.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 21,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 21,
        "endColumn": 29,
        "fix": { "range": [420, 442], "text": "type ToastConfig = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 37,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 37,
        "endColumn": 21,
        "fix": {
          "range": [710, 924],
          "text": "type ToastProps = {\n  onClose: (id: string) => void;\n  index: number;\n  totalToasts: number;\n  previousToastHeights?: number[];\n  onHeightChange?: (height: number) => void;\n} & Omit<ToastConfig, 'onClose'>"
        }
      },
      {
        "ruleId": "@typescript-eslint/non-nullable-type-assertion-style",
        "severity": 1,
        "message": "Use a ! assertion to more succinctly remove null and undefined from the type.",
        "line": 142,
        "column": 15,
        "nodeType": "TSAsExpression",
        "messageId": "preferNonNullAssertion",
        "endLine": 142,
        "endColumn": 41,
        "fix": { "range": [3986, 4012], "text": "basePosition.top!" }
      },
      {
        "ruleId": "@typescript-eslint/non-nullable-type-assertion-style",
        "severity": 1,
        "message": "Use a ! assertion to more succinctly remove null and undefined from the type.",
        "line": 147,
        "column": 18,
        "nodeType": "TSAsExpression",
        "messageId": "preferNonNullAssertion",
        "endLine": 147,
        "endColumn": 47,
        "fix": { "range": [4146, 4175], "text": "basePosition.bottom!" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 219,
        "column": 18,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 219,
        "endColumn": 41,
        "fix": { "range": [5890, 5913], "text": "{ clearTimeout(showTimer); }" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 5,
    "source": "import React, {\n  useEffect,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n} from 'react';\nimport type { ReactNode } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Text } from './PixelFont';\n\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\nexport type ToastPosition =\n  | 'top-right'\n  | 'top-left'\n  | 'bottom-right'\n  | 'bottom-left'\n  | 'top-center'\n  | 'bottom-center';\n\nexport interface ToastConfig {\n  id: string;\n  message: string;\n  type?: ToastType;\n  duration?: number;\n  position?: ToastPosition;\n  persistent?: boolean;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  attachment?: ReactNode;\n  onClose?: () => void;\n  onAction?: () => void;\n}\n\ninterface ToastProps extends Omit<ToastConfig, 'onClose'> {\n  onClose: (id: string) => void;\n  index: number;\n  totalToasts: number;\n  previousToastHeights?: number[];\n  onHeightChange?: (height: number) => void;\n}\n\n// Production-grade ID generation using crypto API\n// const generateToastId = (): string => {\n//   if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n//     return crypto.randomUUID();\n//   }\n//   // Fallback for older browsers\n//   return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n// };\n\n// Toast configuration constants\nconst TOAST_CONFIG = {\n  DEFAULT_DURATION: 4000,\n  ANIMATION_DURATION: 300,\n  MAX_TOASTS: 5,\n  STACK_OFFSET: 80, // Increased for proper spacing (80px = 5rem)\n  Z_INDEX_BASE: 1000,\n} as const;\n\n// Accessibility configuration\nconst ARIA_CONFIG = {\n  ROLE: 'alert',\n  LIVE_REGION: 'polite',\n} as const;\n\nexport function Toast({\n  id,\n  message,\n  type = 'info',\n  duration = TOAST_CONFIG.DEFAULT_DURATION,\n  position = 'top-right',\n  persistent = false,\n  action,\n  attachment,\n  onClose,\n  index,\n  totalToasts: _totalToasts,\n  previousToastHeights = [],\n  onHeightChange,\n}: ToastProps) {\n  const [isVisible, setIsVisible] = useState(false);\n  const [isExiting, setIsExiting] = useState(false);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const exitTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const toastRef = useRef<HTMLDivElement>(null);\n\n  // Memoized styles for performance\n  const toastStyles = useMemo(() => {\n    const baseStyles = `\n      absolute max-w-sm cursor-pointer\n      bg-white border-4 p-4 border-black shadow-pixel\n      transition-all duration-${TOAST_CONFIG.ANIMATION_DURATION} ease-out\n      focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\n    `;\n\n    const positionStyles = {\n      'top-right': `top-4 right-4`,\n      'top-left': `top-4 left-4`,\n      'bottom-right': `bottom-4 right-4`,\n      'bottom-left': `bottom-4 left-4`,\n      'top-center': `top-4 left-1/2`,\n      'bottom-center': `bottom-4 left-1/2`,\n    };\n\n    // Calculate proper stacking offset using CSS transforms\n    // const stackOffset = index > 0 ? TOAST_CONFIG.STACK_OFFSET * index : 0;\n    const visibilityStyles =\n      isVisible && !isExiting\n        ? 'opacity-100 translate-x-0'\n        : 'opacity-0 translate-x-full';\n\n    return `${baseStyles} ${positionStyles[position]} ${visibilityStyles}`;\n  }, [position, isVisible, isExiting]);\n\n  // Calculate dynamic positioning for stacking\n  const dynamicPosition = useMemo(() => {\n    const basePosition = {\n      'top-right': { top: 16, right: 16 },\n      'top-left': { top: 16, left: 16 },\n      'bottom-right': { bottom: 16, right: 16 },\n      'bottom-left': { bottom: 16, left: 16 },\n      'top-center': { top: 16, left: '50%', transform: 'translateX(-50%)' },\n      'bottom-center': {\n        bottom: 16,\n        left: '50%',\n        transform: 'translateX(-50%)',\n      },\n    }[position];\n\n    // Calculate cumulative height offset from previous toasts\n    const cumulativeHeight = previousToastHeights.reduce(\n      (sum, height) => sum + height + 8,\n      0\n    ); // 8px gap between toasts\n\n    if (position.includes('top')) {\n      return {\n        ...basePosition,\n        top: (basePosition.top as number) + cumulativeHeight,\n      };\n    } else if (position.includes('bottom')) {\n      return {\n        ...basePosition,\n        bottom: (basePosition.bottom as number) + cumulativeHeight,\n      };\n    }\n\n    return basePosition;\n  }, [position, previousToastHeights]);\n\n  const typeStyles = useMemo(() => {\n    // Use neutral style for all toast types\n    return 'bg-white border-black text-black';\n  }, []);\n\n  // Cleanup function\n  const cleanup = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    if (exitTimeoutRef.current) {\n      clearTimeout(exitTimeoutRef.current);\n      exitTimeoutRef.current = null;\n    }\n  }, []);\n\n  // Handle toast dismissal\n  const handleDismiss = useCallback(() => {\n    if (isExiting) return;\n\n    setIsExiting(true);\n    exitTimeoutRef.current = setTimeout(() => {\n      onClose(id);\n    }, TOAST_CONFIG.ANIMATION_DURATION);\n  }, [id, onClose, isExiting]);\n\n  // Handle action click\n  const handleAction = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      action?.onClick();\n    },\n    [action]\n  );\n\n  // Handle keyboard events\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        handleDismiss();\n      } else if (e.key === 'Enter' && action) {\n        handleAction(e as unknown as React.MouseEvent);\n      }\n    },\n    [handleDismiss, handleAction, action]\n  );\n\n  // Auto-dismiss timer\n  useEffect(() => {\n    if (persistent) return;\n\n    timeoutRef.current = setTimeout(() => {\n      handleDismiss();\n    }, duration);\n\n    return cleanup;\n  }, [duration, persistent, handleDismiss, cleanup]);\n\n  // Show toast on mount\n  useEffect(() => {\n    const showTimer = setTimeout(() => {\n      setIsVisible(true);\n    }, 10); // Small delay for smooth animation\n\n    return () => clearTimeout(showTimer);\n  }, []);\n\n  // Measure and report height when toast becomes visible\n  useEffect(() => {\n    if (isVisible && toastRef.current && onHeightChange) {\n      const height = toastRef.current.offsetHeight;\n      onHeightChange(height);\n    }\n  }, [isVisible, onHeightChange]);\n\n  const toastContent = (\n    <div\n      ref={toastRef}\n      className={`${toastStyles} ${typeStyles}`}\n      style={{\n        zIndex: TOAST_CONFIG.Z_INDEX_BASE + index,\n        ...dynamicPosition,\n      }}\n      onClick={handleDismiss}\n      onKeyDown={handleKeyDown}\n      tabIndex={0}\n      role={ARIA_CONFIG.ROLE}\n      aria-live={ARIA_CONFIG.LIVE_REGION}\n      aria-label={`${type} notification: ${message}`}\n    >\n      <div className=\"flex flex-col gap-2 justify-center items-center\">\n        <div className=\"flex items-center gap-2\">\n          <Text scale={2} className=\"flex-1\">\n            {message}\n          </Text>\n          {action && (\n            <button\n              onClick={handleAction}\n              className=\"ml-2 px-2 py-1 bg-black text-white text-xs hover:bg-gray-800 transition-colors\"\n              aria-label={`${action.label} action`}\n            >\n              {action.label}\n            </button>\n          )}\n        </div>\n        {attachment}\n      </div>\n    </div>\n  );\n\n  const portalRoot = document.getElementById('portal-root');\n  if (!portalRoot) {\n    return null;\n  }\n\n  return createPortal(toastContent, portalRoot);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/ToastManager.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 13,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 13,
        "endColumn": 27,
        "fix": {
          "range": [244, 353],
          "text": "type ToastData = {\n  id: string;\n  timestamp: number;\n  height?: number;\n} & Omit<ToastConfig, 'id'>"
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 19,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 19,
        "endColumn": 27,
        "fix": { "range": [355, 382], "text": "type ToastContextType = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 30,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 30,
        "endColumn": 21,
        "fix": { "range": [714, 735], "text": "type ToastQueue = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 135,
        "column": 39,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 135,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3613, 3615], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
        "line": 136,
        "column": 7,
        "nodeType": "IfStatement",
        "messageId": "preferNullishOverAssignment",
        "endLine": 138,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "=" },
            "fix": {
              "range": [3639, 3702],
              "text": "groups[position] ??= [];"
            },
            "desc": "Fix to nullish coalescing operator (`??=`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 159,
        "column": 50,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 159,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [4442, 4444], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 170,
        "column": 43,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 170,
        "endColumn": 78,
        "fix": {
          "range": [4849, 4884],
          "text": "{ updateToastHeight(toast.id, height); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import {\n  createContext,\n  useContext,\n  useCallback,\n  useState,\n  useRef,\n  useMemo,\n} from 'react';\nimport type { ReactNode } from 'react';\nimport { Toast } from './Toast';\nimport type { ToastConfig, ToastPosition } from './Toast';\n\nexport interface ToastData extends Omit<ToastConfig, 'id'> {\n  id: string;\n  timestamp: number;\n  height?: number;\n}\n\ninterface ToastContextType {\n  showToast: (toast: Omit<ToastData, 'id' | 'timestamp'>) => string;\n  hideToast: (id: string) => void;\n  hideAllToasts: () => void;\n  getToastCount: () => number;\n  updateToastHeight: (id: string, height: number) => void;\n}\n\nconst ToastContext = createContext<ToastContextType | undefined>(undefined);\n\n// Toast queue management\ninterface ToastQueue {\n  toasts: ToastData[];\n  maxToasts: number;\n}\n\n// Production-grade toast manager with enterprise features\nexport function ToastProvider({\n  children,\n  maxToasts = 5,\n  defaultPosition = 'top-right',\n  defaultDuration = 4000,\n}: {\n  children: ReactNode;\n  maxToasts?: number;\n  defaultPosition?: ToastPosition;\n  defaultDuration?: number;\n}) {\n  const [toastQueue, setToastQueue] = useState<ToastQueue>({\n    toasts: [],\n    maxToasts,\n  });\n\n  const toastIdCounter = useRef(0);\n\n  // Generate unique, predictable IDs for better debugging\n  const generateId = useCallback(() => {\n    toastIdCounter.current += 1;\n    return `toast-${Date.now()}-${toastIdCounter.current}`;\n  }, []);\n\n  // Show toast with queue management\n  const showToast = useCallback(\n    (toast: Omit<ToastData, 'id' | 'timestamp'>) => {\n      const id = generateId();\n      const newToast: ToastData = {\n        ...toast,\n        id,\n        timestamp: Date.now(),\n        duration: toast.duration ?? defaultDuration,\n        position: toast.position ?? defaultPosition,\n      };\n\n      setToastQueue((prev) => {\n        const updatedToasts = [...prev.toasts, newToast];\n\n        // Enforce max toast limit by removing oldest toasts\n        if (updatedToasts.length > prev.maxToasts) {\n          const sortedToasts = updatedToasts\n            .sort((a, b) => a.timestamp - b.timestamp)\n            .slice(-prev.maxToasts);\n          return { ...prev, toasts: sortedToasts };\n        }\n\n        return { ...prev, toasts: updatedToasts };\n      });\n\n      return id;\n    },\n    [generateId, defaultDuration, defaultPosition]\n  );\n\n  // Hide specific toast\n  const hideToast = useCallback((id: string) => {\n    setToastQueue((prev) => ({\n      ...prev,\n      toasts: prev.toasts.filter((toast) => toast.id !== id),\n    }));\n  }, []);\n\n  // Hide all toasts\n  const hideAllToasts = useCallback(() => {\n    setToastQueue((prev) => ({ ...prev, toasts: [] }));\n  }, []);\n\n  // Get current toast count\n  const getToastCount = useCallback(() => {\n    return toastQueue.toasts.length;\n  }, [toastQueue.toasts.length]);\n\n  // Update toast height\n  const updateToastHeight = useCallback((id: string, height: number) => {\n    setToastQueue((prev) => ({\n      ...prev,\n      toasts: prev.toasts.map((toast) =>\n        toast.id === id ? { ...toast, height } : toast\n      ),\n    }));\n  }, []);\n\n  // Memoized context value to prevent unnecessary re-renders\n  const contextValue = useMemo(\n    () => ({\n      showToast,\n      hideToast,\n      hideAllToasts,\n      getToastCount,\n      updateToastHeight,\n    }),\n    [showToast, hideToast, hideAllToasts, getToastCount, updateToastHeight]\n  );\n\n  // Group toasts by position for better rendering\n  const toastsByPosition = useMemo(() => {\n    const groups: Record<string, ToastData[]> = {};\n    toastQueue.toasts.forEach((toast) => {\n      const position = toast.position || defaultPosition;\n      if (!groups[position]) {\n        groups[position] = [];\n      }\n      groups[position].push(toast);\n    });\n\n    // Sort toasts within each position by timestamp (newest first for proper stacking)\n    Object.keys(groups).forEach((position) => {\n      groups[position]?.sort((a, b) => b.timestamp - a.timestamp);\n    });\n\n    return groups;\n  }, [toastQueue.toasts, defaultPosition]);\n\n  return (\n    <ToastContext.Provider value={contextValue}>\n      {children}\n      {/* Render toasts grouped by position */}\n      {Object.entries(toastsByPosition).map(([, toasts]) =>\n        toasts.map((toast, index) => {\n          // Calculate heights of previous toasts for proper stacking\n          const previousToastHeights = toasts\n            .slice(0, index)\n            .map((prevToast) => prevToast.height || 80) // Default height if not measured yet\n            .reverse(); // Reverse to get correct stacking order\n\n          return (\n            <Toast\n              key={toast.id}\n              {...toast}\n              onClose={hideToast}\n              index={index}\n              totalToasts={toasts.length}\n              previousToastHeights={previousToastHeights}\n              onHeightChange={(height) => updateToastHeight(toast.id, height)}\n            />\n          );\n        })\n      )}\n    </ToastContext.Provider>\n  );\n}\n\n// Enhanced hook with additional utilities\nexport function useToast() {\n  const context = useContext(ToastContext);\n  if (context === undefined) {\n    throw new Error('useToast must be used within a ToastProvider');\n  }\n  return context;\n}\n\n// Convenience hooks for common toast types\nexport function useToastHelpers() {\n  const { showToast } = useToast();\n\n  return {\n    success: useCallback(\n      (message: string, options?: Partial<ToastData>) => {\n        return showToast({ message, type: 'success', ...options });\n      },\n      [showToast]\n    ),\n\n    error: useCallback(\n      (message: string, options?: Partial<ToastData>) => {\n        return showToast({\n          message,\n          type: 'error',\n          duration: 6000,\n          ...options,\n        });\n      },\n      [showToast]\n    ),\n\n    warning: useCallback(\n      (message: string, options?: Partial<ToastData>) => {\n        return showToast({\n          message,\n          type: 'warning',\n          duration: 5000,\n          ...options,\n        });\n      },\n      [showToast]\n    ),\n\n    info: useCallback(\n      (message: string, options?: Partial<ToastData>) => {\n        return showToast({ message, type: 'info', ...options });\n      },\n      [showToast]\n    ),\n\n    // Persistent toast that requires user action\n    persistent: useCallback(\n      (\n        message: string,\n        action: ToastData['action'],\n        options?: Partial<ToastData>\n      ) => {\n        return showToast({\n          message,\n          type: 'warning',\n          persistent: true,\n          ...(action && { action }),\n          ...options,\n        });\n      },\n      [showToast]\n    ),\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Clock.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/ColorPalette.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Draw.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Drawings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Multiplier.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Multiplier.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 21,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "neverNullish",
        "endLine": 21,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { IllustrationProps } from './types';\n\ntype MultiplierVariant = 'double' | 'triple';\n\nexport function Multiplier({\n  variant = 'double',\n  size = 12,\n  title = '',\n  className = '',\n  ...props\n}: IllustrationProps & { variant?: MultiplierVariant }) {\n  return (\n    <svg\n      width={size}\n      height={size}\n      viewBox=\"0 0 12 12\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={className}\n      aria-label={\n        title ?? (variant === 'double' ? '2x multiplier' : '3x multiplier')\n      }\n      role=\"img\"\n      {...props}\n    >\n      {variant === 'double' ? (\n        <>\n          <path\n            fillRule=\"evenodd\"\n            clipRule=\"evenodd\"\n            d=\"M11 2H12V6H11V7H10V8H12V11H6V10H4V9H3V10H0V7H1V6H0V3H3V4H4V3H6V2H7V1H11V2ZM8 3H7V4H8V3H10V5H9V6H8V7H7V10H11V9H8V7H9V6H10V5H11V3H10V2H8V3ZM5 5H4V6H3V5H2V6H3V7H2V8H1V9H2V8H3V7H4V8H5V7H4V6H5V5H6V4H5V5ZM5 9H6V8H5V9ZM1 4V5H2V4H1Z\"\n            fill=\"black\"\n            fillOpacity=\"0.8\"\n          />\n          <path\n            d=\"M8 9H11V10H7V7H8V9ZM9 7H8V6H9V7ZM10 6H9V5H10V6ZM11 5H10V3H11V5ZM8 4H7V3H8V4ZM10 3H8V2H10V3Z\"\n            fill=\"#F2C94C\"\n          />\n          <path\n            d=\"M2 9H1V8H2V9ZM6 9H5V8H6V9ZM3 8H2V7H3V8ZM5 8H4V7H5V8ZM4 7H3V6H4V7ZM3 6H2V5H3V6ZM5 6H4V5H5V6ZM2 5H1V4H2V5ZM6 5H5V4H6V5Z\"\n            fill=\"#FAECD1\"\n          />\n        </>\n      ) : (\n        <>\n          <path\n            d=\"M10 9V10H8V9H10ZM8 9H7V8H8V9ZM11 9H10V7H11V9ZM10 7H9V5H10V7ZM11 5H10V3H11V5ZM8 4H7V3H8V4ZM10 3H8V2H10V3Z\"\n            fill=\"#EB5757\"\n          />\n          <path\n            d=\"M2 9H1V8H2V9ZM6 9H5V8H6V9ZM3 8H2V7H3V8ZM5 8H4V7H5V8ZM4 7H3V6H4V7ZM3 6H2V5H3V6ZM5 6H4V5H5V6ZM2 5H1V4H2V5ZM6 5H5V4H6V5Z\"\n            fill=\"#FAECD1\"\n          />\n          <path\n            d=\"M11 2H12V10H11V11H7V10H4V9H3V10H0V7H1V6H0V3H3V4H4V3H6V2H7V1H11V2ZM10 9H8V8H7V9H8V10H10V9H11V7H10V9ZM5 5H4V6H3V5H2V6H3V7H2V8H1V9H2V8H3V7H4V8H5V7H4V6H5V5H6V4H5V5ZM5 9H6V8H5V9ZM7 6H6V7H8V5H7V6ZM8 3H7V4H8V3H10V5H9V7H10V5H11V3H10V2H8V3ZM1 5H2V4H1V5Z\"\n            fill=\"black\"\n            fillOpacity=\"0.8\"\n          />\n        </>\n      )}\n    </svg>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Person.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Stats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Trophy.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/Trophy.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 28,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "neverNullish",
        "endLine": 28,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { IllustrationProps } from './types';\n\ntype TrophyVariant = 'gold' | 'silver' | 'bronze';\n\nexport function Trophy({\n  variant = 'gold',\n  size = 12,\n  title = '',\n  className = '',\n  ...props\n}: IllustrationProps & { variant?: TrophyVariant }) {\n  // Metal colors\n  const fillColors: Record<TrophyVariant, string> = {\n    gold: '#f2c94c',\n    silver: '#c0c0c0',\n    bronze: '#cd7f32',\n  };\n\n  return (\n    <svg\n      fill=\"none\"\n      height={size}\n      width={size}\n      viewBox=\"0 0 12 12\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      className={className}\n      aria-label={title ?? `${variant} trophy`}\n      role=\"img\"\n      {...props}\n    >\n      <path\n        d=\"m9 11h-6v-1h6zm-2-2h-2v-2h2zm2-4h-1v1h-4v-1h-1v-4h6zm-7-1h-1v-2h1zm9 0h-1v-2h1z\"\n        fill={fillColors[variant]}\n      />\n      <path\n        d=\"m3 11h6v-1h1v2h-8v-2h1zm7-10h2v3h-1v-2h-1v2h1v1h-1v1h-1v1h-1v2h1v1h-6v-1h1v-2h-1v-1h-1v-1h-1v-1h1v-2h-1v2h-1v-3h2v-1h8zm-5 8h2v-2h-2zm-2-4h1v1h4v-1h1v-4h-6z\"\n        fill=\"#000\"\n        fillOpacity=\".8\"\n      />\n      <path d=\"m5 3h-1v-2h1z\" fill=\"#fff\" fillOpacity=\".5\" />\n      <path\n        d=\"m9 11h-2v-1h2zm-2-2h-1v-2h1zm1-3h-1v-1h1zm1-1h-1v-4h1zm2-1h-1v-2h1z\"\n        fill=\"#000\"\n        fillOpacity=\".3\"\n      />\n    </svg>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/components/illustrations/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/hooks/useActiveEffects.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"effects_updated\" === \"effects_updated\"` is true.",
        "line": 47,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 47,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 49,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 49,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 52,
        "column": 50,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 52,
        "endColumn": 62,
        "fix": { "range": [1749, 1761], "text": "{ cb(filtered); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-deprecated",
        "severity": 1,
        "message": "`disconnect` is deprecated. Use `disconnectRealtime()`.",
        "line": 66,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "deprecatedWithReason",
        "endLine": 66,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useEffect, useMemo, useRef, useState } from 'react';\nimport { connectRealtime, context } from '@devvit/web/client';\nimport { REALTIME_CHANNELS } from '@shared/realtime';\nimport { trpc } from '@client/trpc/client';\nimport type { ConsumableEffect, ConsumableId } from '@shared/consumables';\n\nexport type ActiveEffectEntry = {\n  activationId: string;\n  itemId: ConsumableId;\n  effect: ConsumableEffect;\n  expiresAt: number; // epoch ms\n};\n\ntype EffectsUpdatedMessage = {\n  type: 'effects_updated';\n  effects: ActiveEffectEntry[];\n  timestamp: number;\n};\n\n// Global manager to keep a single realtime connection per user\nclass RealtimeRewardsManager {\n  private connection: Awaited<ReturnType<typeof connectRealtime>> | null = null;\n  private subscribers = new Set<(effects: ActiveEffectEntry[]) => void>();\n\n  async connect(\n    onEffectsUpdate: (effects: ActiveEffectEntry[]) => void\n  ): Promise<() => void> {\n    const userId = context.userId;\n    if (!userId)\n      return () => {\n        return;\n      };\n\n    const channelName = REALTIME_CHANNELS.userRewards(userId);\n\n    // Add subscriber\n    this.subscribers.add(onEffectsUpdate);\n\n    // Create connection if it doesn't exist\n    if (!this.connection) {\n      try {\n        this.connection = await connectRealtime({\n          channel: channelName,\n          onMessage: (data) => {\n            if (data && typeof data === 'object' && 'type' in data) {\n              const message = data as EffectsUpdatedMessage;\n              if (message.type === 'effects_updated') {\n                const now = Date.now();\n                const filtered = (message.effects || []).filter(\n                  (e) => e.expiresAt > now\n                );\n                this.subscribers.forEach((cb) => cb(filtered));\n              }\n            }\n          },\n        });\n      } catch {\n        // Ignore connection failures\n      }\n    }\n\n    // Return cleanup\n    return () => {\n      this.subscribers.delete(onEffectsUpdate);\n      if (this.subscribers.size === 0 && this.connection) {\n        void this.connection.disconnect();\n        this.connection = null;\n      }\n    };\n  }\n}\n\nconst realtimeRewardsManager = new RealtimeRewardsManager();\n\nexport function useActiveEffects(): {\n  effects: ActiveEffectEntry[];\n  currentEffect: ActiveEffectEntry | null;\n  secondsRemaining: number;\n} {\n  const [effects, setEffects] = useState<ActiveEffectEntry[]>([]);\n  const [cycleIndex, setCycleIndex] = useState(0);\n  const [nowTs, setNowTs] = useState(() => Date.now());\n  const cycleTimerRef = useRef<number | null>(null);\n  const tickTimerRef = useRef<number | null>(null);\n\n  // Initial fetch\n  const { data: initialEffects } = trpc.app.rewards.getActiveEffects.useQuery(\n    undefined,\n    {\n      enabled: !!context.userId,\n      staleTime: 5000,\n    }\n  );\n\n  // Sync from TRPC\n  useEffect(() => {\n    if (initialEffects && Array.isArray(initialEffects)) {\n      const now = Date.now();\n      setEffects(initialEffects.filter((e) => e.expiresAt > now));\n    }\n  }, [initialEffects]);\n\n  // Realtime subscription\n  useEffect(() => {\n    let cleanup: (() => void) | undefined;\n    if (context.userId) {\n      void realtimeRewardsManager\n        .connect((updated) => {\n          setEffects(updated);\n        })\n        .then((c) => {\n          cleanup = c;\n        });\n    }\n    return () => {\n      if (cleanup) cleanup();\n    };\n  }, []);\n\n  // Expiry tick (1s)\n  useEffect(() => {\n    tickTimerRef.current = window.setInterval(() => {\n      const now = Date.now();\n      setNowTs(now);\n      setEffects((prev) => prev.filter((e) => e.expiresAt > now));\n    }, 1000) as unknown as number;\n    return () => {\n      if (tickTimerRef.current) window.clearInterval(tickTimerRef.current);\n      tickTimerRef.current = null;\n    };\n  }, []);\n\n  // Cycle timer (3s)\n  useEffect(() => {\n    // Reset index if out of bounds\n    setCycleIndex((idx) => (effects.length === 0 ? 0 : idx % effects.length));\n    if (cycleTimerRef.current) {\n      window.clearInterval(cycleTimerRef.current);\n      cycleTimerRef.current = null;\n    }\n    if (effects.length > 1) {\n      cycleTimerRef.current = window.setInterval(() => {\n        setCycleIndex((idx) => (idx + 1) % effects.length);\n      }, 3000) as unknown as number;\n    }\n    return () => {\n      if (cycleTimerRef.current) window.clearInterval(cycleTimerRef.current);\n      cycleTimerRef.current = null;\n    };\n  }, [effects.length]);\n\n  const currentEffect = useMemo(() => {\n    if (effects.length === 0) return null;\n    const safeIndex = Math.min(cycleIndex, Math.max(0, effects.length - 1));\n    return effects[safeIndex] ?? null;\n  }, [effects, cycleIndex]);\n\n  const secondsRemaining = useMemo(() => {\n    if (!currentEffect) return 0;\n    return Math.max(0, Math.ceil((currentEffect.expiresAt - nowTs) / 1000));\n  }, [currentEffect, nowTs]);\n\n  return { effects, currentEffect, secondsRemaining };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/hooks/useLevelUpClaim.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"levelup_claimed\" === \"levelup_claimed\"` is true.",
        "line": 40,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 40,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 42,
        "column": 56,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 42,
        "endColumn": 70,
        "fix": { "range": [1440, 1454], "text": "{ callback(true); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-deprecated",
        "severity": 1,
        "message": "`disconnect` is deprecated. Use `disconnectRealtime()`.",
        "line": 58,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "deprecatedWithReason",
        "endLine": 58,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useState, useEffect } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { connectRealtime } from '@devvit/web/client';\nimport { trpc } from '../trpc/client';\nimport { context } from '@devvit/web/client';\nimport { REALTIME_CHANNELS } from '@shared/realtime';\nimport type { RewardType } from '@shared/rewards';\n\ntype UnclaimedLevelUp = {\n  level: number;\n};\n\ntype RealtimeMessage = {\n  type: 'levelup_claimed';\n  timestamp: number;\n};\n\n// Global connection manager to avoid duplicate connections per user\nclass LevelUpClaimManager {\n  private connection: Awaited<ReturnType<typeof connectRealtime>> | null = null;\n  private subscribers = new Set<(claimed: boolean) => void>();\n\n  async connect(onClaimUpdate: (claimed: boolean) => void) {\n    const userId = context.userId;\n    if (!userId) return;\n\n    const channelName = REALTIME_CHANNELS.userLevelUp(userId);\n\n    // Add subscriber\n    this.subscribers.add(onClaimUpdate);\n\n    // Create connection if it doesn't exist\n    if (!this.connection) {\n      try {\n        this.connection = await connectRealtime({\n          channel: channelName,\n          onMessage: (data) => {\n            if (data && typeof data === 'object' && 'type' in data) {\n              const message = data as RealtimeMessage;\n              if (message.type === 'levelup_claimed') {\n                // Notify all subscribers\n                this.subscribers.forEach((callback) => callback(true));\n              }\n            }\n          },\n        });\n      } catch (error) {\n        // Failed to connect to realtime channel\n      }\n    }\n\n    // Return cleanup function\n    return () => {\n      this.subscribers.delete(onClaimUpdate);\n      // If no more subscribers, close connection\n      if (this.subscribers.size === 0) {\n        if (this.connection) {\n          void this.connection.disconnect();\n          this.connection = null;\n        }\n      }\n    };\n  }\n}\n\nconst levelUpClaimManager = new LevelUpClaimManager();\n\nexport function useLevelUpClaim(): {\n  unclaimedLevel: UnclaimedLevelUp | null;\n  isLoading: boolean;\n  claimLevelUp: (level: number) => Promise<void>;\n} {\n  const queryClient = useQueryClient();\n  const [shouldClaim, setShouldClaim] = useState(false);\n\n  // Get initial data from tRPC\n  const {\n    data: unclaimedLevelData,\n    isLoading,\n    refetch,\n  } = trpc.app.user.getUnclaimedLevelUp.useQuery(undefined, {\n    enabled: !!context.userId,\n    refetchOnMount: true,\n    refetchOnWindowFocus: true,\n  });\n\n  const [unclaimedLevel, setUnclaimedLevel] = useState<UnclaimedLevelUp | null>(\n    null\n  );\n\n  // Claim mutation\n  const claimMutation = trpc.app.user.claimLevelUp.useMutation({\n    onSuccess: () => {\n      // Reset local state\n      setUnclaimedLevel(null);\n      setShouldClaim(false);\n      // Invalidate and refetch unclaimed level data\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'user', 'getUnclaimedLevelUp'],\n      });\n    },\n  });\n\n  // Update local state when data changes\n  useEffect(() => {\n    setUnclaimedLevel(unclaimedLevelData ?? null);\n  }, [unclaimedLevelData]);\n\n  // Refetch when userId changes (e.g., navigation)\n  useEffect(() => {\n    if (context.userId) {\n      void refetch();\n    }\n  }, [refetch]);\n\n  // Handle realtime claim events\n  useEffect(() => {\n    if (!context.userId) return;\n\n    const handleClaimUpdate = (claimed: boolean) => {\n      if (claimed) {\n        // Another instance claimed, clear our state\n        setUnclaimedLevel(null);\n      }\n    };\n\n    let cleanup: (() => void) | undefined;\n\n    void levelUpClaimManager.connect(handleClaimUpdate).then((cleanupFn) => {\n      cleanup = cleanupFn;\n    });\n\n    return () => {\n      if (cleanup) {\n        cleanup();\n      }\n    };\n  }, []);\n\n  // Trigger claim when shouldClaim is true\n  useEffect(() => {\n    if (shouldClaim && unclaimedLevel && !claimMutation.isPending) {\n      void claimMutation.mutateAsync({ level: unclaimedLevel.level });\n    }\n  }, [shouldClaim, unclaimedLevel, claimMutation]);\n\n  const claimLevelUp = async (level: number) => {\n    setShouldClaim(true);\n  };\n\n  return {\n    unclaimedLevel: unclaimedLevel ?? null,\n    isLoading,\n    claimLevelUp,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/hooks/useRealtimeStats.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 34,
        "column": 5,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 34,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1063, 1064], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 47,
        "column": 51,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 47,
        "endColumn": 74,
        "fix": { "range": [1623, 1646], "text": "{ callback(message.stats); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-deprecated",
        "severity": 1,
        "message": "`disconnect` is deprecated. Use `disconnectRealtime()`.",
        "line": 67,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "deprecatedWithReason",
        "endLine": 67,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 97,
        "column": 33,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 97,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [3018, 3049],
              "text": "(optimisticStats ?? initialStats)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 97,
        "column": 49,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 97,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3050, 3052], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'queryClient'. Either include it or remove the dependency array.",
        "line": 129,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 129,
        "endColumn": 14,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [postId, queryClient]",
            "fix": { "range": [3816, 3824], "text": "[postId, queryClient]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useEffect, useRef, useState } from 'react';\nimport { connectRealtime } from '@devvit/web/client';\nimport { REALTIME_CHANNELS } from '@shared/realtime';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { trpc } from '@client/trpc/client';\nimport type { PostGuesses } from '@shared/schema';\n\ntype StatsData = PostGuesses;\n\ntype RealtimeMessage = {\n  type: 'guess_submitted';\n  postId: string;\n  correct: boolean;\n  isFirstSolve?: boolean;\n  timestamp: number;\n  stats: StatsData;\n};\n\n// Global connection manager to avoid duplicate connections\nclass RealtimeManager {\n  private connections = new Map<\n    string,\n    Awaited<ReturnType<typeof connectRealtime>>\n  >();\n  private subscribers = new Map<string, Set<(stats: StatsData) => void>>();\n\n  async connect(postId: string, onStatsUpdate: (stats: StatsData) => void) {\n    const channelName = REALTIME_CHANNELS.post(postId);\n\n    // Add subscriber\n    if (!this.subscribers.has(channelName)) {\n      this.subscribers.set(channelName, new Set());\n    }\n    this.subscribers.get(channelName)!.add(onStatsUpdate);\n\n    // Create connection if it doesn't exist\n    if (!this.connections.has(channelName)) {\n      try {\n        const connection = await connectRealtime({\n          channel: channelName,\n          onMessage: (data) => {\n            if (data && typeof data === 'object' && 'stats' in data) {\n              const message = data as RealtimeMessage;\n              // Notify all subscribers\n              const subscribers = this.subscribers.get(channelName);\n              if (subscribers) {\n                subscribers.forEach((callback) => callback(message.stats));\n              }\n            }\n          },\n        });\n        this.connections.set(channelName, connection);\n      } catch (error) {\n        // Failed to connect to realtime channel\n      }\n    }\n\n    // Return cleanup function\n    return () => {\n      const subscribers = this.subscribers.get(channelName);\n      if (subscribers) {\n        subscribers.delete(onStatsUpdate);\n        // If no more subscribers, close connection\n        if (subscribers.size === 0) {\n          const connection = this.connections.get(channelName);\n          if (connection) {\n            void connection.disconnect();\n            this.connections.delete(channelName);\n            this.subscribers.delete(channelName);\n          }\n        }\n      }\n    };\n  }\n}\n\nconst realtimeManager = new RealtimeManager();\n\nexport function useRealtimeStats(postId: string): {\n  stats: PostGuesses | null;\n  isLoading: boolean;\n  updateStats: (stats: PostGuesses | null) => void;\n} {\n  const queryClient = useQueryClient();\n  const [optimisticStats, setOptimisticStats] = useState<StatsData | null>(\n    null\n  );\n  const lastUpdateRef = useRef(0);\n\n  // Get initial data from tRPC\n  const { data: initialStats, isLoading } = trpc.app.guess.getStats.useQuery(\n    { postId },\n    { enabled: !!postId }\n  );\n\n  // Use optimistic stats if available, otherwise fall back to initial stats\n  const stats = optimisticStats || initialStats || null;\n\n  // Handle realtime updates\n  useEffect(() => {\n    if (!postId) return;\n\n    const THROTTLE_MS = 100;\n    const handleStatsUpdate = (newStats: StatsData) => {\n      const now = Date.now();\n      if (now - lastUpdateRef.current < THROTTLE_MS) return;\n      lastUpdateRef.current = now;\n      setOptimisticStats(newStats);\n      queryClient.setQueryData(\n        ['pixelary', 'guess', 'stats', postId],\n        newStats\n      );\n    };\n\n    let cleanup: (() => void) | undefined;\n\n    void realtimeManager\n      .connect(postId, handleStatsUpdate)\n      .then((cleanupFn) => {\n        cleanup = cleanupFn;\n      });\n\n    return () => {\n      if (cleanup) {\n        cleanup();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [postId]);\n\n  // Reset optimistic stats when initial data changes (e.g., page refresh)\n  useEffect(() => {\n    if (initialStats && !optimisticStats) {\n      setOptimisticStats(null);\n    }\n  }, [initialStats, optimisticStats]);\n\n  return {\n    stats,\n    isLoading,\n    // Helper for optimistic updates\n    updateStats: setOptimisticStats,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/hooks/useSlate.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 11,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 11,
        "endColumn": 27,
        "fix": { "range": [198, 225], "text": "type SlateContextType = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, {\n  createContext,\n  useContext,\n  useState,\n  useCallback,\n  useEffect,\n} from 'react';\nimport { trpc } from '@client/trpc/client';\nimport type { SlateAction } from '@shared/types';\n\ninterface SlateContextType {\n  slateId: string | null;\n  setSlateId: (slateId: string | null) => void;\n  trackSlateAction: (\n    action: SlateAction,\n    word?: string,\n    metadata?: Record<string, string | number>\n  ) => Promise<void>;\n}\n\nconst SlateContext = createContext<SlateContextType | null>(null);\n\nexport function SlateProvider({ children }: { children: React.ReactNode }) {\n  const [slateId, setSlateId] = useState<string | null>(null);\n  const trackSlateActionMutation = trpc.app.slate.trackAction.useMutation();\n\n  // Debug slateId changes\n  useEffect(() => {\n    // SlateId changed\n  }, [slateId]);\n\n  const trackSlateAction = useCallback(\n    async (\n      action: SlateAction,\n      word?: string,\n      metadata?: Record<string, string | number>\n    ) => {\n      if (!slateId) {\n        return;\n      }\n\n      await trackSlateActionMutation.mutateAsync({\n        slateId,\n        action,\n        word,\n        metadata,\n      });\n    },\n    [slateId, trackSlateActionMutation]\n  );\n\n  const memoizedSetSlateId = useCallback((newSlateId: string | null) => {\n    setSlateId(newSlateId);\n  }, []);\n\n  return (\n    <SlateContext.Provider\n      value={{ slateId, setSlateId: memoizedSetSlateId, trackSlateAction }}\n    >\n      {children}\n    </SlateContext.Provider>\n  );\n}\n\nexport function useSlate() {\n  const context = useContext(SlateContext);\n  if (!context) {\n    throw new Error('useSlate must be used within a SlateProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/hooks/useTelemetry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 5,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 5,
        "endColumn": 31,
        "fix": { "range": [173, 204], "text": "type TelemetryContextType = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React, { createContext, useContext, useCallback } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport type { TelemetryEventType } from '@shared/types';\n\ninterface TelemetryContextType {\n  track: (\n    eventType: TelemetryEventType,\n    metadata?: Record<string, string | number>\n  ) => Promise<{ ok: boolean }>;\n}\n\nconst TelemetryContext = createContext<TelemetryContextType | null>(null);\n\n/**\n * Provider for telemetry tracking\n * Provides tRPC-based tracking that can be awaited when needed\n * Post type is automatically detected from server context\n */\nexport function TelemetryProvider({ children }: { children: React.ReactNode }) {\n  const trackMutation = trpc.app.telemetry.track.useMutation();\n\n  const track = useCallback(\n    async (\n      eventType: TelemetryEventType,\n      metadata?: Record<string, string | number>\n    ) => {\n      const payload: Record<string, unknown> = { eventType };\n\n      if (metadata && Object.keys(metadata).length > 0) {\n        payload.metadata = metadata;\n      }\n\n      return trackMutation.mutateAsync(\n        payload as {\n          eventType: string;\n          metadata?: Record<string, string | number>;\n        }\n      );\n    },\n    [trackMutation]\n  );\n\n  return (\n    <TelemetryContext.Provider value={{ track }}>\n      {children}\n    </TelemetryContext.Provider>\n  );\n}\n\n/**\n * Hook for telemetry tracking\n * Must be used within TelemetryProvider\n */\nexport function useTelemetry() {\n  const context = useContext(TelemetryContext);\n  if (!context) {\n    throw new Error('useTelemetry must be used within a TelemetryProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/collection-post/CollectionPost.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 14,
        "column": 7,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 14,
        "endColumn": 50,
        "fix": {
          "range": [595, 638],
          "text": "postData?.type !== 'collection'"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always false, since `\"collection\" !== \"collection\"` is false.",
        "line": 14,
        "column": 20,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 14,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 77,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 77,
        "endColumn": 56,
        "fix": {
          "range": [2257, 2285],
          "text": "{ handleDrawingClick(d.postId); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { trpc } from '@client/trpc/client';\nimport { getPostData } from '@client/utils/context';\nimport { Drawing } from '@client/components/Drawing';\nimport { Text } from '@client/components/PixelFont';\nimport { Button } from '@client/components/Button';\nimport { Shimmer } from '@client/components/Shimmer';\nimport { CyclingMessage } from '@client/components/CyclingMessage';\nimport { context, navigateTo } from '@devvit/web/client';\nimport type { CollectionPostData } from '@src/shared/schema';\n\nexport function CollectionPost() {\n  const postData = getPostData<CollectionPostData>();\n\n  if (!postData || postData.type !== 'collection') {\n    return null;\n  }\n\n  const { data, isLoading, error } = trpc.app.post.getCollection.useQuery({\n    collectionId: postData.collectionId,\n  });\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-full w-full\">\n        <Text>Loading...</Text>\n      </div>\n    );\n  }\n\n  if (error || !data) {\n    return (\n      <div className=\"flex items-center justify-center h-full w-full\">\n        <Text>Failed to load collection</Text>\n      </div>\n    );\n  }\n\n  if (data.drawings.length === 0) {\n    return (\n      <div className=\"flex items-center justify-center h-full w-full\">\n        <Text>No drawings found</Text>\n      </div>\n    );\n  }\n\n  const handleDrawingClick = (postId: string) => {\n    const url = `https://reddit.com/r/${context.subredditName}/comments/${postId}`;\n    navigateTo(url);\n  };\n\n  const handleVisit = () => {\n    const url = `https://reddit.com/r/${context.subredditName}`;\n    navigateTo(url);\n  };\n\n  const titleLines = data.label\n    .split('\\n')\n    .map((line) => line.trim())\n    .filter((line) => line.length > 0);\n\n  return (\n    <div className=\"absolute flex flex-col gap-6 items-center justify-center h-full w-full text-black\">\n      <div className=\"flex flex-col gap-2 items-center justify-center\">\n        {titleLines.map((line, index) => (\n          <Text key={index} scale={3}>\n            {line}\n          </Text>\n        ))}\n      </div>\n\n      <div className=\"grid grid-cols-3 gap-3\">\n        {data.drawings.map((d) => (\n          <Drawing\n            key={d.postId}\n            data={d.drawing}\n            size={88}\n            onClick={() => handleDrawingClick(d.postId)}\n          />\n        ))}\n      </div>\n\n      <CyclingMessage\n        messages={[\n          'Click to view drawings',\n          'Check out the comments',\n          'Thanks for playing',\n        ]}\n        className=\"text-secondary\"\n      />\n\n      <Button onClick={handleVisit} size=\"large\">\n        {`Visit r/${context.subredditName}`}\n      </Button>\n\n      {/* Timed shimmer overlay */}\n      <Shimmer />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/collection-post/entry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nimport { Background } from '@components/Background';\nimport { CollectionPost } from './CollectionPost';\n\nimport { Providers } from '@components/Providers';\nimport { setupGlobalErrorHandlers } from '@utils/errors';\n\nsetupGlobalErrorHandlers();\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <Providers>\n      <Background />\n      <CollectionPost />\n    </Providers>\n  </React.StrictMode>\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/drawing-post/DrawingPost.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 33,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 33,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 50,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 50,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 179,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 179,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 199,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 199,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 208,
        "column": 22,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 208,
        "endColumn": 39,
        "fix": { "range": [6831, 6848], "text": "{ setFeedback(null); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 234,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 234,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 280,
        "column": 20,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 280,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 281,
        "column": 17,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 281,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 30,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 30,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1330, 1332], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'isAuthorFirstView' and 'userProfile'. Either include them or remove the dependency array.",
        "line": 189,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 196,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [isAuthor, currentPostId, userProfile.score, isAuthorFirstView.isPending, isAuthorFirstView.isSuccess, isAuthorFirstView.isError, userProfile, isAuthorFirstView]",
            "fix": {
              "range": [6366, 6525],
              "text": "[isAuthor, currentPostId, userProfile.score, isAuthorFirstView.isPending, isAuthorFirstView.isSuccess, isAuthorFirstView.isError, userProfile, isAuthorFirstView]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useState, useEffect } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { GuessView } from './_components/GuessView';\nimport { ResultsView } from './_components/ResultsView';\nimport { DrawingEditor } from '@components/Editor/Editor';\nimport { Confetti } from '@components/Confetti';\nimport { ProgressBar } from '@components/ProgressBar';\nimport { trpc } from '@client/trpc/client';\nimport { context } from '@devvit/web/client';\nimport { useToastHelpers } from '@components/ToastManager';\nimport { useRealtimeStats } from '@client/hooks/useRealtimeStats';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { getLevelByScore } from '@src/shared/utils/progression';\nimport { AUTHOR_REWARD_SUBMIT } from '@shared/constants';\nimport { getPostData } from '@client/utils/context';\nimport type { DrawingPostData } from '@src/shared/schema';\n\ntype DrawingState = 'unsolved' | 'guessing' | 'solved' | 'skipped' | 'author';\n\nexport const DrawingPost = () => {\n  const postData = getPostData<DrawingPostData>();\n  const currentPostId = context.postId;\n  const { error: showErrorToast, success } = useToastHelpers();\n\n  // Telemetry\n  const { track } = useTelemetry();\n  useEffect(() => {\n    void track('view_drawing_post');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Fetch realtime stats for both child components\n  const { stats, isLoading } = useRealtimeStats(currentPostId || '');\n\n  // Initialize state based on immediate author check to prevent flash\n  const getInitialState = (): DrawingState => {\n    if (postData && context.userId && postData.authorId === context.userId) {\n      return 'author';\n    }\n    return 'unsolved';\n  };\n\n  const [currentState, setCurrentState] =\n    useState<DrawingState>(getInitialState);\n  const [feedback, setFeedback] = useState<boolean | null>(null);\n  const [showEditor, setShowEditor] = useState(false);\n  const [earnedPoints, setEarnedPoints] = useState<number | null>(null);\n  const [showConfetti, setShowConfetti] = useState(false);\n  const { data: userProfile } = trpc.app.user.getProfile.useQuery(\n    currentPostId ? { postId: currentPostId } : undefined,\n    { enabled: true }\n  );\n  const queryClient = useQueryClient();\n  const submitGuess = trpc.app.guess.submit.useMutation({\n    onSuccess: (data, variables) => {\n      // Invalidate guess stats for this post\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'guess', 'stats', variables.postId],\n      });\n\n      // Invalidate user profile to update score\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'user', 'profile', { postId: variables.postId }],\n      });\n\n      // Invalidate leaderboard\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'leaderboard'],\n      });\n\n      // If correct, invalidate post data to update solve count\n      if (data.correct) {\n        void queryClient.invalidateQueries({\n          queryKey: ['pixelary', 'post', 'drawing', variables.postId],\n        });\n      }\n    },\n  });\n  const skipPost = trpc.app.guess.skip.useMutation({\n    onSuccess: (_: unknown, variables: { postId: string }) => {\n      // Invalidate user profile to update skipped status\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'user', 'profile', { postId: variables.postId }],\n      });\n\n      // Invalidate post data to update skip count\n      void queryClient.invalidateQueries({\n        queryKey: ['pixelary', 'post', 'drawing', variables.postId],\n      });\n    },\n  });\n\n  const isAuthor =\n    postData && context.userId && postData.authorId === context.userId;\n\n  const isAuthorFirstView = trpc.app.post.isAuthorFirstView.useMutation({\n    onSuccess: (result) => {\n      if (result.firstView && userProfile) {\n        // Show welcome toast with progress bar\n        const attachment = (\n          <ProgressBar\n            percentage={getLevelProgressPercentage(\n              userProfile.score + AUTHOR_REWARD_SUBMIT\n            )}\n            width={200}\n            height={8}\n          />\n        );\n        success(`+${AUTHOR_REWARD_SUBMIT} points!`, {\n          duration: 3000,\n          attachment,\n        });\n\n        // Show confetti\n        setShowConfetti(true);\n      }\n    },\n    onError: (error) => {\n      console.error('isAuthorFirstView error:', error);\n    },\n  });\n\n  // Update state based on user's interaction with this post\n  useEffect(() => {\n    if (userProfile && postData) {\n      if (isAuthor) {\n        setCurrentState('author');\n      } else {\n        // Check user's server state\n        if (userProfile.skipped) {\n          setCurrentState('skipped');\n        } else if (userProfile.solved) {\n          setCurrentState('solved');\n        } else {\n          setCurrentState('unsolved');\n        }\n      }\n    }\n  }, [userProfile, postData, isAuthor]);\n\n  // Clear earned points when transitioning away from solved state\n  useEffect(() => {\n    if (currentState !== 'solved') {\n      setEarnedPoints(null);\n    }\n  }, [currentState]);\n\n  // Show points toast when earnedPoints changes\n  useEffect(() => {\n    if (earnedPoints && earnedPoints > 0 && userProfile) {\n      const attachment = (\n        <ProgressBar\n          percentage={getLevelProgressPercentage(\n            userProfile.score + earnedPoints\n          )}\n          width={200}\n          height={8}\n        />\n      );\n      success(`+${earnedPoints} points!`, {\n        duration: 3000,\n        attachment,\n      });\n    }\n  }, [earnedPoints, success, userProfile]);\n\n  // Helper function to calculate level progress percentage\n  const getLevelProgressPercentage = (score: number): number => {\n    const currentLevel = getLevelByScore(score);\n    const levelProgress = score - currentLevel.min;\n    const levelMax = currentLevel.max - currentLevel.min;\n    return Math.min(100, Math.max(0, (levelProgress / levelMax) * 100));\n  };\n\n  // Show welcome toast for author on first view\n  useEffect(() => {\n    const shouldCheckFirstView =\n      isAuthor &&\n      currentPostId &&\n      userProfile &&\n      !isAuthorFirstView.isPending &&\n      !isAuthorFirstView.isSuccess &&\n      !isAuthorFirstView.isError;\n\n    if (shouldCheckFirstView) {\n      void isAuthorFirstView.mutateAsync({ postId: currentPostId });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    isAuthor,\n    currentPostId,\n    userProfile?.score,\n    isAuthorFirstView.isPending,\n    isAuthorFirstView.isSuccess,\n    isAuthorFirstView.isError,\n  ]);\n\n  const handleGuess = async (guess: string) => {\n    if (!currentPostId || !word) {\n      return;\n    }\n\n    // Show immediate feedback\n    const isCorrect = guess.toLowerCase().trim() === word.toLowerCase();\n    setFeedback(isCorrect);\n\n    // Clear feedback after a brief moment\n    setTimeout(() => setFeedback(null), 800);\n\n    // Submit to server and wait for response before changing state\n    try {\n      const result = await submitGuess.mutateAsync({\n        postId: currentPostId,\n        guess,\n      });\n\n      // Only change state after server confirms\n      if (result.correct) {\n        setCurrentState('solved');\n        if (result.points > 0) {\n          setEarnedPoints(result.points);\n        }\n        // Trigger confetti animation\n        setShowConfetti(true);\n      }\n    } catch (err) {\n      showErrorToast('Failed to submit guess. Please try again.', {\n        duration: 5000,\n      });\n    }\n  };\n\n  const handleSkip = async () => {\n    if (!currentPostId) return;\n\n    try {\n      await skipPost.mutateAsync({ postId: currentPostId });\n      setCurrentState('skipped');\n    } catch (err) {\n      showErrorToast('Failed to skip post. Please try again.', {\n        duration: 5000,\n      });\n    }\n  };\n\n  const handleDrawSomething = () => {\n    setShowEditor(true);\n  };\n\n  const handleCloseEditor = () => {\n    setShowEditor(false);\n  };\n\n  // Use actual post data\n  const drawingData = postData?.drawing;\n  const word = postData?.word;\n  const dictionary = postData?.dictionary;\n  const currentSubreddit = context.subredditName;\n\n  // Reset state if we're in solved state but missing essential data (broken state)\n  useEffect(() => {\n    if (currentState === 'solved' && (!drawingData || !word)) {\n      setCurrentState('unsolved');\n    }\n  }, [currentState, drawingData, word]);\n\n  // Show editor if requested\n  if (showEditor) {\n    return <DrawingEditor onClose={handleCloseEditor} />;\n  }\n\n  if (\n    currentState === 'solved' ||\n    currentState === 'skipped' ||\n    currentState === 'author'\n  ) {\n    return (\n      <>\n        <ResultsView\n          drawing={drawingData!}\n          word={word!}\n          authorUsername={postData?.authorName}\n          dictionary={dictionary}\n          currentSubreddit={currentSubreddit}\n          onDrawSomething={handleDrawSomething}\n          stats={stats}\n          isLoading={isLoading}\n          postId={currentPostId}\n        />\n        {showConfetti && <Confetti />}\n      </>\n    );\n  }\n\n  if (!drawingData) {\n    return null;\n  }\n\n  return (\n    <GuessView\n      drawing={drawingData}\n      onGuess={handleGuess}\n      onGiveUp={handleSkip}\n      feedback={feedback}\n      stats={stats}\n      isLoading={isLoading}\n    />\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/drawing-post/_components/GuessView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 13,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 13,
        "endColumn": 25,
        "fix": { "range": [599, 624], "text": "type GuessViewProps = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 63,
        "column": 42,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 63,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1780, 1782], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 64,
        "column": 42,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 64,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1827, 1829], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 125,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 125,
        "endColumn": 52,
        "fix": {
          "range": [3870, 3894],
          "text": "{ setGuess(e.target.value); }"
        }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 39,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 39,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1252, 1254], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { useState, useRef, useEffect } from 'react';\nimport { Button } from '@components/Button';\nimport { Drawing } from '@components/Drawing';\nimport { Shimmer } from '@components/Shimmer';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { PixelInput } from '@components/PixelInput';\nimport { useToastHelpers } from '@components/ToastManager';\nimport { Text } from '@components/PixelFont';\nimport type { PostGuesses } from '@shared/schema/pixelary';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { ActiveEffectsBadge } from '@components/ActiveEffectsBadge';\n\ninterface GuessViewProps {\n  drawing: DrawingData;\n  onGuess: (guess: string) => Promise<void>;\n  onGiveUp: () => Promise<void>;\n  feedback?: boolean | null;\n  stats?: PostGuesses | null;\n  isLoading?: boolean;\n}\n\nexport function GuessView({\n  drawing,\n  onGuess,\n  onGiveUp,\n  feedback,\n  stats,\n  isLoading,\n}: GuessViewProps) {\n  const [guess, setGuess] = useState('');\n  const inputRef = useRef<HTMLInputElement>(null);\n  const { warning } = useToastHelpers();\n  const { track } = useTelemetry();\n\n  // Track guess view on mount\n  useEffect(() => {\n    void track('post_impression');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleGuessSubmit = async () => {\n    if (!guess.trim()) {\n      warning('Please enter a guess!', { duration: 2000 });\n      return;\n    }\n\n    // Track guess submit\n    void track('post_guess');\n\n    try {\n      await onGuess(guess.trim().toLowerCase());\n      setGuess('');\n\n      // Restore focus to input field after submission\n      setTimeout(() => {\n        inputRef.current?.focus();\n      }, 100);\n    } catch (error) {\n      // Failed to submit guess\n    }\n  };\n\n  const playerCount = stats?.playerCount || 0;\n  const solvedCount = stats?.solvedCount || 0;\n  const solvePercentage =\n    playerCount > 0 ? Math.round((solvedCount / playerCount) * 100) : 0;\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-evenly px-5\">\n      <ActiveEffectsBadge />\n      {/* Drawing */}\n      <div className=\"relative h-64 w-64 flex items-center justify-center\">\n        <Drawing\n          data={drawing}\n          size={256}\n          enableBreathing={true}\n          isPaused={feedback === false}\n        />\n        {/* Feedback overlay - covers whole game area */}\n        <div\n          className={`absolute inset-0 flex items-center justify-center bg-orangered/70 transition-opacity pointer-events-none ${\n            feedback === false ? 'opacity-100' : 'opacity-0'\n          }`}\n        >\n          {/* Pixel X - Scaled to align with canvas grid */}\n          <svg\n            width=\"160\"\n            height=\"160\"\n            viewBox=\"0 0 10 10\"\n            className=\"animate-incorrect-guess\"\n          >\n            <path\n              d=\"M2 1H3V2H4V3H6V2H7V1H8V0H10V2H9V3H8V4H7V6H8V7H9V8H10V10H8V9H7V8H6V7H4V8H3V9H2V10H0V8H1V7H2V6H3V4H2V3H1V2H0V0H2V1Z\"\n              fill=\"white\"\n            />\n          </svg>\n        </div>\n      </div>\n\n      {/* Player Count */}\n      <div className=\"w-full flex flex-col gap-2 items-center justify-center\">\n        {!isLoading ? (\n          <Text scale={2.5}>\n            {`${playerCount.toLocaleString()} player${\n              playerCount !== 1 ? 's' : ''\n            } tried`}\n          </Text>\n        ) : (\n          <div className=\"w-[232.5px] h-[17.5px] skeleton\" />\n        )}\n        {!isLoading ? (\n          <Text className=\"text-secondary\">\n            {`${solvePercentage}% solved it`}\n          </Text>\n        ) : (\n          <div className=\"w-[156px] h-[14px] skeleton\" />\n        )}\n      </div>\n\n      {/* Guess Button */}\n      <div className=\"w-full flex flex-row gap-3 items-center justify-center max-w-xs\">\n        <PixelInput\n          ref={inputRef}\n          value={guess}\n          onChange={(e) => setGuess(e.target.value)}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter') {\n              void handleGuessSubmit();\n            }\n          }}\n          placeholderPhrases={['My guess...', 'Bird?', 'Plane?']}\n        />\n        <Button\n          onClick={() => void handleGuessSubmit()}\n          size=\"large\"\n          telemetryEvent=\"click_guess_submit\"\n        >\n          SEND\n        </Button>\n      </div>\n\n      {/* Give Up Button */}\n      <button\n        onClick={() => {\n          void track('post_skip');\n          void onGiveUp();\n        }}\n        className=\"flex items-center justify-center cursor-pointer\"\n      >\n        <svg\n          width=\"144\"\n          height=\"34\"\n          viewBox=\"0 0 144 34\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <path\n            fill-rule=\"evenodd\"\n            clip-rule=\"evenodd\"\n            d=\"M12 8H10V20H12V8Z M24 24H26.0498V26H24V24Z M28.0371 24H30.1368V26H28.0371V24Z M32.1241 24H34.2238V26H32.1241V24Z M36.211 24H38.3107V26H36.211V24Z M40.298 24H42.3977V26H40.298V24Z M44.3849 24H46.4846V26H44.3849V24Z M48.4719 24H50.5716V26H48.4719V24Z M52.5589 24H54.6585V26H52.5589V24Z M56.6458 24H58.7455V26H56.6458V24Z M60.7328 24H62.8325V26H60.7328V24Z M64.8197 24H66.9194V26H64.8197V24Z M68.9067 24H71.0064V26H68.9067V24Z M72.9936 24H75.0933V26H72.9936V24Z M77.0806 24H79.1803V26H77.0806V24Z M81.1675 24H83.2672V26H81.1675V24Z M85.2545 24H87.3542V26H85.2545V24Z M89.3415 24H91.4411V26H89.3415V24Z M93.4284 24H95.5281V26H93.4284V24Z M97.5154 24H99.6151V26H97.5154V24Z M101.602 24H103.702V26H101.602V24Z M105.689 24H107.789V26H105.689V24Z M109.776 24H111.876V26H109.776V24Z M113.863 24H115.963V26H113.863V24Z M117.95 24H120V26H117.95V24Z M36 8H26V10H24V18H26V20H36V14H30V16H32V18H28V10H36V8Z M38 8H50V10H46V18H50V20H38V18H42V10H38V8Z M52 8H56V16H60V8H64V16H62V18H60V20H56V18H54V16H52V8Z M78 8H66V20H78V18H70V14H76V12H70V10H78V8Z M98 8H94V20H106V8H102V18H98V8Z M108 8V20H112V16H118V14H120V10H118V8H108ZM112 10V14H116V10H112Z M134 8H132V20H134V8Z\"\n            fill=\"var(--color-tertiary)\"\n          />\n          <path\n            d=\"M10 8H8V10H6V8H2V10H0V16H2V14H6V16H10V8Z M134 8H136V10H138V8H142V10H144V16H142V14H138V16H134V8Z\"\n            fill=\"white\"\n          />\n        </svg>\n      </button>\n\n      {/* Timed shimmer overlay */}\n      <Shimmer />\n    </main>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/drawing-post/_components/ResultsView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 17,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 17,
        "endColumn": 27,
        "fix": { "range": [788, 815], "text": "type ResultsViewProps = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 58,
        "column": 24,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 58,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1925, 1927], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 64,
        "column": 30,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 64,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2082, 2084], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 71,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 71,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2278, 2280], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 72,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 72,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2324, 2326], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 73,
        "column": 42,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 73,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2371, 2373], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 78,
        "column": 30,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 78,
        "endColumn": 41,
        "fix": { "range": [2575, 2585], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 78,
        "column": 46,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 78,
        "endColumn": 57,
        "fix": { "range": [2591, 2601], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 94,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 94,
        "endColumn": 49,
        "fix": { "range": [3047, 3070], "text": "{ setIsLightboxOpen(true); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `2 >= 2` is true.",
        "line": 124,
        "column": 28,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 124,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 162,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 162,
        "endColumn": 48,
        "fix": {
          "range": [5302, 5326],
          "text": "{ setIsLightboxOpen(false); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 172,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 172,
        "endColumn": 24,
        "fix": { "range": [5470, 5494], "text": "type GuessRowProps = " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 48,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 48,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1544, 1546], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 6,
    "source": "import { Button } from '@components/Button';\nimport { Icon } from '@components/PixelFont';\nimport { Drawing } from '@components/Drawing';\nimport { Lightbox } from '@components/Lightbox';\nimport { trpc } from '@client/trpc/client';\nimport { abbreviateNumber } from '@shared/utils/numbers';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { Text } from '@components/PixelFont';\nimport { CyclingMessage } from '@components/CyclingMessage';\nimport { AUTHOR_REWARD_SUBMIT } from '@shared/constants';\nimport { titleCase } from '@shared/utils/string';\nimport { useState, useEffect } from 'react';\nimport { useToastHelpers } from '@components/ToastManager';\nimport type { PostGuesses } from '@shared/schema/pixelary';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\n\ninterface ResultsViewProps {\n  drawing: DrawingData;\n  word: string;\n  authorUsername?: string | undefined;\n  dictionary?: string | undefined;\n  currentSubreddit?: string | undefined;\n  onDrawSomething: () => void;\n  stats?: PostGuesses | null;\n  isLoading?: boolean;\n  postId?: string;\n}\n\nexport function ResultsView({\n  drawing,\n  word,\n  authorUsername,\n  dictionary,\n  currentSubreddit,\n  onDrawSomething,\n  stats,\n  isLoading,\n  postId,\n}: ResultsViewProps) {\n  const [isLightboxOpen, setIsLightboxOpen] = useState(false);\n  const { success } = useToastHelpers();\n  const { track } = useTelemetry();\n\n  // Track results view on mount\n  useEffect(() => {\n    void track('view_results');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Mutation for revealing guesses\n  const revealGuess = trpc.app.post.revealGuess.useMutation();\n\n  const handleGuessRowClick = async (guess: string) => {\n    try {\n      // Fire event for all users, server will decide if they get the reveal\n      const normalizedGuess = titleCase(guess.trim());\n      const result = await revealGuess.mutateAsync({\n        postId: postId || '',\n        guess: normalizedGuess,\n      });\n\n      // Show toast if server revealed the guess\n      if (result.revealed) {\n        success(result.guess || normalizedGuess, { duration: 2000 });\n      }\n    } catch (error) {\n      // Server will handle permission checks, so we can ignore errors silently\n    }\n  };\n\n  const guesses = stats?.guesses || {};\n  const guessCount = stats?.guessCount || 0;\n  const playerCount = stats?.playerCount || 0;\n\n  // Sort guesses by count (descending) and take top 5\n  const topGuesses = Object.entries(guesses)\n    .filter(([, count]) => typeof count === 'number' && count > 0)\n    .sort(([, a], [, b]) => (b as number) - (a as number))\n    .slice(0, 5);\n\n  // Rendering flags\n  const showTag =\n    dictionary &&\n    dictionary !== 'main' &&\n    dictionary !== `r/${currentSubreddit}`;\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-center h-full p-6 gap-6\">\n      {/* Header */}\n      <header className=\"flex flex-row items-center justify-center gap-4\">\n        <Drawing\n          data={drawing}\n          size={64}\n          onClick={() => setIsLightboxOpen(true)}\n        />\n        <div className=\"flex flex-col items-start justify-center gap-1.5\">\n          {/* Word */}\n          <Text>{word}</Text>\n          {/* Author */}\n          <Text className=\"text-secondary\">{`By u/${authorUsername}`}</Text>\n          {/* Dictionary Tag */}\n          {showTag && (\n            <div className=\"flex items-center gap-2 text-secondary\">\n              <Icon type=\"clock\" />\n              <Text>{`${dictionary} event`}</Text>\n            </div>\n          )}\n        </div>\n      </header>\n      {/* Guess and Player Count */}\n      {!isLoading ? (\n        <Text>\n          {`${abbreviateNumber(guessCount)} guess${guessCount !== 1 ? 'es' : ''} by ${abbreviateNumber(playerCount)} player${\n            playerCount !== 1 ? 's' : ''\n          }`}\n        </Text>\n      ) : (\n        <div className=\"w-72 h-[14px] skeleton\" />\n      )}\n      {/* Guesses */}\n      <div className=\"w-full max-w-lg flex flex-col gap-2 h-full flex-1\">\n        {Array.from({ length: 5 }, (_, index) => {\n          const guessData = topGuesses[index];\n          if (guessData && guessData.length >= 2) {\n            const [guess, count] = guessData;\n            if (typeof guess === 'string' && typeof count === 'number') {\n              const percentage =\n                guessCount > 0 ? Math.round((count / guessCount) * 100) : 0;\n              return (\n                <GuessRow\n                  key={`guess-${guess}-${index}`}\n                  guess={guess}\n                  count={count}\n                  percentage={percentage}\n                  onGuessClick={handleGuessRowClick}\n                />\n              );\n            }\n          }\n          return <GuessRow key={`blank-${index}`} />;\n        })}\n      </div>\n      {/* Secondary CTA */}\n      <CyclingMessage\n        messages={[\n          'See comments for more',\n          `Draw for ${AUTHOR_REWARD_SUBMIT} points`,\n          'Join r/Pixelary today',\n        ]}\n      />\n      {/* Primary CTA */}\n      <Button\n        onClick={onDrawSomething}\n        size=\"large\"\n        telemetryEvent=\"click_draw_something\"\n      >\n        DRAW SOMETHING\n      </Button>\n      {/* Lightbox */}\n      <Lightbox\n        isOpen={isLightboxOpen}\n        onClose={() => setIsLightboxOpen(false)}\n        drawing={drawing}\n        author={authorUsername}\n      >\n        <Text scale={3}>{word}</Text>\n      </Lightbox>\n    </main>\n  );\n}\n\ninterface GuessRowProps {\n  guess?: string;\n  count?: number;\n  percentage?: number;\n  onGuessClick?: (guess: string) => void;\n}\n\nfunction GuessRow(props: GuessRowProps) {\n  const { guess, count, percentage, onGuessClick } = props;\n\n  // Check if this is an empty row (no data provided)\n  if (guess === undefined || count === undefined || percentage === undefined) {\n    return <div className=\"w-full h-1/5 bg-white-25\" />;\n  }\n\n  const handleClick = () => {\n    if (onGuessClick && guess) {\n      onGuessClick(guess);\n    }\n  };\n\n  return (\n    <div\n      className=\"flex items-center gap-3 px-3 justify-between w-full h-1/5 bg-white-25 relative\"\n      onClick={handleClick}\n    >\n      <div\n        className=\"absolute inset-y-0 left-0 bg-white transition-all duration-300\"\n        style={{ width: `${percentage}%` }}\n      />\n\n      <Text className=\"relative\">{guess}</Text>\n\n      <div className=\"relative flex items-center gap-3\">\n        <Text className=\"text-tertiary\">{abbreviateNumber(count)}</Text>\n        <Text className=\"text-secondary\">{`${percentage}%`}</Text>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/drawing-post/entry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nimport { Background } from '@components/Background';\nimport { DrawingPost } from './DrawingPost';\n\nimport { Providers } from '@components/Providers';\nimport { setupGlobalErrorHandlers } from '@utils/errors';\n\nsetupGlobalErrorHandlers();\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <Providers>\n      <Background />\n      <DrawingPost />\n    </Providers>\n  </React.StrictMode>\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/PinnedPost.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 51,
        "column": 25,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 51,
        "endColumn": 44,
        "fix": { "range": [1298, 1317], "text": "{ goToPage('drawing'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 52,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 52,
        "endColumn": 54,
        "fix": { "range": [1349, 1372], "text": "{ goToPage('my-drawings'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 53,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 53,
        "endColumn": 55,
        "fix": { "range": [1405, 1428], "text": "{ goToPage('leaderboard'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 54,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 54,
        "endColumn": 52,
        "fix": { "range": [1459, 1481], "text": "{ goToPage('my-rewards'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 55,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 55,
        "endColumn": 56,
        "fix": {
          "range": [1513, 1538],
          "text": "{ goToPage('level-details'); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 5,
    "source": "import { useState } from 'react';\nimport { DrawingEditor } from '@client/components/Editor/Editor';\nimport { MyDrawings } from './_components/MyDrawings';\nimport { Leaderboard } from './_components/Leaderboard';\nimport { MyRewards } from './_components/MyRewards';\nimport { LevelDetails } from './_components/LevelDetails';\nimport { Menu } from './_components/Menu';\nimport { trpc } from '@client/trpc/client';\n\ntype Page =\n  | 'menu'\n  | 'drawing'\n  | 'my-drawings'\n  | 'leaderboard'\n  | 'my-rewards'\n  | 'level-details';\n\nexport function PinnedPost() {\n  const [page, setPage] = useState<Page>('menu');\n\n  // Prefetch drawings optimistically for maximum performance\n  trpc.app.user.getDrawings.useQuery(\n    { limit: 20 },\n    {\n      staleTime: 60000, // Cache for 1 minute\n      refetchOnWindowFocus: false, // Don't refetch on window focus\n    }\n  );\n\n  // Prefetch leaderboard data for instant loading\n  trpc.app.leaderboard.getTop.useQuery(\n    { limit: 10 },\n    {\n      staleTime: 60000, // Cache for 1 minute\n      refetchOnWindowFocus: false, // Don't refetch on window focus\n    }\n  );\n\n  function handleClose() {\n    setPage('menu');\n  }\n\n  function goToPage(page: Page) {\n    setPage(page);\n  }\n\n  switch (page) {\n    case 'menu':\n      return (\n        <Menu\n          onDraw={() => goToPage('drawing')}\n          onMyDrawings={() => goToPage('my-drawings')}\n          onLeaderboard={() => goToPage('leaderboard')}\n          onHowToPlay={() => goToPage('my-rewards')}\n          onLevelClick={() => goToPage('level-details')}\n        />\n      );\n    case 'drawing':\n      return <DrawingEditor onClose={handleClose} />;\n    case 'my-drawings':\n      return <MyDrawings onClose={handleClose} />;\n    case 'leaderboard':\n      return <Leaderboard onClose={handleClose} />;\n    case 'my-rewards':\n      return <MyRewards onClose={handleClose} />;\n    case 'level-details':\n      return <LevelDetails onClose={handleClose} />;\n    default:\n      return null;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/CardLayout.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 5,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 5,
        "endColumn": 26,
        "fix": { "range": [127, 153], "text": "type CardLayoutProps = " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import React from 'react';\nimport { Text } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\n\ninterface CardLayoutProps {\n  title: string;\n  onClose: () => void;\n  children: React.ReactNode;\n}\n\nexport function CardLayout(props: CardLayoutProps) {\n  const { title, onClose, children } = props;\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col p-4 gap-4\">\n      {/* Header */}\n      <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n        <Text scale={2.5}>{title}</Text>\n\n        <IconButton onClick={onClose} symbol=\"X\" />\n      </header>\n\n      {/* Card */}\n      <div className=\"flex-1 w-full h-full relative bg-white p-4 flex flex-col items-center justify-center shadow-pixel\">\n        {children}\n      </div>\n    </main>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/Leaderboard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 9,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 9,
        "endColumn": 27,
        "fix": { "range": [354, 381], "text": "type LeaderboardProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 64,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 64,
        "endColumn": 30,
        "fix": { "range": [1907, 1937], "text": "type LeaderboardRowProps = " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 19,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 19,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [642, 644], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { trpc } from '@client/trpc/client';\nimport { abbreviateNumber } from '@shared/utils/numbers';\nimport { Text, Icon } from '@components/PixelFont';\nimport { CardLayout } from './CardLayout';\nimport type { LeaderboardEntry } from '@shared/schema/index';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { useEffect } from 'react';\n\ninterface LeaderboardProps {\n  onClose: () => void;\n}\n\nexport function Leaderboard({ onClose }: LeaderboardProps) {\n  // Telemetry\n  const { track } = useTelemetry();\n  useEffect(() => {\n    void track('view_leaderboard');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Grab data\n  const { data: leaderboard = [], isLoading } =\n    trpc.app.leaderboard.getTop.useQuery({ limit: 10 });\n  const { data: userRank } = trpc.app.user.getRank.useQuery();\n\n  return (\n    <CardLayout title=\"Leaderboard\" onClose={onClose}>\n      {/* Top 10 */}\n      <div className=\"h-full w-full flex flex-col\">\n        {isLoading && leaderboard.length === 0 ? (\n          <div className=\"flex items-center justify-center h-full\">\n            <Text>Loading...</Text>\n          </div>\n        ) : (\n          <>\n            {leaderboard.map((player: LeaderboardEntry, index: number) => (\n              <LeaderboardRow\n                key={index}\n                rank={index + 1}\n                username={player.username}\n                score={player.score}\n              />\n            ))}\n            {/* Current User - only show if not in top N */}\n            {userRank && userRank.rank > leaderboard.length && (\n              <LeaderboardRow\n                rank={userRank.rank}\n                username={userRank.username}\n                score={userRank.score}\n                className=\"border-t-2 border-t-tertiary\"\n              />\n            )}\n          </>\n        )}\n      </div>\n    </CardLayout>\n  );\n}\n\n/*\n * Leaderboard Row\n */\n\ninterface LeaderboardRowProps {\n  rank: number;\n  username: string;\n  score: number;\n  onClick?: () => void;\n  className?: string;\n}\n\nfunction LeaderboardRow({\n  rank,\n  username,\n  score,\n  onClick,\n  className = '',\n}: LeaderboardRowProps) {\n  return (\n    <button\n      className={`w-full h-1/10 flex items-center justify-start ${onClick ? 'cursor-pointer' : ''} ${className}`}\n      onClick={onClick}\n    >\n      {/* Rank + Username */}\n      <div className=\"flex items-center gap-2 w-full flex-1 justify-start overflow-hidden\">\n        <Text className=\"text-secondary\">{`${rank}.`}</Text>\n        <Text>{username}</Text>\n      </div>\n\n      {/* Score */}\n      <div className=\"flex items-center gap-2 text-secondary\">\n        <Text>{abbreviateNumber(score)}</Text>\n        <Icon type=\"star\" />\n      </div>\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/LevelDetails.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 10,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 10,
        "endColumn": 28,
        "fix": { "range": [457, 485], "text": "type LevelDetailsProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 42,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 42,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 61,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 61,
        "endColumn": 39,
        "fix": { "range": [1950, 1969], "text": "{ clearTimeout(timer); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-template-expression",
        "severity": 1,
        "message": "Template literal expression is unnecessary and can be simplified.",
        "line": 116,
        "column": 18,
        "nodeType": null,
        "messageId": "noUnnecessaryTemplateExpression",
        "endLine": 116,
        "endColumn": 97,
        "fix": {
          "range": [3938, 4019],
          "text": "abbreviateNumber(overMinimum ? (userProfile?.score ?? 0) : currentLevel.min)"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 119,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 119,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-template-expression",
        "severity": 1,
        "message": "Template literal expression is unnecessary and can be simplified.",
        "line": 126,
        "column": 16,
        "nodeType": null,
        "messageId": "noUnnecessaryTemplateExpression",
        "endLine": 126,
        "endColumn": 53,
        "fix": {
          "range": [4385, 4424],
          "text": "abbreviateNumber(currentLevel.max)"
        }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 162,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 162,
        "endColumn": 26,
        "fix": { "range": [5388, 5414], "text": "type RewardItemProps = " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 21,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 21,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [775, 777], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 5,
    "source": "import { useState, useEffect } from 'react';\nimport { generateLevel, getLevelByScore } from '@shared/utils/progression';\nimport { abbreviateNumber } from '@shared/utils/numbers';\nimport { Text, Icon } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\nimport { trpc } from '@client/trpc/client';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { getRewardsByLevel, getRewardLabel } from '@shared/rewards';\n\ninterface LevelDetailsProps {\n  onClose: () => void;\n}\n\nexport function LevelDetails({ onClose }: LevelDetailsProps) {\n  const { track } = useTelemetry();\n\n  // Track level details view on mount\n  useEffect(() => {\n    void track('view_level_details');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // Get user profile to show their actual progress\n  const { data: userProfile } = trpc.app.user.getProfile.useQuery(undefined, {\n    enabled: true,\n  });\n\n  const [currentLevelRank, setCurrentLevelRank] = useState(1);\n  const [displayProgress, setDisplayProgress] = useState(0);\n\n  const currentLevel = generateLevel(currentLevelRank);\n\n  // Update level rank when user profile loads\n  useEffect(() => {\n    if (userProfile) {\n      const userLevel = getLevelByScore(userProfile.score);\n      setCurrentLevelRank(userLevel.rank);\n    }\n  }, [userProfile]);\n\n  // Calculate actual progress percentage\n  const actualProgressPercentage =\n    userProfile && currentLevel\n      ? Math.max(\n          0,\n          Math.min(\n            100,\n            ((userProfile.score - currentLevel.min) /\n              (currentLevel.max - currentLevel.min)) *\n              100\n          )\n        )\n      : 0;\n\n  // Animate progress bar from 0 to actual percentage\n  useEffect(() => {\n    if (userProfile) {\n      // Small delay to ensure smooth animation\n      const timer = setTimeout(() => {\n        setDisplayProgress(actualProgressPercentage);\n      }, 100);\n      return () => clearTimeout(timer);\n    } else {\n      setDisplayProgress(0);\n    }\n  }, [userProfile, actualProgressPercentage]);\n\n  // Use the animated display progress\n  const progressPercentage = displayProgress;\n  const nextLevel = () => {\n    setCurrentLevelRank(currentLevelRank + 1);\n  };\n\n  const prevLevel = () => {\n    if (currentLevelRank > 1) {\n      setCurrentLevelRank(currentLevelRank - 1);\n    }\n  };\n\n  const overMinimum = (userProfile?.score ?? 0) >= currentLevel.min;\n  const overMaximum = (userProfile?.score ?? 0) >= currentLevel.max;\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col items-center justify-center p-6\">\n      <div className=\"flex flex-col items-start justify-start gap-6 w-full h-full p-6 bg-white pixel-shadow\">\n        {/* Header */}\n        <header className=\"flex flex-row items-start justify-between gap-2 w-full\">\n          <div className=\"flex flex-col items-start justify-start gap-2 flex-1\">\n            <Text color=\"var(--color-orangered)\">\n              {`Level ${currentLevel.rank}`}\n            </Text>\n            <Text scale={3}>{currentLevel.name}</Text>\n          </div>\n\n          <IconButton\n            symbol=\"X\"\n            onClick={onClose}\n            telemetryEvent=\"click_close_level_details\"\n          />\n        </header>\n\n        {/* XP Bar */}\n        <div className=\"flex flex-col items-start justify-start gap-2 w-full mb-6\">\n          {/* Progress Bar */}\n          <div className=\"flex w-full h-2 relative bg-black-20\">\n            <div\n              className=\"absolute left-0 top-0 h-full bg-orangered transition-all duration-300\"\n              style={{ width: `${progressPercentage}%` }}\n            />\n          </div>\n\n          {/* Labels */}\n          <div className=\"flex flex-row items-center justify-between w-full\">\n            <div className=\"flex flex-row items-center justify-start gap-3\">\n              <Text\n                className={overMinimum ? 'text-orangered' : 'text-black-40'}\n              >{`${abbreviateNumber(overMinimum ? (userProfile?.score ?? 0) : currentLevel.min)}`}</Text>\n              {overMinimum && !overMaximum && (\n                <Text\n                  className={overMinimum ? 'text-orangered' : 'text-black-40'}\n                >{`(${progressPercentage.toFixed(1)}%)`}</Text>\n              )}\n            </div>\n\n            <Text\n              className={overMaximum ? 'text-orangered' : 'text-black-40'}\n            >{`${abbreviateNumber(currentLevel.max)}`}</Text>\n          </div>\n        </div>\n\n        {/* Rewards */}\n        <Text scale={3}>Rewards:</Text>\n        <div className=\"flex flex-col items-start justify-start gap-3 flex-1 h-full\">\n          {getRewardsByLevel(currentLevel.rank).map((reward) => (\n            <RewardItem\n              key={reward}\n              reward={getRewardLabel(reward, currentLevel.rank)}\n              unlocked={overMinimum}\n            />\n          ))}\n        </div>\n\n        {/* Navigation */}\n        <nav className=\"flex items-center justify-between w-full\">\n          <IconButton\n            symbol=\"arrow-left\"\n            onClick={prevLevel}\n            disabled={currentLevelRank === 1}\n            telemetryEvent=\"click_level_prev\"\n          />\n          <IconButton\n            symbol=\"arrow-right\"\n            onClick={nextLevel}\n            disabled={false}\n            telemetryEvent=\"click_level_next\"\n          />\n        </nav>\n      </div>\n    </main>\n  );\n}\n\ninterface RewardItemProps {\n  reward: string;\n  unlocked: boolean;\n}\n\nfunction RewardItem(props: RewardItemProps) {\n  const { reward, unlocked } = props;\n  return (\n    <div className=\"flex flex-row items-center justify-start gap-3\">\n      <Icon\n        type={unlocked ? 'checkmark' : 'x'}\n        className={unlocked ? 'text-orangered' : 'text-black-20'}\n      />\n      <Text className={unlocked ? 'text-black' : 'text-black-50'}>\n        {reward}\n      </Text>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/Menu.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 28,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 28,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [900, 902], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/MyDrawings.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 11,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 11,
        "endColumn": 26,
        "fix": { "range": [451, 477], "text": "type MyDrawingsProps = " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 21,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 21,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [736, 738], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { Button } from '@components/Button';\nimport { trpc } from '@client/trpc/client';\nimport { Text } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\nimport { PaginatedDrawingGrid } from '@components/PaginatedDrawingGrid';\nimport { navigateTo } from '@devvit/web/client';\nimport { context } from '@devvit/web/client';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { useEffect } from 'react';\n\ninterface MyDrawingsProps {\n  onClose: () => void;\n}\n\nexport function MyDrawings({ onClose }: MyDrawingsProps) {\n  // Telemetry\n  const { track } = useTelemetry();\n  useEffect(() => {\n    void track('view_my_drawings');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Grab data\n  const { data: drawings = [], isLoading } = trpc.app.user.getDrawings.useQuery(\n    { limit: 20 }\n  );\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col p-4 gap-4\">\n      {/* Header */}\n      <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n        <Text scale={2.5}>My Drawings</Text>\n\n        <IconButton\n          onClick={onClose}\n          symbol=\"X\"\n          telemetryEvent=\"click_close_my_drawings\"\n        />\n      </header>\n\n      {/* Loading and Drawing Tiles */}\n      <PaginatedDrawingGrid\n        drawings={drawings}\n        onDrawingClick={async (postId) => {\n          // Track drawing tile click - await to ensure delivery before navigation\n          await track('click_drawing_tile');\n\n          // Navigate to drawing post\n          const subredditName = context.subredditName;\n          if (subredditName) {\n            navigateTo(\n              `https://reddit.com/r/${subredditName}/comments/${postId}`\n            );\n          }\n        }}\n        isLoading={isLoading}\n      />\n\n      {/* Empty state */}\n      {drawings.length === 0 && !isLoading && (\n        <div className=\"flex-1 flex flex-col gap-4 items-center justify-center\">\n          <Text className=\"text-muted\">No drawings yet.</Text>\n          <Button onClick={onClose} telemetryEvent=\"click_start_drawing\">\n            New Drawing\n          </Button>\n        </div>\n      )}\n    </main>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/_components/MyRewards.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 30,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 30,
        "endColumn": 25,
        "fix": { "range": [982, 1007], "text": "type MyRewardsProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 105,
        "column": 22,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 105,
        "endColumn": 50,
        "fix": { "range": [3258, 3278], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 106,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 106,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 106,
        "column": 11,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 106,
        "endColumn": 57,
        "fix": {
          "range": [3290, 3336],
          "text": "effect?.kind === 'extra_drawing_time'"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 116,
        "column": 29,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 116,
        "endColumn": 42,
        "fix": { "range": [3580, 3590], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 184,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 184,
        "endColumn": 52,
        "fix": { "range": [6193, 6214], "text": "{ setSelectedItemId(id); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 185,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 185,
        "endColumn": 69,
        "fix": {
          "range": [6245, 6284],
          "text": "{ activateMutation.mutate({ itemId: id }); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 193,
        "column": 55,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 193,
        "endColumn": 78,
        "fix": { "range": [6446, 6469], "text": "{ setSelectedItemId(null); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 206,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 206,
        "endColumn": 57,
        "fix": { "range": [6998, 7021], "text": "{ setSelectedItemId(null); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"draw_time_boost_30s_2h\" === \"draw_time_boost_30s_2h\"` is true.",
        "line": 227,
        "column": 7,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 227,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 242,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 242,
        "endColumn": 30,
        "fix": { "range": [7947, 7977], "text": "type ConsumableItemProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 271,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 271,
        "endColumn": 32,
        "fix": { "range": [8741, 8749], "text": "{ onView(); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 284,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 284,
        "endColumn": 31,
        "fix": { "range": [9077, 9084], "text": "{ onUse(); }" }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'track'. Either include it or remove the dependency array.",
        "line": 47,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 47,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [track]",
            "fix": { "range": [1452, 1454], "text": "[track]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 11,
    "source": "import { Text, Icon } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\nimport { Button } from '@components/Button';\nimport { Modal } from '@components/Modal';\nimport { Multiplier, Clock } from '@components/illustrations';\nimport { useTelemetry } from '@client/hooks/useTelemetry';\nimport { useEffect, useMemo, useState } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport { wrapTextByWidth } from '@client/components/PixelFont';\nimport { useToastHelpers } from '@components/ToastManager';\nimport {\n  getAllRewards,\n  hasReward,\n  getRewardLabel,\n  getRewardValue,\n} from '@shared/rewards';\nimport {\n  CONSUMABLES_CONFIG,\n  getConsumableConfig,\n  getEffectDescription,\n} from '@shared/consumables';\nimport { context } from '@devvit/web/client';\nimport type { ConsumableEffect, ConsumableId } from '@shared/consumables';\n\n/**\n * Props for the MyRewards component.\n * @param onClose - The function to call when the modal is closed.\n */\n\ninterface MyRewardsProps {\n  onClose: () => void;\n}\n\n/**\n * My Rewards component.\n * @param onClose - The function to call when the modal is closed.\n * @returns The rendered My Rewards component.\n */\n\nexport function MyRewards({ onClose }: MyRewardsProps) {\n  // Telemetry\n  const { track } = useTelemetry();\n  const { success } = useToastHelpers();\n  useEffect(() => {\n    void track('view_my_rewards');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Get user profile data\n  const { data: userProfile } = trpc.app.user.getProfile.useQuery();\n\n  const userLevel = userProfile?.level ?? 1;\n  const allRewards = getAllRewards();\n\n  // Filter to only show unlocked rewards and sort by level requirement\n  const unlockedRewards = allRewards\n    .filter((reward) => hasReward(userLevel, reward))\n    .sort((a, b) => {\n      const aLevel = getRewardMinLevel(a);\n      const bLevel = getRewardMinLevel(b);\n      return aLevel - bLevel;\n    });\n\n  // Inventory & Active Effects\n  const { data: inventory, refetch: refetchInventory } =\n    trpc.app.rewards.getInventory.useQuery(undefined, {\n      enabled: !!context.userId,\n      staleTime: 5000,\n    });\n  const { data: activeEffects, refetch: refetchEffects } =\n    trpc.app.rewards.getActiveEffects.useQuery(undefined, {\n      enabled: !!context.userId,\n      staleTime: 5000,\n    });\n  const activateMutation = trpc.app.rewards.activateConsumable.useMutation({\n    onSuccess: () => {\n      success('Used!');\n      void refetchInventory();\n      void refetchEffects();\n    },\n  });\n\n  const hasAnyActiveEffect = (activeEffects?.length ?? 0) > 0;\n\n  const [selectedItemId, setSelectedItemId] = useState<ConsumableId | null>(\n    null\n  );\n  const selectedConfig = useMemo(\n    () => (selectedItemId ? getConsumableConfig(selectedItemId) : null),\n    [selectedItemId]\n  );\n  const selectedDescription = useMemo(\n    () => (selectedConfig ? getEffectDescription(selectedConfig.effect) : ''),\n    [selectedConfig]\n  );\n  const descriptionLines = useMemo(\n    () => wrapTextByWidth(selectedDescription, 128),\n    [selectedDescription]\n  );\n\n  const activeExtraDrawingSeconds = useMemo(() => {\n    const list = activeEffects ?? [];\n    let total = 0;\n    for (const e of list) {\n      const effect = e.effect as ConsumableEffect;\n      if (effect && effect.kind === 'extra_drawing_time') {\n        total += effect.extraSeconds;\n      }\n    }\n    return total;\n  }, [activeEffects]);\n\n  const inventoryEntries = useMemo(() => {\n    const entries = Object.entries(inventory ?? {});\n    return entries\n      .filter(([, qty]) => (qty as number) > 0)\n      .sort((a, b) =>\n        CONSUMABLES_CONFIG[\n          a[0] as keyof typeof CONSUMABLES_CONFIG\n        ].label.localeCompare(\n          CONSUMABLES_CONFIG[b[0] as keyof typeof CONSUMABLES_CONFIG].label\n        )\n      );\n  }, [inventory]);\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col p-4 gap-4 overflow-visible\">\n      {/* Header */}\n      <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n        <Text scale={2.5}>My Rewards</Text>\n        <IconButton onClick={onClose} symbol=\"X\" />\n      </header>\n\n      {/* Rewards - single card listing unlocked items */}\n      <div className=\"p-4 bg-white pixel-shadow flex flex-col items-start justify-start gap-4\">\n        {unlockedRewards.length === 0 ? (\n          <Text className=\"text-muted\">No rewards unlocked yet</Text>\n        ) : (\n          unlockedRewards.map((reward) => {\n            let displayLabel: string;\n\n            if (reward === 'extra_drawing_time') {\n              const base = getRewardValue(userLevel, 'extra_drawing_time') ?? 0;\n              displayLabel = `+${base + activeExtraDrawingSeconds}s drawing time`;\n            } else if (reward === 'extra_word_time') {\n              const base = getRewardValue(userLevel, 'extra_word_time') ?? 0;\n              displayLabel = `+${base}s selection time`;\n            } else if (reward === 'level_flair') {\n              displayLabel = `Level ${userLevel} flair`;\n            } else {\n              displayLabel = getRewardLabel(reward, userLevel);\n            }\n\n            return (\n              <div key={reward} className=\"flex items-center gap-4\">\n                <Icon type=\"checkmark\" className=\"text-success\" />\n                <Text>{displayLabel}</Text>\n              </div>\n            );\n          })\n        )}\n      </div>\n\n      <div className=\"h-8 w-full flex flex-row items-center justify-start\">\n        <Text scale={2.5}>Inventory</Text>\n      </div>\n\n      {/* Consumables Inventory */}\n      <div className=\"flex flex-row items-start justify-start gap-4\">\n        {inventoryEntries.length === 0 ? (\n          <Text className=\"text-muted\">\n            You don't have any consumables yet.\n          </Text>\n        ) : (\n          inventoryEntries.map(([itemId, quantity]) => {\n            const id = itemId as ConsumableId;\n            const disabled =\n              activateMutation.isPending || hasAnyActiveEffect || quantity <= 0;\n            return (\n              <ConsumableItem\n                key={id}\n                itemId={id}\n                quantity={quantity}\n                onView={() => setSelectedItemId(id)}\n                onUse={() => activateMutation.mutate({ itemId: id })}\n                disabled={disabled}\n              />\n            );\n          })\n        )}\n      </div>\n\n      <Modal isOpen={!!selectedItemId} onClose={() => setSelectedItemId(null)}>\n        <div className=\"flex flex-col items-center justify-center gap-6\">\n          {selectedItemId && renderConsumableIllustration(selectedItemId, 48)}\n\n          <div className=\"flex flex-col items-center justify-center gap-2\">\n            <Text className=\"text-primary\">{selectedConfig?.label ?? ''}</Text>\n            {descriptionLines.map((line, i) => (\n              <Text key={i} className=\"text-tertiary\">\n                {line}\n              </Text>\n            ))}\n          </div>\n\n          <Button onClick={() => setSelectedItemId(null)}>Okay</Button>\n        </div>\n      </Modal>\n    </main>\n  );\n}\n\n/**\n * Render the consumable illustration for a given item ID.\n * @param id - The item ID.\n * @param size - The size of the illustration.\n * @returns The rendered illustration.\n */\n\nfunction renderConsumableIllustration(id: ConsumableId, size = 36) {\n  if (id === 'score_multiplier_2x_4h') {\n    return <Multiplier variant=\"double\" size={size} />;\n  }\n  if (id === 'score_multiplier_3x_30m') {\n    return <Multiplier variant=\"triple\" size={size} />;\n  }\n  if (id === 'draw_time_boost_30s_2h') {\n    return <Clock size={size} />;\n  }\n  return null;\n}\n\n/**\n * Props for the ConsumableItem component.\n * @param itemId - The item ID.\n * @param quantity - The quantity of the item.\n * @param disabled - Whether the item is disabled.\n * @param onUse - The function to call when the item is used.\n * @param onView - The function to call when the item is viewed.\n */\n\ninterface ConsumableItemProps {\n  itemId: ConsumableId;\n  quantity: number;\n  disabled: boolean;\n  onUse: () => void;\n  onView: () => void;\n}\n\n/**\n * Render a consumable item.\n * @param itemId - The item ID.\n * @param quantity - The quantity of the item.\n * @param disabled - Whether the item is disabled.\n * @param onUse - The function to call when the item is used.\n * @param onView - The function to call when the item is viewed.\n * @returns The rendered consumable item.\n */\n\nfunction ConsumableItem({\n  itemId,\n  quantity,\n  onView,\n  onUse,\n  disabled,\n}: ConsumableItemProps) {\n  return (\n    <div className=\"flex flex-col items-center gap-2\">\n      <div\n        className=\"flex h-24 w-24 items-center justify-center relative bg-white pixel-shadow cursor-pointer\"\n        onClick={() => onView()}\n      >\n        {renderConsumableIllustration(itemId)}\n        <Text scale={2} className=\"text-muted absolute bottom-2 left-2\">\n          {String(quantity)}\n        </Text>\n      </div>\n\n      <Button\n        variant=\"primary\"\n        size=\"small\"\n        className=\"w-full\"\n        disabled={disabled}\n        onClick={() => onUse()}\n      >\n        Use\n      </Button>\n    </div>\n  );\n}\n\n/**\n * Get the minimum level for a reward.\n * @param reward - The reward.\n * @returns The minimum level.\n */\n\nfunction getRewardMinLevel(reward: string): number {\n  const levelMap: Record<string, number> = {\n    extra_drawing_time: 2,\n    extra_word_time: 2,\n    add_remove_words: 3,\n    extended_colors_tier_1: 2,\n    extended_colors_tier_2: 3,\n    extended_colors_tier_3: 4,\n    extended_colors_tier_4: 5,\n    level_flair: 1,\n  };\n  return levelMap[reward] ?? 1;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/pinned-post/entry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nimport { Background } from '@components/Background';\nimport { PinnedPost } from './PinnedPost';\n\nimport { Providers } from '@components/Providers';\nimport { setupGlobalErrorHandlers } from '@utils/errors';\n\nsetupGlobalErrorHandlers();\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <Providers>\n      <Background />\n      <PinnedPost />\n    </Providers>\n  </React.StrictMode>\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/tournament-post/TournamentPost.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 25,
        "column": 37,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 25,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [1124, 1162],
              "text": "(tournamentData?.word ?? postData?.word)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 25,
        "column": 55,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 25,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1163, 1165], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 26,
        "column": 48,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 26,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [1194, 1234],
              "text": "(tournamentData?.postId ?? context.postId)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 26,
        "column": 51,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 26,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 82,
        "column": 59,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 82,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2780, 2782], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 84,
        "column": 36,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 84,
        "endColumn": 58,
        "fix": { "range": [2851, 2873], "text": "{ setViewMode('gallery'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 85,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 85,
        "endColumn": 56,
        "fix": { "range": [2909, 2930], "text": "{ setViewMode('trophy'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 97,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 97,
        "endColumn": 52,
        "fix": { "range": [3256, 3277], "text": "{ setViewMode('voting'); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 105,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 105,
        "endColumn": 52,
        "fix": { "range": [3520, 3541], "text": "{ setViewMode('voting'); }" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import { useState, useEffect } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport { DrawingEditor } from '@components/Editor/Editor';\nimport { VotingView } from './_components/VotingView';\nimport { GalleryView } from './_components/GalleryView';\nimport { TrophyView } from './_components/TrophyView';\nimport { useToastHelpers } from '@components/ToastManager';\nimport { Shimmer } from '@components/Shimmer';\nimport { getPostData } from '@client/utils/context';\nimport { context } from '@devvit/web/client';\nimport type { TournamentPostData } from '@shared/schema';\n\ntype ViewMode = 'voting' | 'gallery' | 'trophy';\n\nexport function TournamentPost() {\n  const [showEditor, setShowEditor] = useState(false);\n  const [viewMode, setViewMode] = useState<ViewMode>('voting');\n  const { success: showSuccessToast } = useToastHelpers();\n\n  // Still fetch from server for validation, but don't block rendering\n  const { data: tournamentData } = trpc.app.tournament.getTournament.useQuery();\n\n  // Get data from context immediately (no loading state)\n  const postData = getPostData<TournamentPostData>();\n  const word = tournamentData?.word || postData?.word || '';\n  const currentPostId = tournamentData?.postId || context.postId || '';\n\n  const { data: stats, refetch: refetchStats } =\n    trpc.app.tournament.getStats.useQuery(\n      { postId: currentPostId },\n      {\n        enabled: !!currentPostId,\n      }\n    );\n\n  // Prefetch user level (lightweight) so editor opens instantly\n  const utils = trpc.useUtils();\n  useEffect(() => {\n    void utils.app.user.getLevel.prefetch();\n    // Also prefetch full profile in background\n    void utils.app.user.getProfile.prefetch();\n  }, [utils]);\n\n  const handleDrawSomething = () => {\n    setShowEditor(true);\n  };\n\n  const handleCloseEditor = () => {\n    setShowEditor(false);\n  };\n\n  const handleEditorSuccess = async () => {\n    setShowEditor(false);\n    showSuccessToast('Submitted!', { duration: 3000 });\n    // Refetch stats to update submission count\n    await refetchStats();\n  };\n\n  // Drawing state\n  if (showEditor) {\n    return (\n      <DrawingEditor\n        onClose={handleCloseEditor}\n        onSuccess={handleEditorSuccess}\n        mode=\"tournament-comment\"\n        tournamentPostId={currentPostId}\n        tournamentWord={word}\n      />\n    );\n  }\n\n  // Show gallery/voting UI\n  return (\n    <>\n      {/* Voting view - preserve state when hidden */}\n      <div className={viewMode === 'voting' ? 'absolute inset-0' : 'hidden'}>\n        <div className=\"absolute flex flex-col gap-6 items-center justify-center h-full w-full p-6\">\n          <VotingView\n            postId={currentPostId}\n            stats={stats}\n            onDraw={handleDrawSomething}\n            hasEnoughSubmissions={(stats?.submissionCount || 0) >= 2}\n            word={word}\n            onToggleGallery={() => setViewMode('gallery')}\n            onToggleTrophy={() => setViewMode('trophy')}\n          />\n\n          {/* Timed shimmer overlay */}\n          <Shimmer />\n        </div>\n      </div>\n\n      {/* Gallery view - preserve state when hidden */}\n      <div className={viewMode === 'gallery' ? 'absolute inset-0' : 'hidden'}>\n        <GalleryView\n          postId={currentPostId}\n          onToggleView={() => setViewMode('voting')}\n        />\n      </div>\n\n      {/* Trophy view - preserve state when hidden */}\n      <div className={viewMode === 'trophy' ? 'absolute inset-0' : 'hidden'}>\n        <TrophyView\n          postId={currentPostId}\n          onToggleView={() => setViewMode('voting')}\n          onDraw={handleDrawSomething}\n        />\n      </div>\n    </>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/tournament-post/_components/GalleryView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 9,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 9,
        "endColumn": 27,
        "fix": { "range": [359, 386], "text": "type GalleryViewProps = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 53,
        "column": 9,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 53,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1535, 1537], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, the types have no overlap.",
        "line": 92,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "noOverlapBooleanExpression",
        "endLine": 92,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 93,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 93,
        "endColumn": 50,
        "fix": {
          "range": [2917, 2941],
          "text": "{ setSelectedDrawing(null); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { useState } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport { PaginatedDrawingGrid } from '@components/PaginatedDrawingGrid';\nimport { Text } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\nimport { Lightbox } from '@components/Lightbox';\nimport type { DrawingData } from '@shared/schema/drawing';\n\ninterface GalleryViewProps {\n  postId: string;\n  onToggleView: () => void;\n}\n\nexport function GalleryView({ postId, onToggleView }: GalleryViewProps) {\n  const [selectedDrawing, setSelectedDrawing] = useState<{\n    drawing: DrawingData;\n    author: string;\n    rating: number;\n    votes: number;\n    views: number;\n  } | null>(null);\n\n  const {\n    data: submissions,\n    isLoading,\n    error,\n  } = trpc.app.tournament.getSubmissionsWithDrawings.useQuery(\n    { postId },\n    { enabled: !!postId }\n  );\n\n  const incrementViews = trpc.app.tournament.incrementViews.useMutation();\n\n  const handleDrawingClick = (postId: string) => {\n    const submission = submissions?.find((sub) => sub.commentId === postId);\n    if (submission) {\n      setSelectedDrawing({\n        drawing: submission.drawing,\n        author: submission.username,\n        rating: submission.rating,\n        votes: submission.votes,\n        views: submission.views,\n      });\n      // Track view when opening lightbox\n      void incrementViews.mutateAsync({ commentId: postId });\n    }\n  };\n\n  const drawings =\n    submissions?.map((sub) => ({\n      postId: sub.commentId,\n      drawing: sub.drawing,\n    })) || [];\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col p-4 gap-4\">\n      {/* Header */}\n      <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n        <Text scale={2.5}>All drawings</Text>\n        <IconButton onClick={onToggleView} symbol=\"X\" />\n      </header>\n\n      {/* Error state */}\n      {error && (\n        <div className=\"flex items-center justify-center w-full\">\n          <Text className=\"text-red-500\">\n            {`Error: ${Array.isArray(error.message) ? error.message.join(', ') : error.message || 'Failed to load'}`}\n          </Text>\n        </div>\n      )}\n\n      {/* Gallery or empty state */}\n      {isLoading ? (\n        <div className=\"flex items-center justify-center w-full h-full\">\n          <Text className=\"text-tertiary\">Loading ...</Text>\n        </div>\n      ) : submissions && submissions.length > 0 && drawings.length > 0 ? (\n        <PaginatedDrawingGrid\n          drawings={drawings}\n          onDrawingClick={handleDrawingClick}\n          isLoading={isLoading}\n        />\n      ) : (\n        <div className=\"h-full flex flex-col gap-2 items-center justify-center w-full\">\n          <Text className=\"text-tertiary\">No drawings yet</Text>\n        </div>\n      )}\n\n      {/* Lightbox */}\n      {selectedDrawing && (\n        <Lightbox\n          isOpen={selectedDrawing !== null}\n          onClose={() => setSelectedDrawing(null)}\n          drawing={selectedDrawing.drawing}\n          author={selectedDrawing.author}\n        >\n          <div className=\"flex flex-col gap-2 items-center\">\n            <Text>\n              {`${selectedDrawing.views} views  ${selectedDrawing.votes} picks (${\n                selectedDrawing.views > 0\n                  ? Math.round(\n                      (selectedDrawing.votes / selectedDrawing.views) * 100\n                    )\n                  : 0\n              }%)`}\n            </Text>\n            <Text>{`${selectedDrawing.rating} rating`}</Text>\n          </div>\n        </Lightbox>\n      )}\n    </main>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/tournament-post/_components/TrophyView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 10,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 10,
        "endColumn": 26,
        "fix": { "range": [378, 404], "text": "type TrophyViewProps = " }
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 18,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 18,
        "endColumn": 29,
        "fix": { "range": [530, 559], "text": "type WinnerDisplayProps = " }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 107,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 107,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2844, 2846], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 166,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 166,
        "endColumn": 51,
        "fix": { "range": [5006, 5027], "text": "{ handleDrawingClick(0); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 175,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 175,
        "endColumn": 51,
        "fix": { "range": [5307, 5328], "text": "{ handleDrawingClick(1); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 184,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 184,
        "endColumn": 51,
        "fix": { "range": [5608, 5629], "text": "{ handleDrawingClick(2); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, the types have no overlap.",
        "line": 197,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "noOverlapBooleanExpression",
        "endLine": 197,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 198,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 198,
        "endColumn": 50,
        "fix": {
          "range": [5963, 5987],
          "text": "{ setSelectedDrawing(null); }"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 6,
    "source": "import { useState } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport { Drawing } from '@components/Drawing';\nimport { Text } from '@components/PixelFont';\nimport { IconButton } from '@components/IconButton';\nimport { Button } from '@components/Button';\nimport { Lightbox } from '@components/Lightbox';\nimport type { DrawingData } from '@shared/schema/drawing';\n\ninterface TrophyViewProps {\n  postId: string;\n  onToggleView: () => void;\n  onDraw: () => void;\n}\n\ntype TrophyPosition = 'gold' | 'silver' | 'bronze';\n\ninterface WinnerDisplayProps {\n  position: TrophyPosition;\n  artist: string;\n  rating: number;\n  drawing: DrawingData;\n  onClick: () => void;\n}\n\nfunction TrophyIcon({ position }: { position: TrophyPosition }) {\n  const colors = {\n    gold: '#F2C94C',\n    silver: '#C0C0C0',\n    bronze: '#CD7F32',\n  };\n\n  return (\n    <svg\n      width=\"36\"\n      height=\"36\"\n      viewBox=\"0 0 12 12\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path\n        d=\"M9 11H3V10H9V11ZM7 9H5V7H7V9ZM9 5H8V6H4V5H3V1H9V5ZM2 4H1V2H2V4ZM11 4H10V2H11V4Z\"\n        fill={colors[position]}\n      />\n      <path\n        d=\"M3 11H9V10H10V12H2V10H3V11ZM10 1H12V4H11V2H10V4H11V5H10V6H9V7H8V9H9V10H3V9H4V7H3V6H2V5H1V4H2V2H1V4H0V1H2V0H10V1ZM5 9H7V7H5V9ZM3 5H4V6H8V5H9V1H3V5Z\"\n        fill=\"black\"\n        fill-opacity=\"0.8\"\n      />\n      <path d=\"M5 3H4V1H5V3Z\" fill=\"white\" fill-opacity=\"0.5\" />\n      <path\n        d=\"M9 11H7V10H9V11ZM7 9H6V7H7V9ZM8 6H7V5H8V6ZM9 5H8V1H9V5ZM11 4H10V2H11V4Z\"\n        fill=\"black\"\n        fill-opacity=\"0.3\"\n      />\n    </svg>\n  );\n}\n\nfunction WinnerDisplay({\n  position,\n  artist,\n  rating,\n  drawing,\n  onClick,\n}: WinnerDisplayProps) {\n  return (\n    <div className=\"flex flex-row gap-4 items-center justify-center\">\n      <button\n        onClick={onClick}\n        className=\"cursor-pointer hover:opacity-80 transition-opacity\"\n      >\n        <Drawing data={drawing} size={96} />\n      </button>\n      <TrophyIcon position={position} />\n      <div className=\"flex flex-col gap-1 items-start\">\n        <Text scale={2.5} className=\"text-primary\">\n          {artist}\n        </Text>\n        <Text scale={2} className=\"text-tertiary\">\n          {`${Math.round(rating)} rating`}\n        </Text>\n      </div>\n    </div>\n  );\n}\n\nexport function TrophyView({ postId, onToggleView, onDraw }: TrophyViewProps) {\n  const [selectedDrawing, setSelectedDrawing] = useState<{\n    drawing: DrawingData;\n    author: string;\n    rating: number;\n    votes: number;\n    views: number;\n    commentId: string;\n  } | null>(null);\n\n  const {\n    data: submissions,\n    isLoading,\n    error,\n  } = trpc.app.tournament.getSubmissionsWithDrawings.useQuery({ postId });\n\n  const incrementViews = trpc.app.tournament.incrementViews.useMutation();\n\n  // Get top 3 submissions\n  const top3 = submissions?.slice(0, 3) || [];\n\n  const handleDrawingClick = (index: number) => {\n    const submission = top3[index];\n    if (submission) {\n      setSelectedDrawing({\n        drawing: submission.drawing,\n        author: submission.username,\n        rating: submission.rating,\n        votes: submission.votes,\n        views: submission.views,\n        commentId: submission.commentId,\n      });\n      // Track view when opening lightbox\n      void incrementViews.mutateAsync({ commentId: submission.commentId });\n    }\n  };\n\n  if (error) {\n    return (\n      <main className=\"absolute inset-0 flex flex-col p-4 gap-4\">\n        <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n          <Text scale={2.5}>In the lead</Text>\n          <IconButton onClick={onToggleView} symbol=\"X\" />\n        </header>\n        <div className=\"flex items-center justify-center w-full h-full\">\n          <Text className=\"text-red-500\">\n            {`Error: ${Array.isArray(error.message) ? error.message.join(', ') : error.message || 'Failed to load'}`}\n          </Text>\n        </div>\n      </main>\n    );\n  }\n\n  return (\n    <main className=\"absolute inset-0 flex flex-col p-4 gap-6 items-center justify-center\">\n      {/* Header */}\n      <header className=\"shrink-0 w-full flex flex-row items-center justify-between\">\n        <Text scale={2.5}>In the lead</Text>\n        <IconButton onClick={onToggleView} symbol=\"X\" />\n      </header>\n\n      {/* Loading state */}\n      {isLoading ? (\n        <div className=\"flex items-center justify-center w-full h-full\">\n          <Text className=\"text-tertiary\">Loading...</Text>\n        </div>\n      ) : top3.length === 0 ? (\n        <div className=\"flex items-center justify-center w-full h-full\">\n          <Text className=\"text-tertiary\">No winners yet</Text>\n        </div>\n      ) : (\n        <div className=\"flex flex-col gap-6 items-center justify-center w-full h-full flex-1\">\n          {top3.length >= 1 && top3[0] && (\n            <WinnerDisplay\n              position=\"gold\"\n              artist={top3[0].username}\n              rating={top3[0].rating}\n              drawing={top3[0].drawing}\n              onClick={() => handleDrawingClick(0)}\n            />\n          )}\n          {top3.length >= 2 && top3[1] && (\n            <WinnerDisplay\n              position=\"silver\"\n              artist={top3[1].username}\n              rating={top3[1].rating}\n              drawing={top3[1].drawing}\n              onClick={() => handleDrawingClick(1)}\n            />\n          )}\n          {top3.length >= 3 && top3[2] && (\n            <WinnerDisplay\n              position=\"bronze\"\n              artist={top3[2].username}\n              rating={top3[2].rating}\n              drawing={top3[2].drawing}\n              onClick={() => handleDrawingClick(2)}\n            />\n          )}\n        </div>\n      )}\n      {/* Draw button at the bottom */}\n      <Button onClick={onDraw} size=\"large\" className=\"w-min\">\n        DRAW THE WORD\n      </Button>\n\n      {/* Lightbox */}\n      {selectedDrawing && (\n        <Lightbox\n          isOpen={selectedDrawing !== null}\n          onClose={() => setSelectedDrawing(null)}\n          drawing={selectedDrawing.drawing}\n          author={selectedDrawing.author}\n        >\n          <div className=\"flex flex-col gap-2 items-center\">\n            <Text>\n              {`${selectedDrawing.views} views  ${selectedDrawing.votes} picks (${\n                selectedDrawing.views > 0\n                  ? Math.round(\n                      (selectedDrawing.votes / selectedDrawing.views) * 100\n                    )\n                  : 0\n              }%)`}\n            </Text>\n            <Text>{`${selectedDrawing.rating} rating`}</Text>\n          </div>\n        </Lightbox>\n      )}\n    </main>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/tournament-post/_components/VotingView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 12,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 12,
        "endColumn": 26,
        "fix": { "range": [551, 577], "text": "type VotingViewProps = " }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"entering\" === \"entering\"` is true.",
        "line": 66,
        "column": 9,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 66,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 162,
        "column": 30,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 162,
        "endColumn": 61,
        "fix": {
          "range": [4412, 4443],
          "text": "Array<ReturnType<typeof setTimeout>>"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 243,
        "column": 46,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 243,
        "endColumn": 69,
        "fix": { "range": [7127, 7150], "text": "{ setShowCollision(false); }" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 264,
        "column": 51,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 264,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [7775, 7777], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 292,
        "column": 48,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 292,
        "endColumn": 69,
        "fix": { "range": [8858, 8879], "text": "{ clearTimeout(timeout); }" }
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 395,
        "column": 15,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 398,
        "endColumn": 16,
        "fix": {
          "range": [12168, 12287],
          "text": "{ handleVote(\n                leftDrawing?.commentId || '',\n                rightDrawing?.commentId || ''\n              ); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 396,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 396,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [12219, 12221], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 397,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 397,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [12266, 12268], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 408,
        "column": 15,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 411,
        "endColumn": 16,
        "fix": {
          "range": [12560, 12679],
          "text": "{ handleVote(\n                rightDrawing?.commentId || '',\n                leftDrawing?.commentId || ''\n              ); }"
        }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 409,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 409,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [12612, 12614], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 410,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 410,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [12658, 12660], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'fetchInitialPairs'. Either include it or remove the dependency array.",
        "line": 272,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 272,
        "endColumn": 28,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [fetchInitialPairs, hasEnoughSubmissions]",
            "fix": {
              "range": [8002, 8024],
              "text": "[fetchInitialPairs, hasEnoughSubmissions]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 6,
    "source": "import { useState, useEffect, useRef, useCallback } from 'react';\nimport { trpc } from '@client/trpc/client';\nimport { Drawing } from '@components/Drawing';\nimport { Button } from '@components/Button';\nimport { Text } from '@components/PixelFont';\nimport { CyclingMessage } from '@components/CyclingMessage';\nimport { Collision } from '@components/Collision';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport { ActiveEffectsBadge } from '@components/ActiveEffectsBadge';\nimport { Drawings, Trophy } from '@components/illustrations';\n\ninterface VotingViewProps {\n  postId: string;\n  stats:\n    | {\n        submissionCount: number;\n        playerCount: number;\n      }\n    | undefined;\n  onDraw: () => void;\n  hasEnoughSubmissions: boolean;\n  word: string;\n  onToggleGallery: () => void;\n  onToggleTrophy: () => void;\n}\n\ntype AnimationState = 'idle' | 'highlighting' | 'exiting' | 'entering';\n\ntype PairDrawing = {\n  commentId: string;\n  drawing: DrawingData;\n  userId: string;\n  postId: string;\n};\n\ntype Pair = [PairDrawing, PairDrawing];\n\ntype DrawingCardProps = {\n  drawing: PairDrawing | undefined;\n  side: 'left' | 'right';\n  animationState: AnimationState;\n  winnerSide: 'left' | 'right' | null;\n  onVote: () => void;\n  isDisabled: boolean;\n};\n\nfunction DrawingCard({\n  drawing,\n  side,\n  animationState,\n  winnerSide,\n  onVote,\n  isDisabled,\n}: DrawingCardProps) {\n  // State machine states: idle -> highlighting -> exiting -> entering -> idle\n\n  // Determine card state based on state machine\n  const cardState = (() => {\n    if (animationState === 'idle') return 'idle';\n    if (animationState === 'highlighting') {\n      return winnerSide === side ? 'highlighting-winner' : 'highlighting-loser';\n    }\n    if (animationState === 'exiting') {\n      return winnerSide === side ? 'exiting-winner' : 'exiting-loser';\n    }\n    if (animationState === 'entering') return 'entering';\n    return 'idle';\n  })();\n\n  // Map state to animation classes\n  const getAnimationClasses = (state: string) => {\n    const classes: string[] = [];\n\n    // Side class\n    classes.push(`side-${side}`);\n\n    // State-specific classes\n    switch (state) {\n      case 'idle':\n        // No animations\n        break;\n\n      case 'highlighting-winner':\n        classes.push('is-highlighting', 'is-winner');\n        classes.push('tournaments-animate-winner-highlight');\n        break;\n\n      case 'highlighting-loser':\n        classes.push('is-highlighting', 'is-loser');\n        classes.push('tournaments-animate-loser-fadeout');\n        break;\n\n      case 'exiting-winner':\n        classes.push('is-sliding-out', 'is-winner-sliding-out');\n        classes.push(\n          side === 'left'\n            ? 'tournaments-animate-slide-out-left'\n            : 'tournaments-animate-slide-out-right'\n        );\n        break;\n\n      case 'exiting-loser':\n        classes.push('is-sliding-out', 'is-loser-sliding-out');\n        classes.push(\n          side === 'left'\n            ? 'tournaments-animate-slide-out-left-loser'\n            : 'tournaments-animate-slide-out-right-loser'\n        );\n        break;\n\n      case 'entering':\n        classes.push('is-sliding-in');\n        classes.push(\n          side === 'left'\n            ? 'tournaments-animate-slide-in-from-left'\n            : 'tournaments-animate-slide-in-from-right'\n        );\n        break;\n    }\n\n    return classes;\n  };\n\n  const classes = [\n    'flex flex-col gap-3 items-center',\n    ...getAnimationClasses(cardState),\n  ].join(' ');\n\n  return (\n    <div className={classes} style={{ willChange: 'transform' }}>\n      {drawing ? (\n        <Drawing data={drawing.drawing} size={136} />\n      ) : (\n        <div className=\"w-34 h-34 bg-white-25\" />\n      )}\n      <Button\n        onClick={onVote}\n        disabled={isDisabled}\n        className=\"w-full\"\n        variant=\"primary\"\n      >\n        PICK\n      </Button>\n    </div>\n  );\n}\n\nexport function VotingView({\n  postId,\n  stats,\n  onDraw,\n  hasEnoughSubmissions,\n  word,\n  onToggleGallery,\n  onToggleTrophy,\n}: VotingViewProps) {\n  const [animationState, setAnimationState] = useState<AnimationState>('idle');\n  const [winnerSide, setWinnerSide] = useState<'left' | 'right' | null>(null);\n  const [pairsQueue, setPairsQueue] = useState<Pair[]>([]);\n  const [currentPairIndex, setCurrentPairIndex] = useState(0);\n  const [showCollision, setShowCollision] = useState(false);\n  const timeoutRefs = useRef<ReturnType<typeof setTimeout>[]>([]);\n  const isPrefetching = useRef(false);\n  const trackedViews = useRef<Set<string>>(new Set());\n\n  const {\n    refetch: fetchPairs,\n    error: pairsError,\n    isFetching: isFetchingPairs,\n  } = trpc.app.tournament.getDrawingPairs.useQuery(\n    { postId, count: 5 },\n    {\n      enabled: false,\n    }\n  );\n\n  const submitVote = trpc.app.tournament.submitVote.useMutation();\n  const incrementViews = trpc.app.tournament.incrementViews.useMutation();\n\n  const formatStatsLine = (submissionCount: number, playerCount: number) => {\n    const drawingText = submissionCount === 1 ? 'drawing' : 'drawings';\n    const playerText = playerCount === 1 ? 'player' : 'players';\n    return `${submissionCount} ${drawingText} by ${playerCount} ${playerText}`;\n  };\n\n  const prefetchPairs = useCallback(async () => {\n    if (isPrefetching.current) return;\n    isPrefetching.current = true;\n\n    try {\n      const result = await fetchPairs();\n      if (result.data) {\n        setPairsQueue((prev) => [...prev, ...result.data]);\n      }\n    } catch (error) {\n      console.error('Failed to prefetch pairs:', error);\n    } finally {\n      isPrefetching.current = false;\n    }\n  }, [fetchPairs]);\n\n  // Handle transition from exit to entry animation\n  useEffect(() => {\n    if (animationState === 'exiting') {\n      // Wait for exit animation to complete (500ms), then start entry\n      const transitionTimeout = setTimeout(() => {\n        // Move to next pair\n        setCurrentPairIndex((prev) => {\n          const nextIndex = prev + 1;\n\n          // Refill queue if getting low\n          if (\n            nextIndex >= pairsQueue.length - 2 &&\n            hasEnoughSubmissions &&\n            !isPrefetching.current\n          ) {\n            void prefetchPairs();\n          }\n\n          return nextIndex;\n        });\n\n        // Start entering animation\n        setAnimationState('entering');\n\n        const enterTimeout = setTimeout(() => {\n          setAnimationState('idle');\n          setWinnerSide(null);\n        }, 500);\n        timeoutRefs.current.push(enterTimeout);\n      }, 500); // Wait for exit slide-out to complete\n      timeoutRefs.current.push(transitionTimeout);\n    }\n  }, [animationState, hasEnoughSubmissions, prefetchPairs, pairsQueue.length]);\n\n  // Trigger collision effect when entering the entering state\n  useEffect(() => {\n    if (animationState === 'entering') {\n      // Trigger collision effect mid-way when cards meet (250ms = midpoint of 500ms animation)\n      const collisionTimeout = setTimeout(() => {\n        setShowCollision(true);\n        // Auto-hide after 1.75 seconds total (0.25s delay + 1.5s collision = 1.75s)\n        const hideTimeout = setTimeout(() => setShowCollision(false), 1750);\n        timeoutRefs.current.push(hideTimeout);\n      }, 250);\n      timeoutRefs.current.push(collisionTimeout);\n    }\n  }, [animationState]);\n\n  const fetchInitialPairs = useCallback(async () => {\n    if (!hasEnoughSubmissions) return;\n    try {\n      const result = await fetchPairs();\n      if (result.data) {\n        setPairsQueue(result.data);\n      }\n    } catch (error) {\n      console.error('Failed to fetch pairs:', error);\n    }\n  }, [fetchPairs, hasEnoughSubmissions]);\n\n  // Get current pair from queue\n  const currentPair = pairsQueue[currentPairIndex];\n  const [leftDrawing, rightDrawing] = currentPair || [];\n\n  // Fetch initial pairs only when there are enough submissions\n  useEffect(() => {\n    if (hasEnoughSubmissions) {\n      void fetchInitialPairs();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [hasEnoughSubmissions]);\n\n  // Track views when drawings are displayed (only once per pair)\n  useEffect(() => {\n    if (leftDrawing && rightDrawing && animationState === 'idle') {\n      // Track views for both drawings when they're first displayed\n      if (!trackedViews.current.has(leftDrawing.commentId)) {\n        trackedViews.current.add(leftDrawing.commentId);\n        void incrementViews.mutateAsync({ commentId: leftDrawing.commentId });\n      }\n      if (!trackedViews.current.has(rightDrawing.commentId)) {\n        trackedViews.current.add(rightDrawing.commentId);\n        void incrementViews.mutateAsync({ commentId: rightDrawing.commentId });\n      }\n    }\n  }, [leftDrawing, rightDrawing, animationState, incrementViews]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      timeoutRefs.current.forEach((timeout) => clearTimeout(timeout));\n      timeoutRefs.current = [];\n    };\n  }, []);\n\n  const handleVote = (winnerId: string, loserId: string) => {\n    if (animationState !== 'idle' || !leftDrawing || !rightDrawing) return;\n\n    // Determine winner side\n    const isLeftWinner = leftDrawing.commentId === winnerId;\n    setWinnerSide(isLeftWinner ? 'left' : 'right');\n\n    // Stage 1: Highlight winner (300ms)\n    setAnimationState('highlighting');\n\n    const highlightTimeout = setTimeout(() => {\n      setAnimationState('exiting');\n    }, 300);\n    timeoutRefs.current.push(highlightTimeout);\n\n    // Submit vote after highlight starts (non-blocking)\n    void submitVote.mutateAsync({\n      postId,\n      winnerCommentId: winnerId,\n      loserCommentId: loserId,\n    });\n  };\n\n  // Don't show loading if we're animating - keep old content visible\n  const isLoading = animationState === 'idle' && !leftDrawing && !rightDrawing;\n\n  // Determine if buttons should be disabled\n  const isButtonDisabled =\n    submitVote.isPending ||\n    isLoading ||\n    animationState !== 'idle' ||\n    !hasEnoughSubmissions;\n\n  // Show error message if fetching pairs failed\n  if (pairsError) {\n    return (\n      <div className=\"absolute inset-0 flex flex-col items-center justify-center gap-8 w-full h-full\">\n        <div className=\"flex flex-col items-center justify-center gap-2\">\n          <Text scale={3}>Error</Text>\n          <Text className=\"text-secondary\">\n            {pairsError.message || 'Failed to load submissions'}\n          </Text>\n        </div>\n        <Button\n          size=\"large\"\n          onClick={() => void fetchPairs()}\n          disabled={isFetchingPairs}\n        >\n          Retry\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"absolute inset-0 flex flex-col items-center justify-center gap-10 w-full h-full\">\n      <ActiveEffectsBadge />\n      {/* Gallery toggle button */}\n      <div className=\"absolute flex flex-row gap-4 items-center top-4 right-4\">\n        {/* Drawing */}\n        <button\n          onClick={onToggleGallery}\n          className=\"w-8 h-8 flex items-center justify-center cursor-pointer transition-all duration-300 hover:scale-115 active:scale-90\"\n        >\n          <Drawings size={24} />\n        </button>\n\n        {/* Gold Trophy */}\n        <button\n          onClick={onToggleTrophy}\n          className=\"w-8 h-8 flex items-center justify-center cursor-pointer transition-all duration-300 hover:scale-115 active:scale-90\"\n        >\n          <Trophy size={24} variant=\"gold\" />\n        </button>\n      </div>\n\n      <div className=\"flex flex-col gap-2 items-center justify-center\">\n        <Text scale={3}>{word}</Text>\n        <CyclingMessage\n          messages={[\n            'Drawing tournament',\n            stats && hasEnoughSubmissions\n              ? formatStatsLine(stats.submissionCount, stats.playerCount)\n              : 'Waiting for entries',\n          ]}\n          className=\"text-secondary\"\n          intervalMs={2000}\n        />\n      </div>\n\n      {hasEnoughSubmissions && (\n        <div className=\"flex gap-6 items-center justify-center\">\n          <DrawingCard\n            drawing={leftDrawing}\n            side=\"left\"\n            animationState={animationState}\n            winnerSide={winnerSide}\n            onVote={() =>\n              handleVote(\n                leftDrawing?.commentId || '',\n                rightDrawing?.commentId || ''\n              )\n            }\n            isDisabled={isButtonDisabled}\n          />\n          <DrawingCard\n            drawing={rightDrawing}\n            side=\"right\"\n            animationState={animationState}\n            winnerSide={winnerSide}\n            onVote={() =>\n              handleVote(\n                rightDrawing?.commentId || '',\n                leftDrawing?.commentId || ''\n              )\n            }\n            isDisabled={isButtonDisabled}\n          />\n        </div>\n      )}\n\n      {/* Action bar */}\n      <div className=\"flex flex-col gap-3 items-center\">\n        {hasEnoughSubmissions && (\n          <Text scale={2} className=\"text-secondary\">\n            Pick the best, or ...\n          </Text>\n        )}\n        <Button onClick={onDraw} size=\"large\" variant=\"primary\">\n          ADD A DRAWING\n        </Button>\n      </div>\n\n      {/* Collision effect overlay */}\n      {showCollision && <Collision />}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/posts/tournament-post/entry.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nimport { Background } from '@components/Background';\nimport { TournamentPost } from './TournamentPost';\n\nimport { Providers } from '@components/Providers';\nimport { setupGlobalErrorHandlers } from '@utils/errors';\n\nsetupGlobalErrorHandlers();\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <Providers>\n      <Background />\n      <TournamentPost />\n    </Providers>\n  </React.StrictMode>\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/test-setup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-confusing-void-expression",
        "severity": 1,
        "message": "Returning a void expression from an arrow function shorthand is forbidden. Please add braces to the arrow function.",
        "line": 51,
        "column": 59,
        "nodeType": "CallExpression",
        "messageId": "invalidVoidExprArrow",
        "endLine": 51,
        "endColumn": 79,
        "fix": { "range": [1371, 1391], "text": "{ callback(new Blob()); }" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { afterEach, vi } from 'vitest';\nimport { cleanup } from '@testing-library/preact';\nimport '@testing-library/jest-dom';\n\n// Mock @devvit/web/client\nvi.mock('@devvit/web/client', () => ({\n  context: {\n    postId: 't3_test123',\n    postData: {},\n    subredditName: 'testsubreddit',\n    username: 'testuser',\n    userId: 'testuser123',\n  },\n}));\n\n// Mock canvas API for Canvas component tests\nObject.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n  value: vi.fn(() => ({\n    fillRect: vi.fn(),\n    clearRect: vi.fn(),\n    getImageData: vi.fn(() => ({ data: new Array(4) })),\n    putImageData: vi.fn(),\n    createImageData: vi.fn(() => ({ data: new Array(4) })),\n    setTransform: vi.fn(),\n    drawImage: vi.fn(),\n    save: vi.fn(),\n    fillText: vi.fn(),\n    restore: vi.fn(),\n    beginPath: vi.fn(),\n    moveTo: vi.fn(),\n    lineTo: vi.fn(),\n    closePath: vi.fn(),\n    stroke: vi.fn(),\n    translate: vi.fn(),\n    scale: vi.fn(),\n    rotate: vi.fn(),\n    arc: vi.fn(),\n    fill: vi.fn(),\n    measureText: vi.fn(() => ({ width: 0 })),\n    transform: vi.fn(),\n    rect: vi.fn(),\n    clip: vi.fn(),\n  })),\n});\n\nObject.defineProperty(HTMLCanvasElement.prototype, 'toDataURL', {\n  value: vi.fn(() => 'data:image/png;base64,test'),\n});\n\nObject.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n  value: vi.fn((callback: (blob: Blob | null) => void) => callback(new Blob())),\n});\n\n// Mock ResizeObserver\n(globalThis as { ResizeObserver: typeof ResizeObserver }).ResizeObserver = vi\n  .fn()\n  .mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n\n// Mock IntersectionObserver\n(\n  globalThis as { IntersectionObserver: typeof IntersectionObserver }\n).IntersectionObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n}));\n\n// Cleanup after each test\nafterEach(() => {\n  cleanup();\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/trpc/client.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/utils/context.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/utils/context.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
        "severity": 2,
        "message": "Type parameter T is used only once in the function signature.",
        "line": 9,
        "column": 29,
        "nodeType": "TSTypeParameter",
        "messageId": "sole",
        "endLine": 9,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "replaceUsagesWithConstraint",
            "fix": {
              "range": [332, 634],
              "text": "(): PostData | undefined {\n  const isIos = /iPad|iPhone|iPod/.test(navigator.userAgent);\n\n  if (isIos) {\n    // On iOS, the actual postData might be nested under developerData\n    return (context.postData?.developerData as PostData) ?? (context.postData as PostData);\n  }\n\n  return context.postData as PostData"
            },
            "desc": "Replace all usages of type parameter with its constraint."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 14,
        "column": 13,
        "nodeType": "TSAsExpression",
        "messageId": "neverNullish",
        "endLine": 14,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { context, type PostData } from '@devvit/web/client';\n\n/**\n * Gets post data from context, handling a known iOS-specific bug where the data\n * is nested under developerData property. Known to affect iOS version 2025.41.\n *\n * @returns The post data, properly extracted for the current platform\n */\nexport function getPostData<T extends PostData>(): T | undefined {\n  const isIos = /iPad|iPhone|iPod/.test(navigator.userAgent);\n\n  if (isIos) {\n    // On iOS, the actual postData might be nested under developerData\n    return (context.postData?.developerData as T) ?? (context.postData as T);\n  }\n\n  return context.postData as T;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/utils/errors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/client/vite.config.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-deprecated",
        "severity": 1,
        "message": "`name` is deprecated. Use \"names\" instead.",
        "line": 73,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "deprecatedWithReason",
        "endLine": 73,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { defineConfig } from 'vite';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport preact from '@preact/preset-vite';\nimport tailwindcss from '@tailwindcss/vite';\nimport tsconfigPaths from 'vite-tsconfig-paths';\n\nexport default defineConfig({\n  css: {\n    transformer: 'lightningcss',\n  },\n  resolve: {\n    alias: {\n      '@client': path.resolve(path.dirname(fileURLToPath(import.meta.url))),\n      '@components': path.resolve(\n        path.dirname(fileURLToPath(import.meta.url)),\n        'components'\n      ),\n      '@utils': path.resolve(\n        path.dirname(fileURLToPath(import.meta.url)),\n        'utils'\n      ),\n      '@hooks': path.resolve(\n        path.dirname(fileURLToPath(import.meta.url)),\n        'hooks'\n      ),\n      '@src': path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..'),\n      '@server': path.resolve(\n        path.dirname(fileURLToPath(import.meta.url)),\n        '../server'\n      ),\n      '@shared': path.resolve(\n        path.dirname(fileURLToPath(import.meta.url)),\n        '../shared'\n      ),\n    },\n  },\n  plugins: [tsconfigPaths(), preact(), tailwindcss()],\n  build: {\n    cssMinify: 'lightningcss',\n    outDir: '../../dist/client',\n    emptyOutDir: !process.env.ENTRY,\n    modulePreload: { polyfill: false },\n    cssCodeSplit: false,\n    rollupOptions: {\n      input: (() => {\n        const single = process.env.ENTRY;\n        if (single) {\n          // Allow building a single entry via ENTRY env var\n          return { [single]: `./${single}.html` };\n        }\n        return {\n          drawing: './drawing.html',\n          pinned: './pinned.html',\n          collection: './collection.html',\n          tournament: './tournament.html',\n        };\n      })(),\n      output: {\n        // Vendor: third-party deps only; app-shared: app modules used across entries\n        manualChunks(id) {\n          if (id.includes('node_modules')) return 'vendor';\n          const appSharedDirs = [\n            '/src/client/components/',\n            '/src/client/hooks/',\n            '/src/client/utils/',\n            '/src/shared/',\n          ];\n          if (appSharedDirs.some((p) => id.includes(p))) return 'shared';\n        },\n        // Ensure CSS doesn't inherit arbitrary shared chunk names like \"errors\"\n        assetFileNames(assetInfo) {\n          const ext = assetInfo.name?.split('.').pop();\n          if (ext === 'css') return 'assets/styles-[hash][extname]';\n          return 'assets/[name]-[hash][extname]';\n        },\n      },\n    },\n    minify: 'esbuild',\n  },\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/flair.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/flair.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-definitions",
        "severity": 1,
        "message": "Use a `type` instead of an `interface`.",
        "line": 27,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "typeOverInterface",
        "endLine": 27,
        "endColumn": 23,
        "fix": { "range": [840, 863], "text": "type DrawingStats = " }
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 35,
        "column": 12,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 35,
        "endColumn": 45,
        "fix": {
          "range": [1031, 1064],
          "text": "Array<{ word: string; count: number }>"
        }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import type { T2, T3 } from '@devvit/shared-types/tid.js';\nimport type { Level } from '@shared/types';\n\n// Configuration-driven approach\nconst FLAIR_CONFIG = {\n  user: {\n    format: (level: Level) => `Level ${level.rank} - ${level.name}`,\n    cssClass: (level: Level) => `level-${level.rank}`,\n  },\n  post: {\n    templates: [\n      { text: 'Unranked', difficulty: 'unranked', cssClass: 'unranked' },\n      { text: ' Easy', difficulty: 'easy', cssClass: 'easy' },\n      { text: ' Medium', difficulty: 'medium', cssClass: 'medium' },\n      { text: ' Hard', difficulty: 'hard', cssClass: 'hard' },\n      { text: ' Expert', difficulty: 'expert', cssClass: 'expert' },\n      {\n        text: ' Tournament',\n        difficulty: 'tournament',\n        cssClass: 'tournament',\n      },\n    ],\n  },\n} as const;\n\n// Type-safe stats interface\ninterface DrawingStats {\n  playerCount: number;\n  guessCount: number;\n  solves: number;\n  solvedPercentage: number;\n  skips: number;\n  skipPercentage: number;\n  wordCount: number;\n  guesses: { word: string; count: number }[];\n}\n\n/**\n * Ensure all required flair templates exist for the subreddit\n * Creates missing templates and updates existing ones, saves their IDs to Redis\n */\nexport async function initFlairTemplates(): Promise<void> {\n  const { context, reddit, redis } = await import('@devvit/web/server');\n  const { REDIS_KEYS } = await import('./redis');\n  const subredditName = context.subredditName;\n  try {\n    // Check if flair is enabled by trying to get templates\n    const [userTemplates, postTemplates] = await Promise.all([\n      reddit.getUserFlairTemplates(subredditName).catch(() => []),\n      reddit.getPostFlairTemplates(subredditName).catch(() => []),\n    ]);\n\n    // Check if user flair is enabled (for informational purposes)\n    if (userTemplates.length === 0) {\n      // User flair is not enabled - this is informational only\n    }\n\n    // Create or update post flair templates\n    await Promise.all(\n      FLAIR_CONFIG.post.templates.map(async (template) => {\n        const existing = postTemplates.find((t) => t.text === template.text);\n\n        let templateId: string;\n\n        if (existing) {\n          // Update existing template to ensure it matches current configuration\n          const updatedTemplate = await existing.edit({\n            text: template.text,\n            // Add other properties as needed for styling\n            backgroundColor: 'transparent',\n            textColor: 'dark',\n            allowableContent: 'all',\n            modOnly: false,\n            allowUserEdits: false,\n          });\n          templateId = updatedTemplate.id;\n        } else {\n          // Create new template\n          const newTemplate = await reddit.createPostFlairTemplate({\n            subredditName,\n            text: template.text,\n            backgroundColor: 'transparent',\n            textColor: 'dark',\n            allowableContent: 'all',\n            modOnly: false,\n            allowUserEdits: false,\n          });\n          templateId = newTemplate.id;\n        }\n\n        await redis.set(\n          REDIS_KEYS.flairTemplates.post(template.difficulty),\n          templateId\n        );\n      })\n    );\n\n    // Flair templates ensured\n  } catch (error) {\n    // Don't throw - flair setup should not block app installation\n  }\n}\n\n/**\n * Set user flair based on their level\n * Uses scheduler to run in app context for proper permissions\n */\nexport async function setUserFlair(\n  userId: T2,\n  subredditName: string,\n  level: Level\n): Promise<void> {\n  try {\n    // Schedule the flair setting job to run in app context\n    const { scheduler } = await import('@devvit/web/server');\n    await scheduler.runJob({\n      name: 'SET_USER_FLAIR',\n      data: {\n        userId,\n        subredditName,\n        level,\n      },\n      runAt: new Date(), // run immediately\n    });\n  } catch (error) {\n    // Don't throw - flair setting should not block other operations\n  }\n}\n\n/**\n * Set post flair based on difficulty\n */\nexport async function setPostFlair(\n  postId: T3,\n  subredditName: string,\n  difficulty: string\n): Promise<void> {\n  try {\n    const { reddit, redis } = await import('@devvit/web/server');\n    const { REDIS_KEYS } = await import('./redis');\n    const templateId = await redis.get(\n      REDIS_KEYS.flairTemplates.post(difficulty)\n    );\n    if (!templateId) {\n      return;\n    }\n\n    await reddit.setPostFlair({\n      postId,\n      subredditName,\n      flairTemplateId: templateId,\n    });\n\n    // Post flair set\n  } catch (error) {\n    // Don't throw - flair setting should not block other operations\n  }\n}\n\n/**\n * Get difficulty level from drawing stats\n */\nexport function getDifficultyFromStats(stats: DrawingStats): string {\n  // Return \"unranked\" for posts with insufficient data\n  if (stats.playerCount < 4) {\n    return 'unranked';\n  }\n\n  // Calculate solve rate percentage\n  const solveRate = stats.solvedPercentage;\n\n  // Determine difficulty based on solve rate\n  if (solveRate >= 80) return 'easy';\n  if (solveRate >= 50) return 'medium';\n  if (solveRate >= 25) return 'hard';\n  if (solveRate >= 10) return 'expert';\n  return 'expert'; // For solve rates below 10%\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/post.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/post.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/realtime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/redis.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 138,
        "column": 11,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 138,
        "endColumn": 31,
        "fix": { "range": [4805, 4825], "text": "user?.isAdmin" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { reddit, cache, redis } from '@devvit/web/server';\nimport type { T2, T3, T1 } from '@devvit/shared-types/tid.js';\n\n/**\n * Centralized Redis key management\n * Uses short prefixes for efficiency and consistency\n */\n\nexport const REDIS_KEYS = {\n  // Drawings\n  drawing: (postId: T3) => `drawing:${postId}`,\n  drawingGuesses: (postId: T3) => `drawing:guesses:${postId}`,\n  drawingAttempts: (postId: T3) => `drawing:attempts:${postId}`,\n  drawingSolves: (postId: T3) => `drawing:solves:${postId}`,\n  drawingSkips: (postId: T3) => `drawing:skips:${postId}`,\n  authorViews: (postId: T3) => `drawing:author_views:${postId}`,\n  allDrawings: () => 'drawings:all',\n\n  // Users\n  userName: (userId: T2) => `user:name:${userId}`,\n  userMod: (userId: T2) => `user:mod:${userId}`,\n  userAdmin: (userId: T2) => `user:admin:${userId}`,\n  userDrawings: (userId: T2) => `user:drawings:${userId}`,\n  userLevelUpClaim: (userId: T2) => `user:levelup:${userId}`,\n  userInventory: (userId: T2) => `user:inventory:${userId}`, // Hash of itemId -> count\n  userActiveBoosts: (userId: T2) => `user:active_boosts:${userId}`, // ZSET of activationId scored by expiresAt\n  boostActivation: (activationId: string) => `boost:${activationId}`, // Hash for activation metadata\n\n  // Words\n  wordsAll: (subredditName: string) => `words:all:${subredditName}`,\n  wordsBanned: (subredditName: string) => `words:banned:${subredditName}`,\n  wordsActive: (subredditName: string, timestamp: string) =>\n    `words:active:${subredditName}:${timestamp}`,\n  wordsHourlyStats: (subredditName: string, timestamp: string) =>\n    `words:hourly:${subredditName}:${timestamp}`,\n  wordsTotalStats: (subredditName: string) => `words:total:${subredditName}`,\n  wordsUncertainty: (subredditName: string) =>\n    `words:uncertainty:${subredditName}`,\n  wordsLastServed: (subredditName: string) =>\n    `words:lastServed:${subredditName}`,\n\n  // Word backing\n  wordBackingComment: (commentId: T1) => `word:backing:comment:${commentId}`,\n\n  // Word\n  wordBacking: (word: string) => `word:backing:${word}`,\n  wordDrawings: (word: string) => `word:drawings:${word}`,\n\n  // Communities\n  communities: () => 'communities',\n\n  // Legacy\n  legacyUsers: () => 'legacy:users',\n\n  // Comment\n  comment: (postId: T3) => `comment:${postId}`,\n  commentUpdateLock: (postId: T3) => `comment_update_lock:${postId}`,\n\n  // Progression system\n  scores: () => 'scores',\n\n  // Flair templates\n  flairTemplates: {\n    user: (levelRank: number) => `flair:user:${levelRank}`,\n    post: (difficulty: string) => `flair:post:${difficulty}`,\n  },\n\n  // Telemetry\n  telemetry: (date: string) => `telemetry:${date}`,\n\n  // Slates\n  slate: (slateId: string) => `slate:${slateId}`,\n  slateConfig: () => `slate:config`,\n\n  // Collections\n  collection: (collectionId: string) => `collection:${collectionId}`,\n\n  // Tournament\n  tournament: (postId: T3) => `tournament:${postId}`,\n  tournaments: () => `tournaments:all`,\n  tournamentsCounter: () => `tournaments:counter`,\n  tournamentEntries: (postId: T3) => `tournament:entries:${postId}`, // Sorted set with ratings as scores\n  tournamentEntry: (commentId: T1) => `tournament:entry:${commentId}`,\n  tournamentPlayers: (postId: T3) => `tournament:players:${postId}`,\n  tournamentHopper: (subredditName: string) =>\n    `tournament:hopper:${subredditName}`,\n  tournamentSchedulerLock: (subredditName: string) =>\n    `tournament:scheduler:lock:${subredditName}`,\n  tournamentSchedulerEnabled: (subredditName: string) =>\n    `tournament:scheduler:enabled:${subredditName}`,\n  tournamentEloLock: (postId: T3) => `tournament:elo_lock:${postId}`,\n  tournamentPayoutLedger: (postId: T3) => `tournament:payout:ledger:${postId}`,\n  tournamentPayoutLock: (postId: T3, dayIndex: number) =>\n    `tournament:payout:lock:${postId}:${dayIndex}`,\n  // Rate limit keys\n  rateGuess: (userId: T2) => `rate:guess:${userId}`,\n  rateVote: (userId: T2) => `rate:vote:${userId}`,\n  rateSubmit: (userId: T2) => `rate:submit:${userId}`,\n};\n\nconst MODERATOR_STATUS_TTL = 10 * 24 * 60 * 60; // 10 days.\nconst ADMIN_STATUS_TTL = 1 * 24 * 60 * 60; // 1 day.\n\nexport { getUsername } from './user';\n\n/**\n * Check if user is moderator with caching\n */\n\nexport async function isModerator(\n  userId: T2,\n  subredditName: string\n): Promise<boolean> {\n  return await cache(\n    async () => {\n      const moderators = await reddit\n        .getModerators({\n          subredditName,\n        })\n        .all();\n\n      return moderators.some((user) => user.id === userId);\n    },\n    {\n      key: REDIS_KEYS.userMod(userId),\n      ttl: MODERATOR_STATUS_TTL,\n    }\n  );\n}\n\n/**\n * Check if user is admin with caching\n */\nexport async function isAdmin(userId: T2): Promise<boolean> {\n  return await cache(\n    async () => {\n      const user = await reddit.getUserById(userId);\n      if (user && user.isAdmin) {\n        return true;\n      }\n      return false;\n    },\n    {\n      key: REDIS_KEYS.userAdmin(userId),\n      ttl: ADMIN_STATUS_TTL,\n    }\n  );\n}\n\n/**\n * Acquire a lightweight distributed lock using atomic SET NX EX semantics.\n * Returns true if the lock was acquired, false otherwise.\n */\nexport async function acquireLock(\n  key: string,\n  ttlSeconds: number\n): Promise<boolean> {\n  const result = await redis.set(\n    key as never,\n    '1' as never,\n    {\n      ex: ttlSeconds,\n      nx: true,\n    } as never\n  );\n  // Some clients return 'OK', others truthy\n  return Boolean(result);\n}\n\n/**\n * Best-effort lock release. Safe to call even if lock expired.\n */\nexport async function releaseLock(key: string): Promise<void> {\n  try {\n    await redis.del(key as never);\n  } catch {\n    // noop\n  }\n}\n\n/**\n * Simple sliding-window-ish rate limiter using INCR + EXPIRE.\n * Returns true if the caller exceeded the limit.\n */\nexport async function isRateLimited(\n  key: string,\n  limit: number,\n  ttlSeconds: number\n): Promise<boolean> {\n  const count = await redis.incrBy(key as never, 1 as never);\n  if (count === 1) {\n    await redis.expire(key as never, ttlSeconds);\n  }\n  return count > limit;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/core/user.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 44,
        "column": 11,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 44,
        "endColumn": 26,
        "fix": { "range": [1356, 1371], "text": "user?.id" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { reddit, cache } from '@devvit/web/server';\nimport type { T2 } from '@devvit/shared-types/tid.js';\nimport { REDIS_KEYS } from './redis';\n\nconst USERNAME_CACHE_TTL = 90 * 24 * 60 * 60; // 90 days\nconst RESOLVE_USERNAME_BATCH_SIZE = 50;\n\n/**\n * Get the username for a userId. Usernames are cached for 90 days. If there is no cached username, the username is fetched from Reddit and cached.\n */\n\nexport async function getUsername(userId: T2): Promise<string> {\n  return await cache(\n    async () => {\n      const user = await reddit.getUserById(userId);\n      if (!user) {\n        throw new Error('No user found for id: ' + userId);\n      }\n      return user.username;\n    },\n    {\n      key: REDIS_KEYS.userName(userId),\n      ttl: USERNAME_CACHE_TTL,\n    }\n  );\n}\n\n/**\n * Resolve a list of case-insensitive usernames to userIds. If a username is not found, it is not included in the result.\n */\n\nexport async function resolveUsernamesToIds(\n  usernames: string[]\n): Promise<T2[]> {\n  if (usernames.length === 0) return [];\n\n  const results: T2[] = [];\n  for (let i = 0; i < usernames.length; i += RESOLVE_USERNAME_BATCH_SIZE) {\n    const slice = usernames.slice(i, i + RESOLVE_USERNAME_BATCH_SIZE);\n    const users = await Promise.all(\n      slice.map(async (name) => reddit.getUserByUsername(name))\n    );\n    for (const user of users) {\n      if (user && user.id) {\n        results.push(user.id);\n      }\n    }\n  }\n\n  // Dedupe and return the results\n  return Array.from(new Set(results));\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/_schema.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/collection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/pinned.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/post-details-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 123,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 123,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3661, 3663], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 157,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 157,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getRandomWords } from '@server/services/words/dictionary';\nimport {\n  DEFAULT_COLLECTION_POST_LABEL,\n  DEFAULT_COLLECTION_POST_NUMBER_OF_DAYS,\n  DEFAULT_COLLECTION_POST_NUMBER_OF_DRAWINGS,\n  DEFAULT_COLLECTION_POST_TITLE,\n  DEFAULT_PINNED_POST_TITLE,\n  TOURNAMENT_FALLBACK_WORD,\n} from '@shared/constants';\n\n/**\n * Form handler for post type selection\n * Returns form configuration based on selected post type\n */\n\nexport async function showPostDetailsForm(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { postType } = req.body;\n\n    if (!postType) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Post type is required',\n      });\n      return;\n    }\n\n    // Handle both string and array inputs from form fields\n    const postTypeValue = Array.isArray(postType) ? postType[0] : postType;\n\n    // Show post-specific form based on selected type\n    let formName: string;\n    let formTitle: string;\n    let formDescription: string | undefined;\n    let formFields: Array<{\n      type: string;\n      name: string;\n      label: string;\n      placeholder?: string;\n      defaultValue?: string | string[];\n      required?: boolean;\n      options?: Array<{ label: string; value: string }>;\n      min?: number;\n      max?: number;\n      helpText?: string;\n      lineHeight?: number;\n    }> = [];\n\n    switch (postTypeValue) {\n      case 'pinned':\n        formName = 'pinnedPostForm';\n        formTitle = 'Pinned post';\n        formFields = [\n          {\n            type: 'string',\n            name: 'title',\n            label: 'Post title',\n            placeholder: 'Enter post title...',\n            defaultValue: DEFAULT_PINNED_POST_TITLE,\n            required: true,\n          },\n        ];\n        break;\n      case 'collection':\n        formName = 'collectionPostForm';\n        formTitle = 'Collection post';\n        formFields = [\n          {\n            type: 'paragraph',\n            name: 'postTitle',\n            label: 'Post title',\n            lineHeight: 2,\n            placeholder: 'Post title',\n            defaultValue: DEFAULT_COLLECTION_POST_TITLE,\n            required: true,\n          },\n          {\n            type: 'paragraph',\n            name: 'label',\n            label: 'Label',\n            lineHeight: 2,\n            placeholder: 'Shown above drawings',\n            defaultValue: DEFAULT_COLLECTION_POST_LABEL,\n            required: true,\n            helpText: 'Max 2 lines. No word wrapping.',\n          },\n          {\n            type: 'number',\n            name: 'numberOfDays',\n            label: 'Number of days',\n            defaultValue: DEFAULT_COLLECTION_POST_NUMBER_OF_DAYS.toString(),\n            min: 1,\n            max: 365,\n            required: true,\n          },\n          {\n            type: 'select',\n            name: 'numberOfDrawings',\n            label: 'Number of drawings',\n            defaultValue: [\n              DEFAULT_COLLECTION_POST_NUMBER_OF_DRAWINGS.toString(),\n            ],\n            options: [\n              { label: '3 drawings', value: '3' },\n              { label: '6 drawings', value: '6' },\n              { label: '9 drawings', value: '9' },\n            ],\n            required: true,\n          },\n        ];\n        break;\n      case 'tournament': {\n        formName = 'tournamentPostForm';\n        formTitle = 'Drawing tournament';\n        formDescription =\n          'Players compete to make the best drawing for a given word. You get to pick the word, or leave it blank for a random one.';\n\n        const candidateWords = await getRandomWords(1);\n        const word = candidateWords[0] || TOURNAMENT_FALLBACK_WORD;\n\n        formFields = [\n          {\n            type: 'string',\n            name: 'word',\n            label: 'Word',\n            placeholder: 'Using a random word',\n            defaultValue: word,\n            helpText: 'Case insensitive',\n          },\n        ];\n        break;\n      }\n      default:\n        res.status(400).json({\n          status: 'error',\n          message: 'Invalid post type',\n        });\n        return;\n    }\n\n    res.json({\n      showForm: {\n        name: formName,\n        form: {\n          title: formTitle,\n          ...(formDescription && { description: formDescription }),\n          fields: formFields,\n          acceptLabel: 'Create',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error showing post-specific form: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Failed to show post-specific form',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/post-select-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 38,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 38,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\n\n/**\n * Menu action handler for creating a Pixelary post\n * Shows a form for selecting post type\n */\n\nexport async function showPostSelectForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    res.json({\n      showForm: {\n        name: 'createPostForm',\n        form: {\n          title: 'Pixelary post types',\n          description: 'Select a post type to continue.',\n          fields: [\n            {\n              type: 'select',\n              name: 'postType',\n              label: 'Post type',\n              options: [\n                { label: 'Pinned Post', value: 'pinned' },\n                { label: 'Collection Post', value: 'collection' },\n                { label: 'Tournament Post', value: 'tournament' },\n              ],\n              defaultValue: ['tournament'],\n              required: true,\n            },\n          ],\n          acceptLabel: 'Continue',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error showing post creation form: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to show post creation form',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/create-post/tournament.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 10,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 10,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [312, 314], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 18,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 18,
        "endColumn": 59
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context } from '@devvit/web/server';\nimport { createTournament } from '@server/services/posts/tournament/post';\n\nexport async function handleCreateTournamentPost(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const word = req.body.word || undefined;\n    const postId = await createTournament(word);\n    const postUrl = `https://reddit.com/r/${context.subredditName}/comments/${postId}`;\n\n    res.json({\n      navigateTo: postUrl,\n    });\n  } catch (error) {\n    console.error(`Error creating tournament post: ${error}`);\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to create tournament post',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-banned-words/edit-banned-words-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 40,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 40,
        "endColumn": 55
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getBannedWords } from '@server/services/words/dictionary';\n\n/**\n * Menu action handler for showing a form to view and edit the banned words list\n */\n\nexport async function showEditBannedWordsForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { words: bannedWords } = await getBannedWords();\n\n    res.json({\n      showForm: {\n        name: 'editBannedWordsForm',\n        form: {\n          title: 'Edit banned words',\n          description:\n            'These words can not be added to the word list or appear in guess results.',\n          fields: [\n            {\n              type: 'paragraph',\n              name: 'words',\n              label: 'Banned words',\n              lineHeight: 8,\n              required: true,\n              defaultValue: bannedWords.join(', '),\n              placeholder: 'Apple, Banana, Apple Pie, ...',\n              helpText: 'Separate by commas. Case insensitive.',\n            },\n          ],\n          acceptLabel: 'Save',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading banned words: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load banned words',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-banned-words/edit-banned-words.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 41,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 41,
        "endColumn": 56
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { replaceBannedWords } from '@server/services/words/dictionary';\n\n/**\n * Form handler for banned words update\n * Updates the banned words list in Redis\n */\n\nexport async function handleEditBannedWords(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { words } = req.body;\n\n    if (!words) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Words are required',\n      });\n      return;\n    }\n\n    // Parse and clean words\n    const wordList = words\n      .split(',')\n      .map((word: string) => word.trim())\n      .filter((word: string) => word.length > 0)\n      .map(\n        (word: string) =>\n          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\n      )\n      .sort();\n\n    await replaceBannedWords(wordList);\n\n    res.json({\n      showToast: 'Updated!',\n    });\n  } catch (error) {\n    console.error(`Error updating banned words: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Failed to update',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-banned-words/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-legacy-users/edit-legacy-users-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 50,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 50,
        "endColumn": 60
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getLegacyUsersCount } from '@server/services/legacy';\n\n/**\n * Menu action handler to manage legacy users set\n */\n\nexport async function showEditLegacyUsersForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const count = await getLegacyUsersCount();\n\n    res.json({\n      showForm: {\n        name: 'editLegacyUsersForm',\n        form: {\n          title: 'Edit legacy users',\n          description: `Add or remove usernames from the legacy users set. There are ${count} legacy users in the set.`,\n          fields: [\n            {\n              type: 'select',\n              name: 'action',\n              label: 'Action',\n              options: [\n                { label: 'Add users', value: 'add' },\n                { label: 'Remove users', value: 'remove' },\n              ],\n              defaultValue: ['add'],\n              required: true,\n            },\n            {\n              type: 'paragraph',\n              name: 'usernames',\n              label: 'Usernames',\n              lineHeight: 8,\n              required: false,\n              defaultValue: '',\n              placeholder: 'username1, username2, username3',\n              helpText: 'Comma separated. Case insensitive.',\n            },\n          ],\n          acceptLabel: 'Submit',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading legacy users form: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load legacy users form',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-legacy-users/edit-legacy-users.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 20,
        "column": 31,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 20,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [606, 608], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"remove\" === \"remove\"` is true.",
        "line": 41,
        "column": 9,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 41,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 51,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 51,
        "endColumn": 56
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { parseForm, z } from '../_schema';\nimport { resolveUsernamesToIds } from '@server/core/user';\nimport { addLegacyUsers, removeLegacyUsers } from '@server/services/legacy';\n\nexport async function handleEditLegacyUsers(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { action, usernames } = parseForm(\n      z.object({\n        action: z.union([z.literal('add'), z.literal('remove')]),\n        usernames: z.string().optional(),\n      }),\n      req.body\n    );\n\n    // Parse and deduplicate usernames\n    const parsed = (usernames || '')\n      .split(',')\n      .map((x) => x.trim())\n      .filter(Boolean);\n    const deduped = Array.from(new Set(parsed));\n\n    // Resolve usernames to userIds\n    const userIds = await resolveUsernamesToIds(deduped);\n\n    // Handle add action\n    if (action === 'add') {\n      const added = await addLegacyUsers(userIds);\n      res.json({\n        showToast: {\n          text: `Added ${added} users`,\n        },\n      });\n      return;\n    }\n\n    // Handle remove action\n    if (action === 'remove') {\n      const removed = await removeLegacyUsers(userIds);\n      res.json({\n        showToast: {\n          text: `Removed ${removed} users`,\n        },\n      });\n      return;\n    }\n  } catch (error) {\n    console.error(`Error updating legacy users: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Failed to update',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-legacy-users/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-slate-bandit/edit-slate-bandit-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 83,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 83,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getSlateBanditConfig } from '@server/services/words/slate';\n\n/**\n * Menu action handler for slate bandit configuration\n * Shows a form for editing the slate bandit parameters\n */\n\nexport async function showEditSlateBanditForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const config = await getSlateBanditConfig();\n\n    res.json({\n      showForm: {\n        name: 'editSlateBanditForm',\n        form: {\n          title: 'Slate bandit',\n          description:\n            'Configure the non-personalized slate bandit optimizing the word selection',\n          fields: [\n            {\n              type: 'number',\n              name: 'explorationRate',\n              label: 'Exploration rate ()',\n              required: true,\n              defaultValue: config.explorationRate,\n              placeholder: '0.1',\n              helpText: 'Chance to explore (0-1)',\n            },\n            {\n              type: 'number',\n              name: 'zScoreClamp',\n              label: 'Z-score clamp',\n              required: true,\n              defaultValue: config.zScoreClamp,\n              placeholder: '3',\n              helpText: 'Maximum z-score before clamping',\n            },\n            {\n              type: 'number',\n              name: 'weightPickRate',\n              label: 'Pick rate weight',\n              required: true,\n              defaultValue: config.weightPickRate,\n              placeholder: '1',\n              helpText: 'Weight for pick rate in word score',\n            },\n            {\n              type: 'number',\n              name: 'weightPostRate',\n              label: 'Post rate weight',\n              required: true,\n              defaultValue: config.weightPostRate,\n              placeholder: '1',\n              helpText: 'Weight for post rate in word score',\n            },\n            {\n              type: 'number',\n              name: 'ucbConstant',\n              label: 'UCB constant',\n              required: true,\n              defaultValue: config.ucbConstant,\n              placeholder: '2',\n            },\n            {\n              type: 'number',\n              name: 'scoreDecayRate',\n              label: 'Score decay rate',\n              required: true,\n              defaultValue: config.scoreDecayRate,\n              placeholder: '0.1',\n            },\n          ],\n          acceptLabel: 'Save',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading slate bandit config: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to configuration',\n        appearance: 'neutral',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-slate-bandit/edit-slate-bandit.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 115,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 115,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { setSlateBanditConfig } from '@server/services/words/slate';\n\n/**\n * Form handler for slate bandit configuration update\n * Updates the slate bandit parameters in Redis\n */\nexport async function handleEditSlateBandit(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const {\n      explorationRate,\n      zScoreClamp,\n      weightPickRate,\n      weightPostRate,\n      ucbConstant,\n      scoreDecayRate,\n    } = req.body;\n\n    // Validate required fields\n    if (\n      explorationRate === undefined ||\n      zScoreClamp === undefined ||\n      weightPickRate === undefined ||\n      weightPostRate === undefined ||\n      ucbConstant === undefined ||\n      scoreDecayRate === undefined\n    ) {\n      res.status(400).json({\n        status: 'error',\n        message: 'All fields are required',\n      });\n      return;\n    }\n\n    // Validate numeric values\n    const explorationRateNum = parseFloat(explorationRate);\n    const zScoreClampNum = parseFloat(zScoreClamp);\n    const weightPickRateNum = parseFloat(weightPickRate);\n    const weightPostRateNum = parseFloat(weightPostRate);\n    const ucbConstantNum = parseFloat(ucbConstant);\n    const scoreDecayRateNum = parseFloat(scoreDecayRate);\n    if (\n      isNaN(explorationRateNum) ||\n      isNaN(zScoreClampNum) ||\n      isNaN(weightPickRateNum) ||\n      isNaN(weightPostRateNum) ||\n      isNaN(ucbConstantNum) ||\n      isNaN(scoreDecayRateNum)\n    ) {\n      res.status(400).json({\n        status: 'error',\n        message: 'All values must be valid numbers',\n      });\n      return;\n    }\n\n    // Validate ranges\n    if (explorationRateNum < 0 || explorationRateNum > 1) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Exploration rate must be between 0 and 1',\n      });\n      return;\n    }\n\n    if (zScoreClampNum <= 0) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Z-score clamp must be positive',\n      });\n      return;\n    }\n\n    if (weightPickRateNum < 0 || weightPostRateNum < 0) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Weights must be non-negative',\n      });\n      return;\n    }\n\n    if (ucbConstantNum <= 0) {\n      res.status(400).json({\n        status: 'error',\n        message: 'UCB constant must be positive',\n      });\n      return;\n    }\n\n    if (scoreDecayRateNum < 0 || scoreDecayRateNum > 1) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Score decay rate must be between 0 and 1',\n      });\n      return;\n    }\n\n    // Save configuration\n    await setSlateBanditConfig({\n      explorationRate: explorationRateNum,\n      zScoreClamp: zScoreClampNum,\n      weightPickRate: weightPickRateNum,\n      weightPostRate: weightPostRateNum,\n      ucbConstant: ucbConstantNum,\n      scoreDecayRate: scoreDecayRateNum,\n    });\n\n    res.json({\n      showToast: 'Updated!',\n    });\n  } catch (error) {\n    console.error(`Error updating slate bandit config: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Failed to update configuration',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-slate-bandit/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-words/edit-words-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 40,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 40,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getWords } from '@server/services/words/dictionary';\nimport { context } from '@devvit/web/server';\n\n/**\n * Menu action handler for showing a form to view and edit the word list\n */\n\nexport async function showEditWordsForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { words } = await getWords();\n    res.json({\n      showForm: {\n        name: 'editWordsForm',\n        form: {\n          title: 'Edit word list',\n          description: `This is the Pixelary community dictionary for ${context.subredditName}. It controls what players see when they draw.`,\n          fields: [\n            {\n              type: 'paragraph',\n              name: 'words',\n              label: 'Words',\n              lineHeight: 8,\n              required: true,\n              defaultValue: words.join(', '),\n              placeholder: 'Apple, Banana, Meat Loaf, ...',\n              helpText:\n                'Separate by commas. Case insensitive. Max 12 characters.',\n            },\n          ],\n          acceptLabel: 'Save',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading words: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load words',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-words/edit-words.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 37,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 37,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { updateWordsPreservingScores } from '../../services/words/dictionary';\n\n/**\n * Form handler for editing words\n * Replaces the community word list with new words from the text list\n */\nexport async function handleEditWords(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { words } = req.body;\n\n    if (!words) {\n      res.status(400).json({\n        status: 'error',\n        message: 'Words are required',\n      });\n      return;\n    }\n\n    // Parse and clean words from comma-separated text\n    const wordList = words\n      .split(',')\n      .map((word: string) => word.trim())\n      .filter(Boolean);\n    await updateWordsPreservingScores(wordList);\n\n    res.json({\n      showToast: {\n        text: 'Words updated successfully!',\n        appearance: 'success',\n      },\n    });\n  } catch (error) {\n    console.error(`Error updating words: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Failed to update words',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/edit-words/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/reveal-word.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 36,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 36,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context } from '@devvit/web/server';\nimport { getDrawing } from '../services/posts/drawing';\n\n/**\n * Menu action handler for revealing the word for a drawing post\n */\n\nexport async function handleRevealWord(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const postId = context.postId;\n\n    if (!postId) {\n      res.status(400).json({\n        showToast: 'Post ID is required',\n      });\n      return;\n    }\n\n    const drawing = await getDrawing(postId);\n\n    if (!drawing) {\n      res.json({\n        showToast: 'Not a drawing post',\n      });\n      return;\n    }\n\n    res.json({\n      showToast: drawing.word,\n    });\n  } catch (error) {\n    console.error(`Error revealing word: ${error}`);\n    res.status(500).json({\n      showToast: 'Failed to reveal word',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/telemetry-clear.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 20,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 20,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getTelemetryDateKey, clearTelemetryData } from '../services/telemetry';\n\n/**\n * Menu action handler for clearing telemetry data\n * Deletes the Redis hash containing today's telemetry data\n */\n\nexport async function handleTelemetryClear(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const today = getTelemetryDateKey();\n    await clearTelemetryData(today);\n    res.json({\n      showToast: 'Cleared',\n    });\n  } catch (error) {\n    console.error(`Error clearing telemetry: ${error}`);\n    res.status(400).json({\n      showToast: 'Failed to clear telemetry',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/telemetry-log.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 21,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 21,
        "endColumn": 52
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getTelemetryDateKey } from '../services/telemetry';\nimport { REDIS_KEYS } from '../core/redis';\nimport { redis } from '@devvit/web/server';\n\n/**\n * Menu action handler for logging telemetry data\n * Logs the Redis key contents for today's telemetry data\n */\n\nexport async function handleTelemetryLog(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const today = getTelemetryDateKey();\n    const telemetryKey = REDIS_KEYS.telemetry(today);\n    await redis.hGetAll(telemetryKey);\n    res.json({ showToast: 'Done. See server logs' });\n  } catch (error) {\n    console.error(`Error logging telemetry: ${error}`);\n    res.status(400).json({\n      showToast: 'Failed to log telemetry',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/tournament-hopper/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/tournament-hopper/tournament-hopper-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 53,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 53,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { redis, context } from '@devvit/web/server';\nimport { getHopperPrompts } from '@server/services/posts/tournament/hopper';\nimport { REDIS_KEYS } from '@server/core/redis';\n\n/**\n * Menu action handler to view and edit the tournament prompt hopper\n */\n\nexport async function showTournamentHopperForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { prompts } = await getHopperPrompts(0, 10000);\n    const subName = context.subredditName;\n    const enabledStr = await redis.get(\n      REDIS_KEYS.tournamentSchedulerEnabled(subName)\n    );\n    const enabled = enabledStr === '1' || enabledStr === 'true';\n\n    res.json({\n      showForm: {\n        name: 'tournamentHopperForm',\n        form: {\n          title: 'Tournament hopper',\n          description:\n            'Queued tournament prompts. Keep the prompts short and sweet. No more than 12 characters.',\n          fields: [\n            {\n              type: 'boolean',\n              name: 'enabled',\n              label: 'Auto-post daily',\n              defaultValue: enabled,\n            },\n            {\n              type: 'paragraph',\n              name: 'prompts',\n              label: 'Drawing prompts',\n              lineHeight: 8,\n              required: false,\n              defaultValue: prompts.join(', '),\n              placeholder: 'Meatloaf, Cat Pants, Bird with Arms, ...',\n              helpText: 'Separate by commas. Case insensitive.',\n            },\n          ],\n          acceptLabel: 'Save',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading tournament prompts: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load tournament prompts',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/tournament-hopper/tournament-hopper.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 24,
        "column": 27,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 24,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [670, 672], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 45,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 45,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context, redis } from '@devvit/web/server';\nimport { replaceHopperPrompts } from '@server/services/posts/tournament/hopper';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport { parseForm, z } from '../_schema';\n\n/**\n * Form handler to update the tournament prompt hopper\n */\n\nexport async function handleTournamentHopper(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { prompts, enabled } = parseForm(\n      z.object({\n        prompts: z.string().optional(),\n        enabled: z.union([z.string(), z.boolean()]).optional(),\n      }),\n      req.body\n    );\n\n    const list = (prompts || '')\n      .split(/[\\n,]/)\n      .map((x) => x.trim())\n      .filter(Boolean);\n\n    await replaceHopperPrompts(list);\n\n    const subName = context.subredditName;\n    const isEnabled = enabled === true || enabled === 'true' || enabled === '1';\n    await redis.set(\n      REDIS_KEYS.tournamentSchedulerEnabled(subName),\n      isEnabled ? '1' : '0'\n    );\n\n    res.json({\n      showToast: {\n        text: 'Updated!',\n        appearance: 'success',\n      },\n    });\n  } catch (error) {\n    console.error(`Error updating tournament prompts: ${error}`);\n    res.status(400).json({\n      status: 'error',\n      message: 'Something went wrong',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/tournament-payout-now.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/tournament-payout-now.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
        "severity": 1,
        "message": "Passing a string to String() does not change the type or value of the string.",
        "line": 24,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unnecessaryTypeConversion",
        "endLine": 24,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "suggestRemove",
            "fix": { "range": [839, 856], "text": "rawPostId" },
            "desc": "Remove the type conversion."
          },
          {
            "messageId": "suggestSatisfies",
            "data": { "type": "string" },
            "fix": {
              "range": [839, 856],
              "text": "(rawPostId satisfies string)"
            },
            "desc": "Instead, assert that the value satisfies the string type."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
        "severity": 1,
        "message": "Passing a string to String() does not change the type or value of the string.",
        "line": 25,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unnecessaryTypeConversion",
        "endLine": 25,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemove",
            "fix": { "range": [885, 902], "text": "rawPostId" },
            "desc": "Remove the type conversion."
          },
          {
            "messageId": "suggestSatisfies",
            "data": { "type": "string" },
            "fix": {
              "range": [885, 902],
              "text": "(rawPostId satisfies string)"
            },
            "desc": "Instead, assert that the value satisfies the string type."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context, redis } from '@devvit/web/server';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { getTournament } from '@server/services/posts/tournament/post';\nimport { awardTournamentRewards } from '@server/services/posts/tournament/award';\n// no direct comment posting here; handled in award service when notify=true\nimport { REDIS_KEYS } from '@server/core/redis';\n\n/**\n * Menu action: Manually trigger a one-off tournament payout.\n * No-op (with toast) if not a tournament post.\n */\nexport async function handleRunTournamentPayout(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const rawPostId = context.postId;\n    if (!rawPostId) {\n      res.status(400).json({ showToast: 'Post ID is required' });\n      return;\n    }\n    const postId = (\n      String(rawPostId).startsWith('t3_')\n        ? String(rawPostId)\n        : `t3_${rawPostId}`\n    ) as T3;\n\n    // Check post type by reading tournament metadata (best-effort)\n    let isTournament = false;\n    try {\n      const info = await getTournament(postId);\n      isTournament = info.type === 'tournament';\n    } catch {\n      // ignore\n    }\n\n    // Fallback: treat as tournament if there are any tournament entries\n    if (!isTournament) {\n      try {\n        const count = await redis.zCard(REDIS_KEYS.tournamentEntries(postId));\n        if (count > 0) {\n          isTournament = true;\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    if (!isTournament) {\n      res.json({ showToast: 'Not a tournament post' });\n      return;\n    }\n\n    await awardTournamentRewards(postId, { manual: true });\n\n    res.json({ showToast: 'Payout complete' });\n  } catch (error) {\n    console.error('Manual tournament payout failed:', error);\n    res.status(500).json({ showToast: 'Failed to run payout' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/update-pinned-comment/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/update-pinned-comment/update-pinned-comment.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/update-pinned-comment/update-pinned-comment.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 85,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 85,
        "endColumn": 51
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { context } from '@devvit/web/server';\nimport type { Request, Response } from 'express';\nimport {\n  saveLastCommentUpdate,\n  clearNextScheduledJobId,\n} from '@server/services/posts/drawing';\nimport { getPinnedCommentId } from '@server/services/comments/pinned';\nimport { updatePinnedPostComment } from '@server/services/posts/pinned';\nimport { updatePinnedComment } from '@server/services/comments/pinned';\nimport { getTournament } from '@server/services/posts/tournament/post';\nimport { generateTournamentCommentText } from '@server/services/posts/tournament/comments';\nimport {\n  generateDrawingCommentText,\n  getDrawingCommentData,\n} from '@server/services/posts/drawing';\nimport type { PostType } from '@shared/schema/index';\n\n/**\n * Menu action handler for updating the pinned comment for a drawing post or pinned post\n */\n\nexport async function handleUpdatePinnedComment(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const postId = context.postId;\n\n    if (!postId) {\n      res.status(400).json({\n        showToast: 'postId is missing',\n      });\n      return;\n    }\n\n    // Get the pinned comment ID for this post\n    const pinnedCommentId = await getPinnedCommentId(postId);\n    if (!pinnedCommentId) {\n      res.json({\n        showToast: 'No comment found',\n      });\n      return;\n    }\n\n    // Determine post type from UI request\n    const postType = (req.body?.postType as PostType | undefined) ?? undefined;\n    if (!postType) {\n      res.status(400).json({\n        showToast: 'postType is missing',\n      });\n      return;\n    }\n\n    if (postType === 'pinned') {\n      // For pinned posts, use the dedicated update method (static text)\n      await updatePinnedPostComment(postId);\n    } else {\n      // For drawing/tournament, build text directly\n      if (postType === 'drawing') {\n        const stats = await getDrawingCommentData(postId);\n        const text = generateDrawingCommentText(stats);\n        await updatePinnedComment(postId, text);\n      } else if (postType === 'tournament') {\n        const data = await getTournament(postId);\n        const text = await generateTournamentCommentText(data.word);\n        await updatePinnedComment(postId, text);\n      } else {\n        res.json({ showToast: 'Unsupported post type' });\n        return;\n      }\n    }\n\n    // Update timestamp and clear any scheduled jobs (only for drawing posts)\n    if (postType === 'drawing') {\n      await Promise.all([\n        saveLastCommentUpdate(postId, Date.now()),\n        clearNextScheduledJobId(postId),\n      ]);\n    }\n\n    res.json({\n      showToast: 'Updated!',\n    });\n  } catch (error) {\n    console.error(`Error updating comment: ${error}`);\n    res.status(500).json({\n      showToast: 'Failed to update',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/update-user-flair.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 32,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 32,
        "endColumn": 67
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context } from '@devvit/web/server';\nimport { getLevelByScore, getScore } from '../services/progression';\nimport { setUserFlair } from '../core/flair';\n\n/**\n * Menu action handler for updating user flair. Enables users to manually trigger a flair update\n */\n\nexport async function handleUpdateUserFlair(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { userId, subredditName } = context;\n    if (!userId) {\n      res.status(400).json({\n        showToast: 'No userId found',\n        appearance: 'neutral',\n      });\n      return;\n    }\n    const score = await getScore(userId);\n    const level = getLevelByScore(score);\n    await setUserFlair(userId, subredditName, level);\n\n    res.json({\n      showToast: 'Flair updated',\n      appearance: 'success',\n    });\n  } catch (error) {\n    console.error(`Error in update user flair menu action: ${error}`);\n    res.status(500).json({\n      showToast: 'Error. Try later.',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-get/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-get/user-points-get-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 23,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 23,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 50,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 50,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context } from '@devvit/web/server';\nimport { getUsername } from '@server/core/user';\n\n/**\n * Menu action handler for getting user points\n * Shows a form for entering username\n */\n\nexport async function showGetUserPointsForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Get current username\n    const { userId } = context;\n    let defaultUsername = '';\n\n    if (userId) {\n      try {\n        defaultUsername = await getUsername(userId);\n      } catch (error) {\n        console.error(`Error getting username: ${error}`);\n      }\n    }\n\n    res.json({\n      showForm: {\n        name: 'getUserPointsForm',\n        form: {\n          title: 'User points',\n          description: \"View a user's points\",\n          fields: [\n            {\n              type: 'string',\n              name: 'username',\n              label: 'Username',\n              placeholder: 'Enter a username',\n              required: true,\n              helpText: 'No u/ prefix',\n              defaultValue: defaultUsername,\n            },\n          ],\n          acceptLabel: 'Get Points',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading get user points form: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load form',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-get/user-points-get.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 35,
        "column": 20,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 35,
        "endColumn": 33,
        "fix": { "range": [825, 831], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 47,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 47,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import type { Request, Response } from 'express';\nimport { reddit } from '@devvit/web/server';\nimport { getScore } from '@server/services/progression';\nimport { getUsername } from '@server/core/user';\nimport type { T2 } from '@devvit/shared-types/tid.js';\n\n/**\n * Form handler for getting user points\n * Returns a toast with user's points\n */\n\nexport async function handleGetUserPoints(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { username } = req.body;\n\n    if (!username) {\n      res.status(400).json({\n        showToast: 'Username is required',\n      });\n      return;\n    }\n\n    // Look up user\n    const user = await reddit.getUserByUsername(username);\n    if (!user) {\n      res.status(400).json({\n        showToast: `User not found`,\n      });\n      return;\n    }\n\n    const userId = user.id as T2;\n\n    // Fetch user data\n    const [score, actualUsername] = await Promise.all([\n      getScore(userId),\n      getUsername(userId),\n    ]);\n\n    res.json({\n      showToast: `u/${actualUsername} has ${score} points`,\n    });\n  } catch (error) {\n    console.error(`Error getting user points: ${error}`);\n    res.status(500).json({\n      showToast: 'Failed to get points',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-set/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-set/user-points-set-form.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 28,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 28,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 64,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 64,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { context } from '@devvit/web/server';\nimport { getScore } from '@server/services/progression';\nimport { getUsername } from '@server/core/user';\n\n/**\n * Menu action handler for setting user points\n * Shows a form for entering username and points\n */\n\nexport async function showSetUserPointsForm(\n  _req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Get current user info\n    const { userId } = context;\n    let defaultUsername = '';\n    let defaultPoints = 0;\n\n    if (userId) {\n      try {\n        [defaultUsername, defaultPoints] = await Promise.all([\n          getUsername(userId),\n          getScore(userId),\n        ]);\n      } catch (error) {\n        console.error(`Error getting user info: ${error}`);\n      }\n    }\n\n    res.json({\n      showForm: {\n        name: 'setUserPointsForm',\n        form: {\n          title: 'User points',\n          description: 'Set the exact number of points for a user',\n          fields: [\n            {\n              type: 'string',\n              name: 'username',\n              label: 'Username',\n              placeholder: 'Enter a username',\n              required: true,\n              helpText: 'No u/ prefix',\n              defaultValue: defaultUsername,\n            },\n            {\n              type: 'number',\n              name: 'points',\n              label: 'Points',\n              placeholder: '1000',\n              required: true,\n              helpText: 'The exact number of points to set',\n              defaultValue: defaultPoints,\n            },\n          ],\n          acceptLabel: 'Set Points',\n          cancelLabel: 'Cancel',\n        },\n      },\n    });\n  } catch (error) {\n    console.error(`Error loading set user points form: ${error}`);\n    res.json({\n      showToast: {\n        text: 'Failed to load form',\n        appearance: 'error',\n      },\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/menu-actions/user-points-set/user-points-set.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 1,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 52,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 52,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { reddit } from '@devvit/web/server';\nimport { setScore, getUserLevel } from '@server/services/progression';\n\n/**\n * Form handler for setting user points\n * Sets the exact score for a user\n */\n\nexport async function handleSetUserPoints(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const { username, points } = req.body;\n\n    if (!username || points === undefined) {\n      res.status(400).json({\n        showToast: 'Username and points are required',\n      });\n      return;\n    }\n\n    // Look up user\n    const user = await reddit.getUserByUsername(username);\n    if (!user) {\n      res.status(400).json({\n        showToast: `User u/${username} not found`,\n      });\n      return;\n    }\n\n    const userId = user.id;\n    const pointsNumber = Number(points);\n\n    if (isNaN(pointsNumber)) {\n      res.status(400).json({\n        showToast: 'Points must be a number',\n      });\n      return;\n    }\n\n    // Set the score\n    await setScore(userId, pointsNumber);\n    const level = getUserLevel(pointsNumber);\n    const rankText = level.rank;\n\n    res.json({\n      showToast: `u/${username} has ${pointsNumber} points (Level ${rankText})`,\n    });\n  } catch (error) {\n    console.error(`Error setting user points: ${error}`);\n    res.status(500).json({\n      showToast: 'Failed to set points',\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/drawing-post-comment.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 23,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 23,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [723, 725], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 58,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 58,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1634, 1636], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 78,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 78,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { context } from '@devvit/web/server';\nimport type { Request, Response } from 'express';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { assertT3 } from '@devvit/shared-types/tid.js';\nimport {\n  createDrawingPostComment,\n  updateDrawingPostComment,\n  getDrawingCommentData,\n} from '@server/services/posts/drawing';\nimport { setPostFlair, getDifficultyFromStats } from '@server/core/flair';\n\n/**\n * Job handler for creating a new drawing pinned comment\n * Creates a contextual comment for drawing posts\n */\n\nexport async function handleNewDrawingPinnedComment(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Extract data from the scheduler payload\n    const jobData = req.body.data || req.body;\n    const { postId } = jobData;\n\n    // Validate and parse postId as T3\n    let validatedPostId: T3;\n    try {\n      assertT3(postId);\n      validatedPostId = postId;\n    } catch (error) {\n      res.status(400).json({\n        status: 'error',\n        message: 'PostId is required and must be a valid T3 ID',\n      });\n      return;\n    }\n\n    // Create the pinned comment\n    await createDrawingPostComment(validatedPostId);\n    res.json({ status: 'success' });\n  } catch (error) {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n\n/**\n * Job handler for updating drawing pinned comment with live stats\n * Updates comment with comprehensive stats and guess distribution\n */\n\nexport async function handleUpdateDrawingPinnedComment(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Extract data from the scheduler payload\n    const jobData = req.body.data || req.body;\n\n    // Validate and parse postId as validateT3\n    let postId: T3;\n    try {\n      postId = jobData.postId;\n    } catch (error) {\n      res.status(400).json({\n        status: 'error',\n        message: 'PostId is required and must be a valid T3 ID',\n      });\n      return;\n    }\n\n    // Update the pinned comment\n    await updateDrawingPostComment(postId);\n\n    // Set difficulty flair if threshold is met (non-blocking)\n    try {\n      const stats = await getDrawingCommentData(postId);\n      if (stats && stats.guessCount >= 100) {\n        const difficulty = getDifficultyFromStats(stats);\n        if (difficulty) {\n          await setPostFlair(postId, context.subredditName, difficulty);\n        }\n      }\n    } catch (error) {\n      // Don't fail the job if flair setting fails\n    }\n\n    res.json({ status: 'success' });\n  } catch (error) {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/pinned-post-comment.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 17,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 17,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [534, 536], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { assertT3 } from '@devvit/shared-types/tid.js';\nimport { createPinnedPostComment } from '@server/services/posts/pinned';\n\n/**\n * Job handler for creating pinned post comment\n * Creates a contextual comment for pinned posts\n */\n\nexport async function handleCreatePinnedPostComment(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Extract data from the scheduler payload\n    const jobData = req.body.data || req.body;\n\n    // Validate and parse postId as T3\n    let postId: T3;\n    try {\n      assertT3(jobData.postId);\n      postId = jobData.postId;\n    } catch (error) {\n      res.status(400).json({\n        status: 'error',\n        message: 'PostId is required and must be a valid T3 ID',\n      });\n      return;\n    }\n\n    const commentId = await createPinnedPostComment(postId);\n\n    res.json({ status: 'success', commentId });\n  } catch (error) {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/tournament/payout.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
        "severity": 1,
        "message": "Passing a string to String() does not change the type or value of the string.",
        "line": 102,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unnecessaryTypeConversion",
        "endLine": 102,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestRemove",
            "fix": { "range": [3418, 3428], "text": "id" },
            "desc": "Remove the type conversion."
          },
          {
            "messageId": "suggestSatisfies",
            "data": { "type": "string" },
            "fix": { "range": [3418, 3428], "text": "(id satisfies string)" },
            "desc": "Instead, assert that the value satisfies the string type."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect, vi, beforeEach } from 'vitest';\n\nvi.mock('@devvit/web/server', () => ({\n  redis: {\n    hGet: vi.fn(),\n    hSet: vi.fn(),\n    zCard: vi.fn(),\n    zRange: vi.fn(),\n  },\n}));\n\nvi.mock('../../core/redis', () => ({\n  acquireLock: vi.fn().mockResolvedValue(true),\n  releaseLock: vi.fn().mockResolvedValue(undefined),\n  REDIS_KEYS: {\n    tournamentEntries: (p: string) => `tournament:entries:${p}`,\n    tournamentPayoutLedger: (p: string) => `tournament:payout:ledger:${p}`,\n    tournamentPayoutLock: (p: string, d: number) =>\n      `tournament:payout:lock:${p}:${d}`,\n  },\n}));\n\nvi.mock('../../services/posts/tournament/award', () => ({\n  awardTournamentRewards: vi.fn(),\n}));\nvi.mock('../../services/posts/tournament/post', () => ({\n  getTournamentEntry: vi.fn(),\n}));\n\nvi.mock('../../services/comments/pinned', () => ({\n  replyToPinnedComment: vi.fn(),\n}));\n\nvi.mock('../../core/user', () => ({\n  getUsername: vi.fn(),\n}));\n\nimport type { Request, Response } from 'express';\nimport type { T1, T2, T3 } from '@devvit/shared-types/tid.js';\nimport { redis } from '@devvit/web/server';\nimport { handleTournamentPayoutSnapshot } from './payout';\nimport { acquireLock, releaseLock } from '../../core/redis';\nimport { awardTournamentRewards } from '../../services/posts/tournament/award';\nimport { getTournamentEntry } from '../../services/posts/tournament/post';\nimport { replyToPinnedComment } from '../../services/comments/pinned';\nimport { getUsername } from '../../core/user';\n\nfunction mockRes(): Response {\n  const res = {\n    json: vi.fn().mockReturnThis(),\n    status: vi.fn().mockReturnThis(),\n  } as unknown as Response;\n  return res;\n}\n\ndescribe('tournament payout snapshot', () => {\n  const postId = 't3_abc' as T3;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('skips when lock is held', async () => {\n    vi.mocked(acquireLock).mockResolvedValue(false as unknown as boolean);\n    const req = {\n      body: { data: { postId, dayIndex: 1 } },\n    } as unknown as Request;\n    const res = mockRes();\n    await handleTournamentPayoutSnapshot(req, res);\n    expect(res.json).toHaveBeenCalledWith(\n      expect.objectContaining({ status: 'skipped' })\n    );\n  });\n\n  it('skips when already ran', async () => {\n    vi.mocked(acquireLock).mockResolvedValue(true as unknown as boolean);\n    vi.mocked(redis.hGet).mockResolvedValue('1');\n    const req = {\n      body: { data: { postId, dayIndex: 1 } },\n    } as unknown as Request;\n    const res = mockRes();\n    await handleTournamentPayoutSnapshot(req, res);\n    expect(res.json).toHaveBeenCalledWith(\n      expect.objectContaining({ status: 'skipped' })\n    );\n    expect(releaseLock).toHaveBeenCalled();\n  });\n\n  it('awards payouts, writes ledger, and replies', async () => {\n    vi.mocked(acquireLock).mockResolvedValue(true as unknown as boolean);\n    vi.mocked(redis.hGet).mockResolvedValue(null as unknown as string);\n    vi.mocked(redis.zCard).mockResolvedValue(10);\n    vi.mocked(redis.zRange).mockResolvedValue([\n      { member: 't1_a', score: 1500 },\n      { member: 't1_b', score: 1400 },\n      { member: 't1_c', score: 1300 },\n      { member: 't1_d', score: 1200 },\n    ] as unknown as Array<{ member: string; score: number }>);\n    vi.mocked(getTournamentEntry).mockImplementation(async (id: T1) => ({\n      commentId: id,\n      drawing: {} as unknown as import('@shared/schema').DrawingData,\n      userId: ('t2_' + String(id)).slice(0, 6) as unknown as T2,\n      postId: postId,\n      votes: 0,\n      views: 0,\n      mediaUrl: '',\n      mediaId: '',\n    }));\n    vi.mocked(getUsername).mockResolvedValueOnce('alpha');\n    vi.mocked(getUsername).mockResolvedValueOnce('beta');\n    vi.mocked(getUsername).mockResolvedValueOnce('gamma');\n\n    const req = {\n      body: { data: { postId, dayIndex: 2 } },\n    } as unknown as Request;\n    const res = mockRes();\n    await handleTournamentPayoutSnapshot(req, res);\n\n    expect(awardTournamentRewards).toHaveBeenCalled();\n    expect(redis.hSet).toHaveBeenCalled();\n    expect(replyToPinnedComment).toHaveBeenCalledWith(\n      postId,\n      expect.stringContaining('Day 2/5')\n    );\n    expect(res.json).toHaveBeenCalledWith(\n      expect.objectContaining({ status: 'success' })\n    );\n  });\n\n  it('handles small tournaments (min 1)', async () => {\n    vi.mocked(acquireLock).mockResolvedValue(true as unknown as boolean);\n    vi.mocked(redis.hGet).mockResolvedValue(null as unknown as string);\n    vi.mocked(redis.zCard).mockResolvedValue(1);\n    vi.mocked(redis.zRange).mockResolvedValue([\n      { member: 't1_a', score: 1200 },\n    ] as unknown as Array<{ member: string; score: number }>);\n    vi.mocked(getTournamentEntry).mockResolvedValue({\n      commentId: 't1_a' as unknown as T1,\n      drawing: {} as unknown as import('@shared/schema').DrawingData,\n      userId: 't2_a' as unknown as T2,\n      postId: postId,\n      votes: 0,\n      views: 0,\n      mediaUrl: '',\n      mediaId: '',\n    });\n    vi.mocked(getUsername).mockResolvedValueOnce('alpha');\n\n    const req = {\n      body: { data: { postId, dayIndex: 1 } },\n    } as unknown as Request;\n    const res = mockRes();\n    await handleTournamentPayoutSnapshot(req, res);\n    expect(awardTournamentRewards).toHaveBeenCalled();\n    expect(res.json).toHaveBeenCalledWith(\n      expect.objectContaining({ status: 'success' })\n    );\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/tournament/payout.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 19,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 19,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [753, 755], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { assertT3 } from '@devvit/shared-types/tid.js';\nimport { redis } from '@devvit/web/server';\nimport { REDIS_KEYS, acquireLock, releaseLock } from '@server/core/redis';\nimport { awardTournamentRewards } from '@server/services/posts/tournament/award';\nimport { buildTournamentPayoutSummary } from '@server/services/posts/tournament/summary';\nimport { replyToPinnedComment } from '@server/services/comments/pinned';\n\n/**\n * Job handler for running a tournament payout snapshot.\n * Ensures idempotency per dayIndex via a ledger + lightweight lock.\n */\n\nexport async function handleTournamentPayoutSnapshot(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const jobData = req.body.data || req.body;\n    const { postId, dayIndex } = jobData;\n\n    // Validate postId and dayIndex\n    try {\n      assertT3(postId);\n    } catch {\n      res.status(400).json({ status: 'error', message: 'postId is required' });\n      return;\n    }\n    const day = Number(dayIndex);\n    if (!Number.isFinite(day) || day < 1) {\n      res.status(400).json({ status: 'error', message: 'dayIndex is invalid' });\n      return;\n    }\n\n    const ledgerKey = REDIS_KEYS.tournamentPayoutLedger(postId);\n    const lockKey = REDIS_KEYS.tournamentPayoutLock(postId, day);\n\n    // Acquire short-lived lock to dedupe concurrent scheduler calls\n    const gotLock = await acquireLock(lockKey, 120);\n    if (!gotLock) {\n      res.json({ status: 'skipped', reason: 'lock held' });\n      return;\n    }\n\n    try {\n      // Idempotency check\n      const alreadyRan = await redis.hGet(ledgerKey, String(day));\n      if (alreadyRan) {\n        res.json({ status: 'skipped', reason: 'already ran' });\n        return;\n      }\n\n      // Execute snapshot payout\n      await awardTournamentRewards(postId, {\n        dayIndex: day,\n      });\n\n      // Build and post summary reply\n      const summary = await buildTournamentPayoutSummary(postId, {\n        dayIndex: day,\n      });\n      try {\n        await replyToPinnedComment(postId, summary);\n      } catch {\n        // non-fatal\n      }\n\n      // Mark ledger\n      await redis.hSet(ledgerKey, { [String(day)]: '1' });\n\n      res.json({ status: 'success' });\n    } finally {\n      try {\n        await releaseLock(lockKey);\n      } catch {\n        // best effort\n      }\n    }\n  } catch {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/tournament/post-comment.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 18,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 18,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [650, 652], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { assertT3 } from '@devvit/shared-types/tid.js';\nimport { generateTournamentCommentText } from '@server/services/posts/tournament/comments';\nimport { createPinnedComment } from '@server/services/comments/pinned';\n\n/**\n * Job handler for creating tournament post comment\n * Creates a pinned comment explaining how to play the tournament\n */\n\nexport async function handleCreateTournamentPostComment(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    // Extract data from the scheduler payload\n    const jobData = req.body.data || req.body;\n    const { postId, word } = jobData;\n\n    // Validate and parse postId as T3\n    let validatedPostId: T3;\n    try {\n      assertT3(postId);\n      validatedPostId = postId;\n    } catch (error) {\n      res.status(400).json({\n        status: 'error',\n        message: 'PostId is required and must be a valid T3 ID',\n      });\n      return;\n    }\n\n    if (typeof word !== 'string' || word.trim() === '') {\n      res.status(400).json({\n        status: 'error',\n        message: 'Word is required to create tournament comment',\n      });\n      return;\n    }\n\n    // Create the pinned comment\n    const text = generateTournamentCommentText(word);\n    await createPinnedComment(validatedPostId, text);\n    res.json({ status: 'success' });\n  } catch (error) {\n    console.error('Tournament pinned comment creation failed:', error);\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/tournament/scheduler.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/tournament/scheduler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/update-word-stats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/user/flair.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/user/flair.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 22,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 22,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [602, 604], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 26,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 26,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 38,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 38,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/use-unknown-in-catch-callback-variable",
        "severity": 1,
        "message": "Prefer the safe `: unknown` for a `catch` callback variable.",
        "line": 46,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "useUnknown",
        "endLine": 46,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "addUnknownTypeAnnotationSuggestion",
            "fix": { "range": [1239, 1239], "text": ": unknown" },
            "desc": "Add an explicit `: unknown` type annotation to the rejection callback variable."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport type { T2 } from '@devvit/shared-types/tid.js';\nimport { getUsername } from '@server/core/user';\nimport { reddit } from '@devvit/web/server';\nimport type { Level } from '@shared/types';\nimport { isLegacyUser } from '@server/services/legacy';\n\n/**\n * Job handler for setting user flair\n * Runs in app context to ensure proper permissions\n */\n\nexport async function handleSetUserFlair(\n  req: Request,\n  res: Response\n): Promise<void> {\n  let userId: T2;\n  let subredditName: string;\n  let level: Level;\n\n  try {\n    const jobData = req.body.data || req.body;\n    ({ userId, subredditName, level } = jobData);\n\n    // Validate required parameters\n    if (!userId) {\n      res.status(400).json({ status: 'error', message: 'userId is required' });\n      return;\n    }\n\n    if (!subredditName) {\n      res\n        .status(400)\n        .json({ status: 'error', message: 'subredditName is required' });\n      return;\n    }\n\n    if (!level) {\n      res.status(400).json({ status: 'error', message: 'level is required' });\n      return;\n    }\n\n    // First check if user flair is enabled\n    const userTemplates = await reddit\n      .getUserFlairTemplates(subredditName)\n      .catch((_error) => {\n        return [];\n      });\n\n    if (userTemplates.length === 0) {\n      res.json({ status: 'success', message: 'User flair not enabled' });\n      return;\n    }\n\n    // Convert T2 ID to username for the API call\n    const username = await getUsername(userId);\n\n    // Format flair text and CSS class\n    const baseText = `Level ${level.rank} - ${level.name}`;\n    let flairText = baseText;\n    try {\n      if (await isLegacyUser(userId)) {\n        flairText = `${baseText} [OG]`;\n      }\n    } catch {\n      // Non-blocking: legacy check shouldn't fail the job\n    }\n    const cssClass = `level-${level.rank}`;\n\n    // Set user flair using app context\n    await reddit.setUserFlair({\n      username: username,\n      subredditName,\n      text: flairText,\n      cssClass: cssClass,\n    });\n\n    res.json({ status: 'success' });\n  } catch (error) {\n    // Check if it's a 404 error (API endpoint not found)\n    if (error instanceof Error && error.message.includes('404')) {\n      res.json({ status: 'success', message: 'Flair API not available' });\n    } else {\n      res.status(500).json({ status: 'error', message: 'Job failed' });\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/user/level-claimed.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 13,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 13,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [329, 331], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { grantItems } from '@server/services/rewards/consumables';\n\n/**\n * Job handler for granting score multipliers upon level claim\n */\n\nexport async function handleUserLevelClaimed(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const jobData = req.body.data || req.body;\n    const { userId, level } = jobData;\n\n    if (!userId || typeof level !== 'number') {\n      res.status(400).json({ status: 'error', message: 'invalid payload' });\n      return;\n    }\n\n    // Grant 5 score multipliers upon claim\n    await grantItems(userId, [\n      { itemId: 'score_multiplier_2x_4h', quantity: 5 },\n    ]);\n\n    res.json({ status: 'success' });\n  } catch (error) {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/scheduler/user/level-up.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 14,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 14,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [358, 360], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response } from 'express';\nimport { getLevelByScore, getScore } from '@server/services/progression';\nimport { scheduler } from '@devvit/web/server';\n\n/**\n * Job handler for handling user level up\n */\n\nexport async function handleUserLevelUp(\n  req: Request,\n  res: Response\n): Promise<void> {\n  try {\n    const jobData = req.body.data || req.body;\n    const { userId, subredditName } = jobData;\n\n    // Validate required parameters\n    if (!userId) {\n      res.status(400).json({ status: 'error', message: 'userId is required' });\n      return;\n    }\n\n    if (!subredditName) {\n      res\n        .status(400)\n        .json({ status: 'error', message: 'subredditName is required' });\n      return;\n    }\n\n    const score = await getScore(userId);\n    const level = getLevelByScore(score);\n\n    // Schedule user flair update (non-blocking)\n    try {\n      await scheduler.runJob({\n        name: 'SET_USER_FLAIR',\n        data: {\n          userId,\n          subredditName,\n          level,\n        },\n        runAt: new Date(),\n      });\n    } catch (error) {\n      // Don't fail the job if flair scheduling fails\n    }\n\n    // TODO: Send DM to user\n    // const message =\n    //   ` Congratulations! You've leveled up to **${level.name}** (Level ${level.rank})!\\n\\n` +\n    //   `You now have ${level.extraTime} extra seconds when drawing!\\n\\n` +\n    //   `Keep drawing and guessing to reach the next level!`;\n\n    res.json({ status: 'success' });\n  } catch (error) {\n    res.status(500).json({ status: 'error', message: 'Job failed' });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/comment-commands.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/comment-commands.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 52,
        "column": 19,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 52,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1106, 1107], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 53,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "neverNullish",
        "endLine": 53,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { T5, T3, T1, T2 } from '@devvit/shared-types/tid.js';\nimport * as handlers from './handlers';\nimport {\n  getBackedWord,\n  removeBacker,\n} from '@server/services/words/word-backing';\n\nexport type CommandContext = {\n  commentId: T1;\n  authorName: string;\n  authorId: T2;\n  subredditName: string;\n  subredditId: T5;\n  postId?: T3;\n  timestamp: number;\n};\n\nexport type CommandResult = {\n  success: boolean;\n  response?: string;\n  error?: string;\n  metadata?: Record<string, unknown>;\n};\n\nexport type CommandHandler = (\n  args: string[],\n  context: CommandContext\n) => Promise<CommandResult>;\n\nconst COMMAND_LIST = [\n  '!add',\n  '!remove',\n  '!words',\n  '!stats',\n  '!score',\n  '!show',\n  '!dispense',\n  '!help',\n];\n\nexport function isCommand(text: string): boolean {\n  if (!text || typeof text !== 'string') return false;\n  const command = text.split(' ')[0]?.toLowerCase().trim();\n  return command ? COMMAND_LIST.includes(command) : false;\n}\n\nexport function parseCommand(text: string): {\n  command: string;\n  args: string[];\n} {\n  const parts = text.trim().split(' ');\n  const command = parts[0]!.toLowerCase();\n  const args = parts.slice(1) ?? [];\n  return { command, args };\n}\n\nexport async function processCommand(\n  command: string,\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  const normalizedCommand = command.toLowerCase();\n  switch (normalizedCommand) {\n    case '!words':\n      return handlers.handleWords(args, context);\n    case '!add':\n      return handlers.handleAdd(args, context);\n    case '!remove':\n      return handlers.handleRemove(args, context);\n    case '!stats':\n      return handlers.handleStats(args, context);\n    case '!score':\n      return handlers.handleScore(args, context);\n    case '!show':\n      return handlers.handleShow(args, context);\n    case '!dispense':\n      return handlers.handleDispense(args, context);\n    case '!help':\n      return handlers.handleHelp(args, context);\n    default:\n      return { success: false, error: 'Unknown command' };\n  }\n}\n\nexport async function handleCommentEdit(\n  commentId: T1,\n  previousBody: string,\n  newBody: string,\n  context: Omit<CommandContext, 'commentId'>\n): Promise<CommandResult> {\n  const wasCommand = isCommand(previousBody);\n  const isNowCommand = isCommand(newBody);\n  const backedWord = await getBackedWord(commentId);\n\n  const fullContext: CommandContext = {\n    ...context,\n    commentId,\n  };\n\n  if (wasCommand && !isNowCommand) {\n    if (backedWord) {\n      await removeBacker(backedWord);\n    }\n    return { success: true };\n  }\n\n  if (!wasCommand && isNowCommand) {\n    const { command, args } = parseCommand(newBody);\n    return await processCommand(command, args, fullContext);\n  }\n\n  if (wasCommand && isNowCommand) {\n    if (backedWord) {\n      await removeBacker(backedWord);\n    }\n    const { command, args } = parseCommand(newBody);\n    return await processCommand(command, args, fullContext);\n  }\n\n  return { success: true };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/add.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 12,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 12,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { addWord, getBannedWords } from '@server/services/words/dictionary';\nimport { getScore, getLevelByScore } from '@server/services/progression';\nimport { hasReward } from '@shared/rewards';\nimport { addBacker } from '@server/services/words/word-backing';\n\nexport async function handleAdd(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    if (context.authorId) {\n      const userScore = await getScore(context.authorId);\n      const userLevel = getLevelByScore(userScore);\n\n      if (!hasReward(userLevel.rank, 'add_remove_words')) {\n        return { success: false, error: 'Requires Level 3 to add words.' };\n      }\n    }\n\n    if (args.length === 0) {\n      return { success: false, error: 'Provide a word. Usage: `!add <word>`' };\n    }\n\n    const word = args[0]?.trim();\n    if (!word || word.length > 50) {\n      return { success: false, error: 'Invalid word. Max 50 characters.' };\n    }\n\n    const bannedWordsResult = await getBannedWords(0, 10000);\n    const isBanned = bannedWordsResult.words.some(\n      (w) => w.toLowerCase() === word.toLowerCase()\n    );\n    if (isBanned) {\n      return { success: false, error: 'Word banned.' };\n    }\n\n    const success = await addWord(word);\n\n    if (success) {\n      await addBacker(word, context.commentId);\n      return {\n        success: true,\n        response: `Added \"${word}\". Removed if comment deleted.`,\n        metadata: { word, addedBy: context.authorName },\n      };\n    } else {\n      return { success: false, error: `Already exists.` };\n    }\n  } catch (error) {\n    return { success: false, error: 'Failed to add word.' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/dispense.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 30,
        "column": 25,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 30,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [970, 971], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 31,
        "column": 20,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 31,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1006, 1007], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 32,
        "column": 26,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 32,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1064, 1065], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 50,
        "column": 26,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 50,
        "endColumn": 39,
        "fix": { "range": [1701, 1707], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 54,
        "column": 19,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 54,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1892, 1893], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 54,
        "column": 19,
        "nodeType": "TSNonNullExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 54,
        "endColumn": 46,
        "fix": { "range": [1892, 1893], "text": "" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { isAdmin, isModerator } from '@server/core/redis';\nimport { reddit } from '@devvit/web/server';\nimport type { T2 } from '@devvit/shared-types/tid.js';\nimport { CONSUMABLES_CONFIG, type ConsumableId } from '@shared/consumables';\n\nexport async function handleDispense(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    // Authorization: admin or mod only\n    const userIsAdmin = await isAdmin(context.authorId);\n    const userIsModerator = await isModerator(\n      context.authorId,\n      context.subredditName\n    );\n    if (!userIsAdmin && !userIsModerator) {\n      return { success: false, error: 'Not authorized' };\n    }\n\n    // Expect: !dispense u/<username> <itemId> <qty>\n    if (args.length < 3) {\n      return {\n        success: false,\n        error: 'Usage: !dispense u/<username> <itemId> <qty>',\n      };\n    }\n\n    const rawUsername = args[0]!.trim();\n    const itemId = args[1]!.trim() as ConsumableId;\n    const qty = parseInt(args[2]!.trim(), 10);\n\n    if (!rawUsername.startsWith('u/')) {\n      return { success: false, error: 'Username must start with u/' };\n    }\n    if (!Object.prototype.hasOwnProperty.call(CONSUMABLES_CONFIG, itemId)) {\n      return { success: false, error: 'Unknown itemId' };\n    }\n    if (!Number.isFinite(qty) || qty <= 0) {\n      return { success: false, error: 'Quantity must be a positive integer' };\n    }\n\n    const username = rawUsername.slice(2);\n    const user = await reddit.getUserByUsername(username);\n    if (!user) {\n      return { success: false, error: `User ${rawUsername} not found` };\n    }\n\n    const targetUserId = user.id as T2;\n    const { grantItems } = await import('../../../rewards/consumables');\n    await grantItems(targetUserId, [{ itemId, quantity: qty }]);\n\n    const label = CONSUMABLES_CONFIG[itemId]!.label;\n    const response = `Dispensed ${qty}  ${label} to ${rawUsername}.`;\n    return { success: true, response };\n  } catch {\n    return { success: false, error: 'Failed to dispense items' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/help.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/remove.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 11,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 11,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { removeWord } from '@server/services/words/dictionary';\nimport { getScore, getLevelByScore } from '@server/services/progression';\nimport { hasReward } from '@shared/rewards';\n\nexport async function handleRemove(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    if (context.authorId) {\n      const userScore = await getScore(context.authorId);\n      const userLevel = getLevelByScore(userScore);\n\n      if (!hasReward(userLevel.rank, 'add_remove_words')) {\n        return { success: false, error: 'Requires Level 3 to remove words.' };\n      }\n    }\n\n    if (args.length === 0) {\n      return {\n        success: false,\n        error: 'Provide a word. Usage: `!remove <word>`',\n      };\n    }\n\n    const word = args[0]?.trim();\n    if (!word) {\n      return { success: false, error: 'Invalid word.' };\n    }\n\n    const success = await removeWord(word);\n\n    if (success) {\n      return {\n        success: true,\n        response: `Removed \"${word}\".`,\n        metadata: { word, removedBy: context.authorName },\n      };\n    } else {\n      return { success: false, error: `Not in dictionary.` };\n    }\n  } catch (error) {\n    return { success: false, error: 'Failed to remove word.' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/score.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 31,
        "column": 16,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 31,
        "endColumn": 29,
        "fix": { "range": [962, 968], "text": "" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { getScore, getRank, getUserLevel } from '@server/services/progression';\nimport { getUsername } from '@server/core/user';\nimport { reddit } from '@devvit/web/server';\nimport type { T2 } from '@devvit/shared-types/tid.js';\n\nexport async function handleScore(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    let userId: T2;\n\n    if (args.length === 0) {\n      userId = context.authorId;\n    } else {\n      const usernameArg = args[0]?.trim();\n      if (!usernameArg) {\n        return { success: false, error: 'Invalid username' };\n      }\n\n      const cleanUsername = usernameArg.startsWith('u/')\n        ? usernameArg.slice(2)\n        : usernameArg;\n\n      const user = await reddit.getUserByUsername(cleanUsername);\n      if (!user) {\n        return { success: false, error: `User u/${cleanUsername} not found` };\n      }\n\n      userId = user.id as T2;\n    }\n\n    const [score, rank, level, username] = await Promise.all([\n      getScore(userId),\n      getRank(userId),\n      getUserLevel(await getScore(userId)),\n      getUsername(userId),\n    ]);\n\n    const isSelf = userId === context.authorId;\n    const rankText = rank === -1 ? 'Unranked' : `Rank ${rank}`;\n    const response = isSelf\n      ? `You have ${score} points (Level ${level.rank}, ${rankText})`\n      : `u/${username} has ${score} points (Level ${level.rank}, ${rankText})`;\n\n    return {\n      success: true,\n      response,\n      metadata: {\n        userId,\n        score,\n        rank: rank === -1 ? null : rank,\n        level: level.rank,\n        username,\n        isSelf,\n      },\n    };\n  } catch (error) {\n    return { success: false, error: 'Failed to retrieve user score' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/show.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 50,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 50,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { normalizeWord } from '@shared/utils/string';\nimport { isWordBanned } from '@server/services/words/dictionary';\nimport {\n  getBacker,\n  addBacker,\n  shouldShowWord,\n} from '@server/services/words/word-backing';\nimport { incrementScore } from '@server/services/progression';\n\nexport async function handleShow(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    if (args.length === 0) {\n      return { success: false, error: 'Provide a word. Usage: `!show <word>`' };\n    }\n\n    const word = args[0]?.trim();\n    if (!word) {\n      return { success: false, error: 'Invalid word.' };\n    }\n\n    const normalizedWord = normalizeWord(word);\n\n    const banned = await isWordBanned(normalizedWord);\n    if (banned) {\n      return {\n        success: true,\n        response: 'This word is banned.',\n        metadata: { word: normalizedWord, wasBacked: false, isBanned: true },\n      };\n    }\n\n    const isAlreadyVisible = await shouldShowWord(normalizedWord);\n    if (isAlreadyVisible) {\n      return {\n        success: true,\n        response: 'This word is already visible.',\n        metadata: { word: normalizedWord, wasBacked: false, isBanned: false },\n      };\n    }\n\n    const existingBacking = await getBacker(normalizedWord);\n    const isFirstTimeBacking = existingBacking === null;\n\n    await addBacker(normalizedWord, context.commentId);\n\n    if (isFirstTimeBacking && context.authorId) {\n      try {\n        await incrementScore(context.authorId, 1);\n      } catch {\n        // ignore scoring errors\n      }\n    }\n\n    return {\n      success: true,\n      response: 'This word is now visible.',\n      metadata: { word: normalizedWord, wasBacked: true, isBanned: false },\n    };\n  } catch (error) {\n    return { success: false, error: 'Failed to back word.' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/stats.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/stats.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 63,
        "column": 73,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 63,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2108, 2110], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 64,
        "column": 68,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 64,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2184, 2186], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 65,
        "column": 71,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 65,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2263, 2265], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { isWordInList } from '@server/services/words/dictionary';\nimport { addBacker } from '@server/services/words/word-backing';\nimport { redis, context } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport type { WordMetrics } from '@shared/types';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { normalizeWord } from '@shared/utils/string';\n\nexport async function handleStats(\n  args: string[],\n  commandContext: CommandContext\n): Promise<CommandResult> {\n  try {\n    if (args.length === 0) {\n      return {\n        success: true,\n        response: 'Provide a word. Usage: `!stats <word>`',\n      };\n    }\n\n    const word = args[0]?.trim();\n    if (!word) {\n      return { success: false, error: 'Invalid word.' };\n    }\n\n    const wordExists = await isWordInList(word);\n    if (!wordExists) {\n      return { success: false, error: `Word not found. See \\`!words\\`.` };\n    }\n\n    await addBacker(word, commandContext.commentId);\n\n    const metrics = await getWordMetrics(word);\n\n    const response = `#####  Drawer stats\n- Shown: ${metrics.impressions}\n- Picked: ${metrics.clicks} (${(metrics.clickRate * 100).toFixed(1)}%)\n- Started: ${metrics.starts}\n- Published: ${metrics.publishes} (${(metrics.publishRate * 100).toFixed(1)}%)\n- Guesses: ${metrics.guesses}\n- Skips: ${metrics.skips} (${(metrics.skipRate * 100).toFixed(1)}%)\n- Solves: ${metrics.solves} (${(metrics.solveRate * 100).toFixed(1)}%)\n\n#####  Social stats\n- Upvotes: ${metrics.upvotes}\n- Comments: ${metrics.comments}`;\n\n    return { success: true, response, metadata: { word, isBanned: false } };\n  } catch (error) {\n    return { success: false, error: 'Failed to retrieve word statistics' };\n  }\n}\n\nexport async function getWordMetrics(word: string): Promise<WordMetrics> {\n  try {\n    const normalizedWord = normalizeWord(word);\n\n    const totalStats = await redis.hGetAll(\n      REDIS_KEYS.wordsTotalStats(context.subredditName)\n    );\n\n    const impressions = parseInt(totalStats[`${normalizedWord}:served`] || '0');\n    const clicks = parseInt(totalStats[`${normalizedWord}:picked`] || '0');\n    const publishes = parseInt(totalStats[`${normalizedWord}:posted`] || '0');\n\n    const wordDrawings = await redis.zRange(\n      REDIS_KEYS.wordDrawings(normalizedWord),\n      0,\n      -1\n    );\n\n    let starts = 0;\n    let guesses = 0;\n    let skips = 0;\n    let solves = 0;\n    const upvotes = 0;\n    const comments = 0;\n\n    for (const drawing of wordDrawings) {\n      const postId = drawing.member as T3;\n      const [attempts, solvesCount, skipsCount, guessesCount] =\n        await Promise.all([\n          redis.zCard(REDIS_KEYS.drawingAttempts(postId)),\n          redis.zCard(REDIS_KEYS.drawingSolves(postId)),\n          redis.zCard(REDIS_KEYS.drawingSkips(postId)),\n          redis.zCard(REDIS_KEYS.drawingGuesses(postId)),\n        ]);\n\n      starts += attempts;\n      solves += solvesCount;\n      skips += skipsCount;\n      guesses += guessesCount;\n    }\n\n    const clickRate = impressions > 0 ? clicks / impressions : 0;\n    const publishRate = impressions > 0 ? publishes / impressions : 0;\n    const skipRate = starts > 0 ? skips / starts : 0;\n    const solveRate = starts > 0 ? solves / starts : 0;\n\n    return {\n      impressions,\n      clicks,\n      clickRate,\n      publishes,\n      publishRate,\n      starts,\n      guesses,\n      skips,\n      solves,\n      skipRate,\n      solveRate,\n      upvotes,\n      comments,\n    };\n  } catch (error) {\n    return {\n      impressions: 0,\n      clicks: 0,\n      clickRate: 0,\n      publishes: 0,\n      publishRate: 0,\n      starts: 0,\n      guesses: 0,\n      skips: 0,\n      solves: 0,\n      skipRate: 0,\n      solveRate: 0,\n      upvotes: 0,\n      comments: 0,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/commands/handlers/words.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 10,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 10,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [312, 314], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { CommandContext, CommandResult } from '../comment-commands';\nimport { getWords } from '@server/services/words/dictionary';\n\nexport async function handleWords(\n  args: string[],\n  context: CommandContext\n): Promise<CommandResult> {\n  try {\n    const pageSize = 200;\n    const page = parseInt(args[0] || '1', 10) || 1;\n\n    if (page < 1 || page > 1000) {\n      return { success: false, error: 'Invalid page number (1-1000)' };\n    }\n\n    const offset = (page - 1) * pageSize;\n    const result = await getWords(context.subredditName, offset, pageSize);\n\n    const { words, total, hasMore } = result;\n    const wordCount = total;\n    const totalPages = Math.ceil(wordCount / pageSize);\n\n    if (wordCount <= pageSize) {\n      const wordList = words.join(', ');\n      const response =\n        `r/${context.subredditName} dictionary: ${wordList}\\n\\n` +\n        `${wordCount} total words.\\n\\n`;\n\n      return {\n        success: true,\n        response,\n        metadata: { wordCount, totalPages: 1 },\n      };\n    }\n\n    const wordList = words.join(', ');\n    const nextPageText = hasMore\n      ? ` Use \\`!words ${page + 1}\\` for next page.`\n      : '';\n\n    const response =\n      `r/${context.subredditName} dictionary: ${wordList}\\n\\n` +\n      `${wordCount} total words.\\n\\n` +\n      `Page ${page} of ${totalPages}.${nextPageText}\\n\\n`;\n\n    return {\n      success: true,\n      response,\n      metadata: { page, totalPages, wordCount },\n    };\n  } catch (error) {\n    return { success: false, error: 'Failed to retrieve dictionary.' };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/pinned.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/comments/pinned.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/drawing.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/legacy.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/legacy.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/collection.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 47,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 47,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1504, 1506], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 48,
        "column": 46,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 48,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1556, 1558], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 49,
        "column": 29,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 49,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1591, 1593], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { redis, reddit, context } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport { createPost } from '@server/core/post';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport type { T2, T3 } from '@devvit/shared-types/tid.js';\n\nexport type CollectionDrawing = {\n  postId: T3;\n  drawing: DrawingData;\n  word: string;\n  authorName: string;\n  score: number;\n};\n\nexport type CollectionData = {\n  label: string;\n  createdAt: number;\n  drawings: CollectionDrawing[];\n};\n\nexport async function fetchTopDrawingPosts(\n  subredditName: string,\n  days: number,\n  limit: number\n): Promise<CollectionDrawing[]> {\n  try {\n    const now = Date.now();\n    const cutoffTime = now - days * 24 * 60 * 60 * 1000;\n    const allPostIds = await redis.zRange(REDIS_KEYS.allDrawings(), 0, -1);\n    const postIds: T3[] = [];\n    for (const item of allPostIds) {\n      if (item.score >= cutoffTime) {\n        if (typeof item.member === 'string' && item.member.startsWith('t3_')) {\n          postIds.push(item.member as T3);\n        }\n      }\n    }\n    if (postIds.length === 0) return [];\n    const fetchPromises = postIds.map(async (postId) => {\n      try {\n        const drawingData = await redis.hGetAll(REDIS_KEYS.drawing(postId));\n        const post = await reddit.getPostById(postId);\n        if (!drawingData.drawing || !post) return null;\n        return {\n          postId,\n          drawing: JSON.parse(drawingData.drawing) as DrawingData,\n          word: drawingData.word || '',\n          authorName: drawingData.authorName || '',\n          score: post.score || 0,\n        };\n      } catch (error) {\n        return null;\n      }\n    });\n    const results = await Promise.all(fetchPromises);\n    const validDrawings = results.filter(\n      (r): r is CollectionDrawing => r !== null\n    );\n    validDrawings.sort((a, b) => b.score - a.score);\n    return validDrawings.slice(0, limit);\n  } catch (error) {\n    return [];\n  }\n}\n\nexport async function createCollectionPost(\n  postTitle: string,\n  label: string,\n  drawings: CollectionDrawing[]\n): Promise<{ id: T3 }> {\n  const collectionId = `collection_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n  const collectionData: CollectionData = {\n    label,\n    createdAt: Date.now(),\n    drawings,\n  };\n  await redis.set(\n    REDIS_KEYS.collection(collectionId),\n    JSON.stringify(collectionData)\n  );\n  const postData = { type: 'collection' as const, collectionId, label };\n  const post = await createPost(postTitle, postData);\n  return post;\n}\n\nexport async function getCollectionData(\n  collectionId: string\n): Promise<CollectionData | null> {\n  const data = await redis.get(REDIS_KEYS.collection(collectionId));\n  if (!data) return null;\n  return JSON.parse(data) as CollectionData;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/drawing.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 338,
        "column": 19,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 338,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 342,
        "column": 30,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 342,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9018, 9020], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 343,
        "column": 42,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 343,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9066, 9068], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 344,
        "column": 47,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 344,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9119, 9121], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 346,
        "column": 42,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 346,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9214, 9216], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 379,
        "column": 48,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 379,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [10227, 10229], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 382,
        "column": 26,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 382,
        "endColumn": 44,
        "fix": { "range": [10356, 10374], "text": "Array<Promise<unknown>>" }
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `unknown`.",
        "line": 438,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 438,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `unknown`.",
        "line": 438,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 438,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 449,
        "column": 38,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 449,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 468,
        "column": 12,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 468,
        "endColumn": 45,
        "fix": {
          "range": [12784, 12817],
          "text": "Array<{ word: string; count: number }>"
        }
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 493,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 493,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 493,
        "column": 65,
        "nodeType": "MemberExpression",
        "messageId": "invalid",
        "endLine": 493,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 604,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 604,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 604,
        "column": 55,
        "nodeType": "MemberExpression",
        "messageId": "invalid",
        "endLine": 604,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import {\n  redis,\n  scheduler,\n  realtime,\n  context,\n  cache,\n  media,\n} from '@devvit/web/server';\nimport { incrementScore } from '@server/services/progression';\nimport { REDIS_KEYS, acquireLock, isRateLimited } from '@server/core/redis';\nimport { normalizeWord, obfuscateString } from '@shared/utils/string';\nimport { shouldShowWord } from '@server/services/words/word-backing';\nimport type { DrawingPostDataExtended } from '@shared/schema/pixelary';\nimport { createPost } from '@server/core/post';\nimport { setPostFlair } from '@server/core/flair';\nimport type { DrawingData } from '@shared/schema/drawing';\nimport type { T1, T2, T3 } from '@devvit/shared-types/tid.js';\nimport { isT2, isT3 } from '@devvit/shared-types/tid.js';\nimport {\n  AUTHOR_REWARD_CORRECT_GUESS,\n  AUTHOR_REWARD_SUBMIT,\n  GUESSER_REWARD_SOLVE,\n} from '@shared/constants';\nimport type { MediaAsset } from '@devvit/web/server';\nimport {\n  createPinnedComment,\n  updatePinnedComment,\n} from '@server/services/comments/pinned';\nimport { REALTIME_CHANNELS } from '@server/core/realtime';\n\nconst DRAWING_DATA_TTL = 5 * 60;\n\nasync function getCachedDrawingData(\n  postId: T3\n): Promise<Record<string, string>> {\n  return await cache(\n    async () => {\n      return await redis.hGetAll(REDIS_KEYS.drawing(postId));\n    },\n    {\n      key: `drawing_data:${postId}`,\n      ttl: DRAWING_DATA_TTL,\n    }\n  );\n}\n\nexport const createDrawing = async (options: {\n  word: string;\n  dictionary: string;\n  drawing: DrawingData;\n  authorName: string;\n  authorId: T2;\n  imageData?: string;\n}) => {\n  const { word, dictionary, drawing, authorName, authorId, imageData } =\n    options;\n\n  let imageUrl: string | undefined;\n  if (imageData) {\n    try {\n      const mediaResponse: MediaAsset = await media.upload({\n        url: imageData,\n        type: 'image',\n      });\n      imageUrl = mediaResponse.mediaUrl;\n    } catch (error) {\n      console.warn('Failed to upload image:', error);\n    }\n  }\n\n  const postData = {\n    type: 'drawing' as const,\n    word,\n    drawing,\n    dictionary,\n    authorId,\n    authorName,\n  };\n\n  const post = await createPost(\n    `What did u/${authorName} draw?`,\n    postData,\n    imageUrl\n  );\n\n  const postId = post.id;\n  const currentDate = new Date();\n  const currentTime = currentDate.getTime();\n  const normalizedWord = normalizeWord(word);\n\n  await Promise.all([\n    redis.hSet(REDIS_KEYS.drawing(postId), {\n      type: 'drawing',\n      postId,\n      createdAt: post.createdAt.getTime().toString(),\n      word,\n      normalizedWord,\n      dictionary,\n      drawing: JSON.stringify(drawing),\n      authorId,\n      authorName,\n    }),\n    incrementScore(authorId, AUTHOR_REWARD_SUBMIT),\n    redis.zAdd(REDIS_KEYS.wordDrawings(word), {\n      member: postId,\n      score: currentTime,\n    }),\n    redis.zAdd(REDIS_KEYS.allDrawings(), {\n      member: postId,\n      score: currentTime,\n    }),\n    redis.zAdd(REDIS_KEYS.userDrawings(authorId), {\n      member: postId,\n      score: currentTime,\n    }),\n  ]);\n\n  try {\n    await scheduler.runJob({\n      name: 'NEW_DRAWING_PINNED_COMMENT',\n      data: { postId, authorName, word },\n      runAt: currentDate,\n    });\n  } catch (error) {\n    // Ignore scheduling errors: comment creation is best-effort\n  }\n\n  try {\n    await setPostFlair(postId, context.subredditName, 'unranked');\n  } catch (error) {\n    // Ignore flair errors: should not block post creation\n  }\n\n  return post;\n};\n\nexport async function getDrawing(\n  postId: T3\n): Promise<DrawingPostDataExtended | null> {\n  const key = REDIS_KEYS.drawing(postId);\n  const [data, stats] = await Promise.all([\n    redis.hGetAll(key),\n    getDrawingStats(postId),\n  ]);\n  const {\n    type,\n    word,\n    dictionary,\n    drawing,\n    authorId,\n    authorName,\n    lastCommentUpdate,\n  } = data;\n  const { playerCount, solvedPercentage } = stats;\n  if (\n    !type ||\n    type !== 'drawing' ||\n    !word ||\n    !dictionary ||\n    !drawing ||\n    !authorId ||\n    !authorName\n  ) {\n    return null;\n  }\n  return {\n    type: 'drawing',\n    postId,\n    word,\n    dictionary,\n    drawing: JSON.parse(drawing),\n    authorId,\n    authorName,\n    playerCount,\n    solvedPercentage,\n    lastCommentUpdate: lastCommentUpdate\n      ? parseInt(lastCommentUpdate)\n      : undefined,\n  };\n}\n\nexport async function getDrawings(\n  postIds: T3[]\n): Promise<DrawingPostDataExtended[]> {\n  if (postIds.length === 0) return [];\n  const drawings = await Promise.all(\n    postIds.map(async (postId) => await getDrawing(postId))\n  );\n  return drawings.filter(\n    (drawing): drawing is DrawingPostDataExtended => drawing !== null\n  );\n}\n\nexport async function skipDrawing(postId: T3, userId: T2): Promise<void> {\n  const key = REDIS_KEYS.drawingSkips(postId);\n  await redis.zAdd(key, { member: userId, score: Date.now() });\n}\n\nexport async function getDrawingStats(\n  postId: T3\n): Promise<{ playerCount: number; solvedPercentage: number }> {\n  return await cache(\n    async () => {\n      const [playerCount, solvedCount] = await Promise.all([\n        redis.zCard(REDIS_KEYS.drawingAttempts(postId)),\n        redis.zCard(REDIS_KEYS.drawingSolves(postId)),\n      ]);\n      return {\n        playerCount,\n        solvedPercentage:\n          playerCount === 0\n            ? 0\n            : Math.round((solvedCount / playerCount) * 100 * 10) / 10,\n      };\n    },\n    { key: `drawing:stats:${postId}`, ttl: 5 }\n  );\n}\n\nexport async function saveLastCommentUpdate(\n  postId: T3,\n  updatedAt: number\n): Promise<void> {\n  const key = REDIS_KEYS.drawing(postId);\n  await redis.hSet(key, { lastCommentUpdate: updatedAt.toString() });\n}\n\nexport async function saveNextScheduledJobId(\n  postId: T3,\n  jobId: string\n): Promise<void> {\n  const key = REDIS_KEYS.drawing(postId);\n  await redis.hSet(key, { nextScheduledJobId: jobId });\n}\n\nexport async function clearNextScheduledJobId(postId: T3): Promise<void> {\n  const key = REDIS_KEYS.drawing(postId);\n  await redis.hDel(key, ['nextScheduledJobId']);\n}\n\nexport async function handleCommentUpdateCooldown(postId: T3): Promise<void> {\n  const lockKey = REDIS_KEYS.commentUpdateLock(postId);\n  const LOCK_TTL = 30;\n  const ONE_MINUTE = 60 * 1000;\n  const gotLock = await acquireLock(lockKey, LOCK_TTL);\n  if (!gotLock) return;\n  try {\n    const now = Date.now();\n    const [lastUpdate, nextJobId] = await Promise.all([\n      redis.hGet(REDIS_KEYS.drawing(postId), 'lastCommentUpdate'),\n      redis.hGet(REDIS_KEYS.drawing(postId), 'nextScheduledJobId'),\n    ]);\n    const lastUpdateTime = lastUpdate ? parseInt(lastUpdate) : 0;\n    const timeSinceLastUpdate = now - lastUpdateTime;\n    if (timeSinceLastUpdate >= ONE_MINUTE) {\n      if (nextJobId) {\n        try {\n          await scheduler.cancelJob(nextJobId);\n          await clearNextScheduledJobId(postId);\n        } catch (e) {\n          // Ignore cancellation errors\n        }\n      }\n      try {\n        await scheduleCommentUpdate(postId, new Date(now));\n      } catch (e) {\n        // Ignore scheduling errors\n      }\n    } else if (!nextJobId) {\n      const nextUpdateTime = lastUpdateTime + ONE_MINUTE;\n      try {\n        await scheduleCommentUpdate(postId, new Date(nextUpdateTime));\n      } catch (e) {\n        // Ignore scheduling errors\n      }\n    }\n  } finally {\n    try {\n      await redis.del(lockKey);\n    } catch (e) {\n      // Ignore lock release errors\n    }\n  }\n}\n\nexport async function scheduleCommentUpdate(\n  postId: T3,\n  runAt: Date\n): Promise<string> {\n  const jobId = await scheduler.runJob({\n    name: 'UPDATE_DRAWING_PINNED_COMMENT',\n    data: { postId },\n    runAt,\n  });\n  await saveNextScheduledJobId(postId, jobId);\n  return jobId;\n}\n\nexport async function getUserDrawings(\n  userId: T2,\n  limit: number = 20\n): Promise<T3[]> {\n  const drawingIds = await redis.zRange(\n    REDIS_KEYS.userDrawings(userId),\n    0,\n    limit - 1,\n    { reverse: true, by: 'rank' }\n  );\n  return drawingIds.map((entry) => entry.member).filter(isT3);\n}\n\nexport async function getUserDrawingsWithData(\n  userId: T2,\n  limit: number = 20\n): Promise<DrawingPostDataExtended[]> {\n  const drawingIds = await redis.zRange(\n    REDIS_KEYS.userDrawings(userId),\n    0,\n    limit - 1,\n    { reverse: true, by: 'rank' }\n  );\n  const postIds = drawingIds.map((entry) => entry.member).filter(isT3);\n  if (postIds.length === 0) return [];\n  const drawingPromises = postIds.map(async (postId) => {\n    const drawingData = await redis.hGetAll(REDIS_KEYS.drawing(postId));\n    return { postId, drawingData };\n  });\n  const results = await Promise.all(drawingPromises);\n  const drawings: DrawingPostDataExtended[] = [];\n  const validDrawings = results.filter(\n    ({ drawingData }) => drawingData.type === 'drawing' && drawingData.drawing\n  );\n  const statsPromises = validDrawings.map(({ postId }) =>\n    getDrawingStats(postId)\n  );\n  const allStats = await Promise.all(statsPromises);\n  validDrawings.forEach(({ postId, drawingData }, index) => {\n    const stats = allStats[index]!;\n    drawings.push({\n      postId,\n      type: 'drawing',\n      word: drawingData.word || '',\n      dictionary: drawingData.dictionary || '',\n      drawing: JSON.parse(drawingData.drawing || '{}'),\n      authorId: drawingData.authorId as T2,\n      authorName: drawingData.authorName || '',\n      playerCount: stats.playerCount,\n      solvedPercentage: stats.solvedPercentage,\n    });\n  });\n  return drawings;\n}\n\nexport async function submitGuess(options: {\n  postId: T3;\n  userId: T2;\n  guess: string;\n}): Promise<{ correct: boolean; points: number }> {\n  const { postId, userId, guess } = options;\n  const empty = { correct: false, points: 0 };\n  if (await isRateLimited(REDIS_KEYS.rateGuess(userId), 3, 1)) return empty;\n  const [drawingData, solved, skipped] = await Promise.all([\n    getCachedDrawingData(postId),\n    redis.zScore(REDIS_KEYS.drawingSolves(postId), userId),\n    redis.zScore(REDIS_KEYS.drawingSkips(postId), userId),\n  ]);\n  const word = drawingData.word;\n  const drawingNormalizedWord = drawingData.normalizedWord;\n  const authorId = drawingData.authorId;\n  if (\n    !word ||\n    !authorId ||\n    !isT2(authorId) ||\n    solved != null ||\n    skipped != null\n  )\n    return empty;\n  const normalizedGuess = normalizeWord(guess);\n  const normalizedWord = drawingNormalizedWord || normalizeWord(word);\n  const correct = normalizedGuess === normalizedWord;\n  const now = Date.now();\n  const redisOperations: Promise<unknown>[] = [\n    redis.zIncrBy(REDIS_KEYS.drawingAttempts(postId), userId, 1),\n    redis.zIncrBy(REDIS_KEYS.wordDrawings(word), postId, 1),\n    redis.zIncrBy(REDIS_KEYS.drawingGuesses(postId), normalizedGuess, 1),\n  ];\n  if (correct) {\n    redisOperations.push(\n      redis.zAdd(REDIS_KEYS.drawingSolves(postId), {\n        member: userId,\n        score: now,\n      }),\n      incrementScore(userId, GUESSER_REWARD_SOLVE),\n      incrementScore(authorId, AUTHOR_REWARD_CORRECT_GUESS)\n    );\n  }\n  await Promise.all(redisOperations);\n  void handleCommentUpdateCooldown(postId);\n  const channelName = REALTIME_CHANNELS.post(postId);\n  const finalStats = await getGuesses(postId);\n  void realtime.send(channelName, {\n    type: 'guess_submitted',\n    postId,\n    correct,\n    timestamp: now,\n    stats: finalStats,\n  });\n  const points = correct ? GUESSER_REWARD_SOLVE : 0;\n  return { correct, points };\n}\n\nexport async function getGuesses(\n  postId: T3,\n  limit: number = 10\n): Promise<{\n  guesses: Record<string, number>;\n  wordCount: number;\n  guessCount: number;\n  playerCount: number;\n  solvedCount: number;\n}> {\n  const [guesses, stats, solvedCount] = await Promise.all([\n    redis\n      .zRange(REDIS_KEYS.drawingGuesses(postId), 0, limit - 1, {\n        reverse: true,\n        by: 'rank',\n      })\n      .then((guesses) =>\n        guesses.reduce(\n          (acc, guess) => ({ ...acc, [guess.member]: guess.score }),\n          {} as Record<string, number>\n        )\n      ),\n    getDrawingStats(postId),\n    redis.zCard(REDIS_KEYS.drawingSolves(postId)),\n  ]);\n  const guessCount = Object.values(guesses).reduce(\n    (sum, count) => sum + count,\n    0\n  );\n  const wordCount = Object.keys(guesses).length;\n  const words = Object.keys(guesses);\n  const showChecks = await Promise.all(\n    words.map((word) => shouldShowWord(word))\n  );\n  const obfuscatedGuesses: Record<string, number> = {};\n  words.forEach((word, i) => {\n    const displayWord = showChecks[i] ? word : obfuscateString(word);\n    obfuscatedGuesses[displayWord] = guesses[word]!;\n  });\n  return {\n    guesses: obfuscatedGuesses,\n    wordCount,\n    guessCount,\n    playerCount: stats.playerCount,\n    solvedCount,\n  };\n}\n\nexport async function getDrawingCommentData(postId: T3): Promise<{\n  solves: number;\n  solvedPercentage: number;\n  skips: number;\n  skipPercentage: number;\n  wordCount: number;\n  guessCount: number;\n  playerCount: number;\n  guesses: { word: string; count: number }[];\n}> {\n  const [playerCount, solvedCount, skippedCount, wordCount, guesses] =\n    await Promise.all([\n      redis.zCard(REDIS_KEYS.drawingAttempts(postId)),\n      redis.zCard(REDIS_KEYS.drawingSolves(postId)),\n      redis.zCard(REDIS_KEYS.drawingSkips(postId)),\n      redis.zCard(REDIS_KEYS.drawingGuesses(postId)),\n      redis.zRange(REDIS_KEYS.drawingGuesses(postId), 0, -1, {\n        reverse: true,\n        by: 'rank',\n      }),\n    ]);\n  const solvedPercentage =\n    playerCount === 0\n      ? 0\n      : Math.round((solvedCount / playerCount) * 100 * 10) / 10;\n  const skipPercentage =\n    playerCount === 0\n      ? 0\n      : Math.round((skippedCount / playerCount) * 100 * 10) / 10;\n  const guessesParsed = guesses.map((guess) => ({\n    word: guess.member,\n    count: guess.score,\n  }));\n  const guessCount = guessesParsed.reduce((sum, guess) => sum + guess.count, 0);\n  return {\n    solves: solvedCount,\n    solvedPercentage,\n    skips: skippedCount,\n    skipPercentage,\n    wordCount,\n    guessCount,\n    playerCount,\n    guesses: guessesParsed,\n  };\n}\n\ntype DrawingCommentStats = {\n  playerCount: number;\n  guessCount: number;\n  wordCount: number;\n  skips: number;\n  skipPercentage: number;\n  solves: number;\n  solvedPercentage: number;\n};\n\ntype CommentSection = {\n  content: string;\n  condition?: (stats: DrawingCommentStats) => boolean;\n};\n\nexport async function createDrawingPostComment(postId: T3): Promise<T1> {\n  const commentText = generateDrawingCommentText();\n  const id = await createPinnedComment(postId, commentText);\n  await saveLastCommentUpdate(postId, Date.now());\n  return id;\n}\n\nexport async function updateDrawingPostComment(postId: T3): Promise<void> {\n  const postData = await getDrawing(postId);\n  if (!postData) {\n    throw new Error(`Post data not found for ${postId}`);\n  }\n  const stats = await getDrawingCommentData(postId);\n  const commentText = generateDrawingCommentText(stats);\n  await updatePinnedComment(postId, commentText);\n  await saveLastCommentUpdate(postId, Date.now());\n  await clearNextScheduledJobId(postId);\n}\n\nexport function generateDrawingCommentText(\n  stats?: DrawingCommentStats\n): string {\n  const sections: CommentSection[] = [\n    {\n      content: `Pixelary is a community drawing game. Submit your guess in the post above!`,\n    },\n    {\n      content: generateDifficultySection(stats),\n      condition: (stats) => stats.guessCount >= 100,\n    },\n    { content: generateLiveStatsSection(stats), condition: () => !!stats },\n    {\n      content: `Comment commands:\\n- \\`!words\\` - See dictionary\\n- \\`!add <word>\\` - Add word to dictionary\\n- \\`!show <word>\\` - Check guess stats\\n- \\`!help\\` - All commands`,\n    },\n    { content: `Good luck and thanks for playing!` },\n  ];\n  return sections\n    .filter(\n      (section) => !section.condition || (stats && section.condition(stats))\n    )\n    .map((section) => section.content)\n    .join('\\n\\n');\n}\n\nfunction generateDifficultySection(\n  stats: DrawingCommentStats | undefined\n): string {\n  if (!stats) return '';\n  const difficultyScore =\n    stats.playerCount > 0\n      ? Math.round((stats.guessCount / stats.playerCount) * 10) / 10\n      : 0;\n  const difficultyLevel =\n    difficultyScore < 2\n      ? ' Easy'\n      : difficultyScore < 4\n        ? ' Medium'\n        : difficultyScore < 6\n          ? ' Hard'\n          : ' Expert';\n  return `Difficulty: ${difficultyLevel} (${difficultyScore}/10)`;\n}\n\nfunction generateLiveStatsSection(\n  stats: DrawingCommentStats | undefined\n): string {\n  if (!stats) return '';\n  const avgGuessesPerPlayer =\n    stats.playerCount > 0\n      ? Math.round((stats.guessCount / stats.playerCount) * 10) / 10\n      : 0;\n  return `Live stats:\\n- ${stats.playerCount} unique players guessed\\n- ${stats.guessCount} total guesses (avg ${avgGuessesPerPlayer} per player)\\n- ${stats.wordCount} unique words guessed\\n- ${stats.skips} skips (${stats.skipPercentage}% skip rate)\\n- ${stats.solves} solves (${stats.solvedPercentage}% solved rate)`;\n}\n\nexport async function getUserDrawingStatus(\n  postId: T3,\n  userId: T2\n): Promise<{ solved: boolean; skipped: boolean; guessCount: number }> {\n  const [solved, skipped, guesses] = await Promise.all([\n    redis.zScore(REDIS_KEYS.drawingSolves(postId), userId),\n    redis.zScore(REDIS_KEYS.drawingSkips(postId), userId),\n    redis.zRange(REDIS_KEYS.drawingGuesses(postId), 0, -1, { by: 'rank' }),\n  ]);\n  const guessCount = guesses.reduce((sum, g) => sum + g.score, 0);\n  return { solved: solved != null, skipped: skipped != null, guessCount };\n}\n\nexport async function isAuthorFirstView(postId: T3): Promise<boolean> {\n  const key = REDIS_KEYS.authorViews(postId);\n  const views = await redis.incrBy(key, 1);\n  return views === 1;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/pinned.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/award.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 45,
        "column": 18,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 45,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
        "severity": 1,
        "message": "Passing a string to String() does not change the type or value of the string.",
        "line": 45,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unnecessaryTypeConversion",
        "endLine": 45,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestRemove",
            "fix": { "range": [1431, 1442], "text": "key" },
            "desc": "Remove the type conversion."
          },
          {
            "messageId": "suggestSatisfies",
            "data": { "type": "string" },
            "fix": { "range": [1431, 1442], "text": "(key satisfies string)" },
            "desc": "Instead, assert that the value satisfies the string type."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 65,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 65,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [1963, 1965], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 72,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 72,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [2131, 2133], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 80,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 80,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [2321, 2323], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 86,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 86,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [2473, 2475], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect, vi, beforeEach } from 'vitest';\n\nvi.mock('@devvit/web/server', () => ({\n  redis: {\n    zCard: vi.fn(),\n    zRange: vi.fn(),\n    hGetAll: vi.fn(),\n  },\n  reddit: {\n    submitComment: vi.fn(),\n    getUserById: vi.fn(async () => ({ username: 'testuser' })),\n  },\n  cache: vi.fn((fn) => fn()),\n}));\n\nvi.mock('@server/services/progression', () => ({\n  incrementScore: vi.fn(),\n}));\n\nimport { redis } from '@devvit/web/server';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { awardTournamentRewards } from './award';\nimport { incrementScore } from '@server/services/progression';\nimport {\n  TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT,\n  TOURNAMENT_PAYOUT_LADDER_FIRST,\n  TOURNAMENT_PAYOUT_LADDER_SECOND,\n} from '@shared/constants';\n\ndescribe('awardTournamentRewards (snapshot engine)', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('awards top-% base reward and ladder bonuses', async () => {\n    vi.mocked(redis.zCard).mockResolvedValue(10);\n    vi.mocked(redis.zRange).mockResolvedValue([\n      { member: 't1_a', score: 1600 },\n      { member: 't1_b', score: 1500 },\n      { member: 't1_c', score: 1400 },\n      { member: 't1_d', score: 1300 },\n    ] as unknown as Array<{ member: string; score: number }>);\n    // getTournamentEntry is called via hGetAll path in module; mock hGetAll\n    vi.mocked(redis.hGetAll).mockImplementation(async (key: string) => {\n      const id = String(key).split(':').pop()!;\n      return {\n        drawing: JSON.stringify({}),\n        userId: `t2_${id}`,\n        postId: 't3_x',\n        mediaUrl: 'u',\n        mediaId: 'm',\n        votes: '0',\n        views: '0',\n      } as unknown as Record<string, string>;\n    });\n\n    await awardTournamentRewards('t3_x' as T3);\n\n    // cutoff 20% of 10 = 2  users for t1_a, t1_b\n    const calls = vi.mocked(incrementScore).mock.calls;\n    // Expect base rewards for both top 2\n    expect(\n      calls.some(\n        (c) =>\n          c[0]?.startsWith('t2_t1_a') &&\n          c[1] === TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT\n      )\n    ).toBe(true);\n    expect(\n      calls.some(\n        (c) =>\n          c[0]?.startsWith('t2_t1_b') &&\n          c[1] === TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT\n      )\n    ).toBe(true);\n    // Ladder bonuses\n    expect(\n      calls.some(\n        (c) =>\n          c[0]?.startsWith('t2_t1_a') && c[1] === TOURNAMENT_PAYOUT_LADDER_FIRST\n      )\n    ).toBe(true);\n    expect(\n      calls.some(\n        (c) =>\n          c[0]?.startsWith('t2_t1_b') &&\n          c[1] === TOURNAMENT_PAYOUT_LADDER_SECOND\n      )\n    ).toBe(true);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/award.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 45,
        "column": 25,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 45,
        "endColumn": 43,
        "fix": { "range": [1498, 1516], "text": "Array<Promise<unknown>>" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `10 > 0` is true.",
        "line": 52,
        "column": 9,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 52,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `30 > 0` is true.",
        "line": 58,
        "column": 20,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 58,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `20 > 0` is true.",
        "line": 62,
        "column": 27,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 62,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `10 > 0` is true.",
        "line": 66,
        "column": 27,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 66,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import type { T1, T3 } from '@devvit/shared-types/tid.js';\nimport { redis } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport {\n  TOURNAMENT_PAYOUT_LADDER_FIRST,\n  TOURNAMENT_PAYOUT_LADDER_SECOND,\n  TOURNAMENT_PAYOUT_LADDER_THIRD,\n  TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT,\n  TOURNAMENT_PAYOUT_TOP_PERCENT,\n} from '@shared/constants';\nimport { incrementScore } from '@server/services/progression';\nimport { getTournamentEntry } from './post';\nimport { buildTournamentPayoutSummary } from './summary';\n\n/**\n * Awards per-snapshot tournament rewards using current ELO standings.\n * - Pays a base amount to top N% (min 1)\n * - Adds ladder bonuses for ranks 1, 2, and 3\n */\nexport async function awardTournamentRewards(\n  postId: T3,\n  options?: { manual?: boolean; dayIndex?: number }\n): Promise<{ summary: string }> {\n  const entryCount = await redis.zCard(REDIS_KEYS.tournamentEntries(postId));\n  if (entryCount === 0) {\n    return {\n      summary: options?.manual ? 'Manual payout executed.' : 'Payout executed.',\n    };\n  }\n\n  const percent = Math.max(0, Math.min(100, TOURNAMENT_PAYOUT_TOP_PERCENT));\n  const cutoff = Math.max(1, Math.floor((entryCount * percent) / 100));\n\n  const entries = await redis.zRange(\n    REDIS_KEYS.tournamentEntries(postId),\n    0,\n    cutoff - 1,\n    { by: 'score', reverse: true }\n  );\n\n  const entryData = await Promise.all(\n    entries.map(async (entry) => await getTournamentEntry(entry.member as T1))\n  );\n\n  const rewardPromises: Promise<unknown>[] = [];\n  for (let i = 0; i < cutoff; i++) {\n    const score = entries[i];\n    const data = entryData[i];\n    if (!score || !data) continue;\n    const userId = data.userId;\n\n    if (TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT > 0) {\n      rewardPromises.push(\n        incrementScore(userId, TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT)\n      );\n    }\n\n    if (i === 0 && TOURNAMENT_PAYOUT_LADDER_FIRST > 0) {\n      rewardPromises.push(\n        incrementScore(userId, TOURNAMENT_PAYOUT_LADDER_FIRST)\n      );\n    } else if (i === 1 && TOURNAMENT_PAYOUT_LADDER_SECOND > 0) {\n      rewardPromises.push(\n        incrementScore(userId, TOURNAMENT_PAYOUT_LADDER_SECOND)\n      );\n    } else if (i === 2 && TOURNAMENT_PAYOUT_LADDER_THIRD > 0) {\n      rewardPromises.push(\n        incrementScore(userId, TOURNAMENT_PAYOUT_LADDER_THIRD)\n      );\n    }\n  }\n\n  await Promise.all(rewardPromises);\n\n  const summary = await buildTournamentPayoutSummary(postId, options);\n  return { summary };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/comments.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/elo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/hopper.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 46,
        "column": 10,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 46,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [1661, 1662], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { context, redis } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport { normalizeWord } from '@shared/utils/string';\n\nexport async function getHopperPrompts(\n  offset: number = 0,\n  limit: number = 1000\n): Promise<{ prompts: string[]; total: number; hasMore: boolean }> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.tournamentHopper(subName);\n  const [entities, total] = await Promise.all([\n    redis.global.zRange(key, offset, offset + limit - 1),\n    redis.global.zCard(key),\n  ]);\n  const prompts = entities.map((e) => e.member);\n  return { prompts, total, hasMore: offset + limit < total };\n}\n\nexport async function replaceHopperPrompts(prompts: string[]): Promise<void> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.tournamentHopper(subName);\n  await redis.global.del(key);\n  if (prompts.length === 0) return;\n  await addHopperPrompts(prompts);\n}\n\nexport async function addHopperPrompts(prompts: string[]): Promise<void> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.tournamentHopper(subName);\n  const now = Date.now();\n  const normalized = prompts\n    .map((p) => normalizeWord(p))\n    .filter((p) => p && p.length > 0);\n  if (normalized.length === 0) return;\n  await redis.global.zAdd(\n    key,\n    ...normalized.map((p, idx) => ({ member: p, score: now + idx }))\n  );\n}\n\nexport async function peekNextHopperPrompt(): Promise<string | null> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.tournamentHopper(subName);\n  const result = await redis.global.zRange(key, 0, 0);\n  if (result.length === 0) return null;\n  return result[0]!.member;\n}\n\nexport async function removeHopperPrompt(prompt: string): Promise<boolean> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.tournamentHopper(subName);\n  const normalized = normalizeWord(prompt);\n  const removed = await redis.global.zRem(key, [normalized]);\n  return removed > 0;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/pairs.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 20,
        "column": 12,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 20,
        "endColumn": 52,
        "fix": {
          "range": [760, 800],
          "text": "Array<[TournamentDrawing, TournamentDrawing]>"
        }
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 24,
        "column": 18,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 24,
        "endColumn": 28,
        "fix": { "range": [967, 977], "text": "Array<[T1, T1]>" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 37,
        "column": 9,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 37,
        "endColumn": 38,
        "fix": { "range": [1324, 1353], "text": "lastPair?.[0] === a" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 52,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "alwaysTruthy",
        "endLine": 52,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import type { T1, T3 } from '@devvit/shared-types/tid.js';\nimport { shuffle } from '@shared/utils/array';\nimport type { TournamentDrawing } from './post';\nimport { getTournamentEntries, getTournamentEntry } from './post';\n\nexport async function getRandomPair(postId: T3): Promise<[T1, T1]> {\n  const submissions = await getTournamentEntries(postId);\n  if (submissions.length < 2)\n    throw new Error('Not enough submissions for voting');\n  const shuffled = [...submissions].sort(() => Math.random() - 0.5);\n  const first = shuffled[0];\n  const second = shuffled[1];\n  if (!first || !second) throw new Error('Failed to select random submissions');\n  return [first, second];\n}\n\nexport async function getDrawingPairs(\n  postId: T3,\n  count: number = 5\n): Promise<[TournamentDrawing, TournamentDrawing][]> {\n  const submissions = await getTournamentEntries(postId);\n  if (submissions.length < 2)\n    throw new Error('Not enough submissions for voting');\n  const pairIds: [T1, T1][] = [];\n  let pool = shuffle(submissions);\n  let idx = 0;\n  while (pairIds.length < count) {\n    if (idx + 1 >= pool.length) {\n      pool = shuffle(submissions);\n      idx = 0;\n    }\n    const a = pool[idx];\n    const b = pool[idx + 1];\n    idx += 2;\n    if (!a || !b || a === b) continue;\n    const lastPair = pairIds[pairIds.length - 1];\n    if (lastPair && lastPair[0] === a && lastPair[1] === b) {\n      pairIds.push([b, a]);\n    } else if (lastPair && (lastPair[0] === a || lastPair[1] === b)) {\n      continue;\n    } else {\n      pairIds.push([a, b]);\n    }\n  }\n  const uniqueIds = [...new Set(pairIds.flat())];\n  const fetchedData = await Promise.all(\n    uniqueIds.map((id) => getTournamentEntry(id))\n  );\n  const dataMap = new Map<T1, Awaited<ReturnType<typeof getTournamentEntry>>>();\n  uniqueIds.forEach((id, i) => {\n    const data = fetchedData[i];\n    if (id && data) dataMap.set(id, data);\n  });\n  const pairs: Array<[TournamentDrawing, TournamentDrawing]> = [];\n  for (const [firstId, secondId] of pairIds) {\n    const leftData = dataMap.get(firstId);\n    const rightData = dataMap.get(secondId);\n    if (!leftData || !rightData) continue;\n    pairs.push([\n      { ...leftData, commentId: firstId },\n      { ...rightData, commentId: secondId },\n    ]);\n  }\n  return pairs;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/post.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/post.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 53,
        "column": 22,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 53,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 89,
        "column": 16,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 89,
        "endColumn": 34,
        "fix": { "range": [2651, 2669], "text": "Array<Promise<unknown>>" }
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 93,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "invalid",
        "endLine": 93,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 132,
        "column": 25,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 132,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3884, 3886], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 133,
        "column": 25,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 133,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3915, 3917], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 135,
        "column": 40,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 135,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [3986, 3988], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 189,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 189,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [5204, 5206], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 189,
        "column": 38,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 189,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 190,
        "column": 49,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 190,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since the receiver accepts the original type of the expression.",
        "line": 190,
        "column": 49,
        "nodeType": "TSNonNullExpression",
        "messageId": "contextuallyUnnecessary",
        "endLine": 190,
        "endColumn": 64,
        "fix": { "range": [5286, 5287], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 210,
        "column": 13,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 210,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 225,
        "column": 57,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 225,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since the receiver accepts the original type of the expression.",
        "line": 225,
        "column": 57,
        "nodeType": "TSNonNullExpression",
        "messageId": "contextuallyUnnecessary",
        "endLine": 225,
        "endColumn": 72,
        "fix": { "range": [6466, 6467], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 280,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 280,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 284,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "invalid",
        "endLine": 284,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 321,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 321,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9300, 9302], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 322,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 322,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [9340, 9342], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 3,
    "source": "import type { T2, T3, T1 } from '@devvit/shared-types/tid.js';\nimport {\n  reddit,\n  redis,\n  media,\n  context,\n  scheduler,\n  cache,\n} from '@devvit/web/server';\nimport type { MediaAsset } from '@devvit/web/server';\nimport { createPost, setPostFlair } from '@server/core';\nimport {\n  REDIS_KEYS,\n  acquireLock,\n  releaseLock,\n  isRateLimited,\n} from '@server/core/redis';\nimport { getRandomWords } from '@server/services/words/dictionary';\nimport type { DrawingData, TournamentPostData } from '@shared/schema';\nimport {\n  TOURNAMENT_REWARD_VOTE,\n  TOURNAMENT_ELO_INITIAL_RATING,\n  TOURNAMENT_PAYOUT_SNAPSHOT_COUNT,\n  TOURNAMENT_PAYOUT_INTERVAL_HOURS,\n} from '@shared/constants';\nimport { calculateEloChange } from './elo';\nimport { incrementScore } from '@server/services/progression';\nimport { normalizeWord } from '@shared/utils/string';\nimport { generateTournamentCommentText } from '@server/services/posts/tournament/comments';\nimport { createPinnedComment } from '@server/services/comments/pinned';\n\nexport type TournamentDrawing = {\n  commentId: T1;\n  drawing: DrawingData;\n  userId: T2;\n  postId: T3;\n  votes: number;\n  views: number;\n  mediaUrl: string;\n  mediaId: string;\n};\n\n/**\n * Creates a tournament post.\n * @param word - The word for the tournament.\n * @returns The ID of the post.\n */\n\nexport async function createTournament(word?: string): Promise<T3> {\n  let tournamentWord = word ? normalizeWord(word) : undefined;\n  if (!tournamentWord || tournamentWord.trim() === '') {\n    const words = await getRandomWords(1);\n    tournamentWord = words[0]!;\n  }\n  const postData: TournamentPostData = {\n    type: 'tournament',\n    word: tournamentWord,\n  };\n  const tournamentIndex = await redis.incrBy(\n    REDIS_KEYS.tournamentsCounter(),\n    1\n  );\n  const post = await createPost(\n    `Drawing Tournament #${tournamentIndex}: ${tournamentWord}`,\n    postData\n  );\n  if (!post) throw new Error('Failed to create tournament post');\n  await setPostFlair(post.id, context.subredditName, 'tournament');\n  await Promise.all([\n    redis.hSet(REDIS_KEYS.tournament(post.id), {\n      ...postData,\n      createdAt: post.createdAt.getTime().toString(),\n      votes: '0',\n    }),\n    redis.zAdd(REDIS_KEYS.tournaments(), {\n      member: post.id,\n      score: post.createdAt.getTime(),\n    }),\n  ]);\n  // Create tournament pinned comment synchronously to ensure availability\n  try {\n    const text = generateTournamentCommentText(tournamentWord);\n    await createPinnedComment(post.id, text);\n  } catch (error) {\n    console.error('Failed to create tournament pinned comment:', error);\n  }\n  // Schedule payout snapshots (daily)\n  try {\n    const ops: Promise<unknown>[] = [];\n    const hoursToMs = (h: number) => h * 60 * 60 * 1000;\n    for (let day = 1; day <= TOURNAMENT_PAYOUT_SNAPSHOT_COUNT; day++) {\n      const runAt = new Date(\n        post.createdAt.getTime() +\n          day * hoursToMs(TOURNAMENT_PAYOUT_INTERVAL_HOURS)\n      );\n      ops.push(\n        scheduler.runJob({\n          name: 'TOURNAMENT_PAYOUT_SNAPSHOT',\n          data: { postId: post.id, dayIndex: day },\n          runAt,\n        })\n      );\n    }\n    await Promise.all(ops);\n  } catch (error) {\n    console.error('Failed to schedule tournament payouts:', error);\n  }\n  return post.id;\n}\n\n/**\n * Gets the tournament data for a post.\n * @param postId - The ID of the post.\n * @returns The tournament data.\n */\n\nexport async function getTournament(postId: T3): Promise<{\n  word: string;\n  type: string;\n  submissionCount: number;\n  voteCount: number;\n  playerCount: number;\n}> {\n  return await cache(\n    async () => {\n      const [data, submissionCount, playerCount] = await Promise.all([\n        redis.hGetAll(REDIS_KEYS.tournament(postId)),\n        redis.zCard(REDIS_KEYS.tournamentEntries(postId)),\n        redis.zCard(REDIS_KEYS.tournamentPlayers(postId)),\n      ]);\n      return {\n        word: data.word || '',\n        type: data.type || '',\n        submissionCount,\n        voteCount: parseInt(data.votes || '0'),\n        playerCount,\n      };\n    },\n    { key: `tournament:stats:${postId}`, ttl: 10 }\n  );\n}\n\n/**\n * Gets the rating for a tournament entry.\n * @param postId - The ID of the post.\n * @param commentId - The ID of the comment.\n * @returns The rating.\n */\n\nexport async function getEntryRating(\n  postId: T3,\n  commentId: T1\n): Promise<number> {\n  const rating = await redis.zScore(\n    REDIS_KEYS.tournamentEntries(postId),\n    commentId\n  );\n  return rating ?? TOURNAMENT_ELO_INITIAL_RATING;\n}\n\n/**\n * Gets the tournament entries for a post.\n * @param postId - The ID of the post.\n * @returns The tournament entries.\n */\n\nexport async function getTournamentEntries(postId: T3): Promise<T1[]> {\n  const commentIds = await redis.zRange(\n    REDIS_KEYS.tournamentEntries(postId),\n    0,\n    -1\n  );\n  return commentIds.map((item) => item.member as T1);\n}\n\n/**\n * Submits a tournament entry.\n * @param drawing - The drawing data.\n * @param imageData - The image data.\n * @param postId - The ID of the post.\n * @returns The ID of the comment.\n */\n\nexport async function submitTournamentEntry(\n  drawing: DrawingData,\n  imageData: string,\n  tournamentPostId?: T3\n): Promise<T1> {\n  const postId = tournamentPostId || context.postId!;\n  if (await isRateLimited(REDIS_KEYS.rateSubmit(context.userId!), 2, 10)) {\n    throw new Error('Too many submissions, slow down');\n  }\n  let response: MediaAsset;\n  try {\n    response = await media.upload({ url: imageData, type: 'image' });\n  } catch (mediaError) {\n    const mediaErrorMessage =\n      mediaError instanceof Error ? mediaError.message : String(mediaError);\n    throw new Error(`Failed to upload image: ${mediaErrorMessage}`);\n  }\n  const comment = await reddit.submitComment({\n    text: `[My submission](${response.mediaUrl})`,\n    id: postId,\n    runAs: 'USER',\n  });\n  if (!comment) throw new Error('Failed to submit comment');\n  const entryKey = REDIS_KEYS.tournamentEntry(comment.id);\n  const entryData = {\n    postId: postId,\n    userId: context.userId!,\n    commentId: comment.id,\n    drawing: JSON.stringify(drawing),\n    mediaUrl: response.mediaUrl,\n    mediaId: response.mediaId,\n    votes: '0',\n    views: '0',\n  };\n  const sortedSetKey = REDIS_KEYS.tournamentEntries(postId);\n  await Promise.all([\n    redis.zAdd(sortedSetKey, {\n      member: comment.id,\n      score: TOURNAMENT_ELO_INITIAL_RATING,\n    }),\n    redis.hSet(entryKey, entryData),\n    redis.zIncrBy(REDIS_KEYS.tournamentPlayers(postId), context.userId!, 1),\n  ]);\n  return comment.id;\n}\n\n/**\n * Votes for a tournament entry.\n * @param winnerId - The ID of the winner.\n * @param loserId - The ID of the loser.\n */\n\nexport async function tournamentVote(winnerId: T1, loserId: T1): Promise<void> {\n  const { postId, userId } = context;\n  if (!postId || !userId)\n    throw new Error('Must be in a tournament post and logged in');\n  if (await isRateLimited(REDIS_KEYS.rateVote(userId), 3, 1)) return;\n  const [winnerRating, loserRating, _score, _playerCount, _votes] =\n    await Promise.all([\n      getEntryRating(postId, winnerId),\n      getEntryRating(postId, loserId),\n      incrementScore(userId, TOURNAMENT_REWARD_VOTE),\n      redis.zIncrBy(REDIS_KEYS.tournamentPlayers(postId), userId, 1),\n      redis.hIncrBy(REDIS_KEYS.tournament(postId), 'votes', 1),\n      redis.hIncrBy(REDIS_KEYS.tournamentEntry(winnerId), 'votes', 1),\n    ]);\n  const eloLockKey = REDIS_KEYS.tournamentEloLock(postId);\n  const gotLock = await acquireLock(eloLockKey, 2);\n  try {\n    if (gotLock) {\n      const [latestWinner, latestLoser] = await Promise.all([\n        getEntryRating(postId, winnerId),\n        getEntryRating(postId, loserId),\n      ]);\n      const { winnerChange, loserChange } = calculateEloChange(\n        latestWinner,\n        latestLoser\n      );\n      await Promise.all([\n        redis.zAdd(REDIS_KEYS.tournamentEntries(postId), {\n          member: winnerId,\n          score: latestWinner + winnerChange,\n        }),\n        redis.zAdd(REDIS_KEYS.tournamentEntries(postId), {\n          member: loserId,\n          score: latestLoser + loserChange,\n        }),\n      ]);\n    } else {\n      const { winnerChange, loserChange } = calculateEloChange(\n        winnerRating,\n        loserRating\n      );\n      await Promise.all([\n        redis.zAdd(REDIS_KEYS.tournamentEntries(postId), {\n          member: winnerId,\n          score: winnerRating + winnerChange,\n        }),\n        redis.zAdd(REDIS_KEYS.tournamentEntries(postId), {\n          member: loserId,\n          score: loserRating + loserChange,\n        }),\n      ]);\n    }\n  } finally {\n    if (gotLock) {\n      await releaseLock(eloLockKey);\n    }\n  }\n}\n\n/**\n * Gets a tournament entry.\n * @param commentId - The ID of the comment.\n * @returns The tournament entry.\n */\n\nexport async function getTournamentEntry(\n  commentId: T1\n): Promise<TournamentDrawing | undefined> {\n  const key = REDIS_KEYS.tournamentEntry(commentId);\n  const data = await redis.hGetAll(key);\n  if (\n    !data.drawing ||\n    !data.userId ||\n    !data.postId ||\n    !data.mediaUrl ||\n    !data.mediaId\n  ) {\n    console.error('Tournament entry missing required fields:', data);\n    return undefined;\n  }\n  return {\n    commentId,\n    drawing: JSON.parse(data.drawing),\n    userId: data.userId as T2,\n    postId: data.postId as T3,\n    votes: parseInt(data.votes || '0'),\n    views: parseInt(data.views || '0'),\n    mediaUrl: data.mediaUrl,\n    mediaId: data.mediaId,\n  };\n}\n\n/**\n * Removes a tournament entry.\n * @param postId - The ID of the post.\n * @param commentId - The ID of the comment.\n */\n\nexport async function removeTournamentEntry(\n  postId: T3,\n  commentId: T1\n): Promise<void> {\n  const entry = await getTournamentEntry(commentId);\n  await Promise.all([\n    redis.zRem(REDIS_KEYS.tournamentEntries(postId), [commentId]),\n    redis.del(REDIS_KEYS.tournamentEntry(commentId)),\n  ]);\n  if (entry) {\n    try {\n      await redis.zIncrBy(\n        REDIS_KEYS.tournamentPlayers(postId),\n        entry.userId,\n        -1\n      );\n    } catch {\n      // best-effort decrement\n    }\n  }\n}\n\n/**\n * Increments the view counter for a tournament entry.\n */\nexport async function incrementEntryViews(commentId: T1): Promise<void> {\n  const key = REDIS_KEYS.tournamentEntry(commentId);\n  try {\n    await redis.hIncrBy(key, 'views', 1);\n  } catch {\n    // best-effort increment\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/posts/tournament/summary.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 19,
        "column": 16,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 19,
        "endColumn": 51,
        "fix": {
          "range": [660, 695],
          "text": "Array<{ member: string; score: number }>"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `10 > 0` is true.",
        "line": 53,
        "column": 7,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 53,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `30 > 0` is true.",
        "line": 56,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 56,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `20 > 0` is true.",
        "line": 58,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 58,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `10 > 0` is true.",
        "line": 60,
        "column": 19,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 60,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import type { T1, T3 } from '@devvit/shared-types/tid.js';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport { getTournamentEntry } from '@server/services/posts/tournament/post';\nimport { getUsername } from '@server/core/user';\nimport {\n  TOURNAMENT_PAYOUT_SNAPSHOT_COUNT,\n  TOURNAMENT_PAYOUT_TOP_PERCENT,\n  TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT,\n  TOURNAMENT_PAYOUT_LADDER_FIRST,\n  TOURNAMENT_PAYOUT_LADDER_SECOND,\n  TOURNAMENT_PAYOUT_LADDER_THIRD,\n} from '@shared/constants';\n\nexport async function buildTournamentPayoutSummary(\n  postId: T3,\n  options?: { dayIndex?: number; manual?: boolean }\n): Promise<string> {\n  let entryCount = 0;\n  let entries: { member: string; score: number }[] = [];\n  try {\n    const { redis } = await import('@devvit/web/server');\n    entryCount = await redis.zCard(REDIS_KEYS.tournamentEntries(postId));\n    entries = await redis.zRange(REDIS_KEYS.tournamentEntries(postId), 0, -1, {\n      by: 'score',\n      reverse: true,\n    });\n  } catch {\n    return options?.manual ? 'Manual payout executed.' : 'Payout executed.';\n  }\n\n  const percent = Math.max(0, Math.min(100, TOURNAMENT_PAYOUT_TOP_PERCENT));\n  const cutoff = Math.max(1, Math.floor((entryCount * percent) / 100));\n  const entryData = await Promise.all(\n    entries\n      .slice(0, cutoff)\n      .map(async (e) => getTournamentEntry(e.member as T1))\n  );\n  const top3 = entryData\n    .filter((d): d is NonNullable<typeof d> => Boolean(d))\n    .slice(0, 3);\n  const names = await Promise.all(top3.map((d) => getUsername(d.userId)));\n\n  const parts: string[] = [];\n  if (options?.manual) {\n    parts.push(`Manual payout: paid top ${percent}% (${cutoff})`);\n  } else if (options?.dayIndex) {\n    parts.push(\n      `Day ${options.dayIndex}/${TOURNAMENT_PAYOUT_SNAPSHOT_COUNT}: paid top ${percent}% (${cutoff})`\n    );\n  } else {\n    parts.push(`Payout: paid top ${percent}% (${cutoff})`);\n  }\n  if (TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT > 0) {\n    parts.push(` +${TOURNAMENT_PAYOUT_REWARD_TOP_PERCENT} each`);\n  }\n  if (names[0] && TOURNAMENT_PAYOUT_LADDER_FIRST > 0)\n    parts.push(` | 1st +${TOURNAMENT_PAYOUT_LADDER_FIRST} (u/${names[0]})`);\n  if (names[1] && TOURNAMENT_PAYOUT_LADDER_SECOND > 0)\n    parts.push(`, 2nd +${TOURNAMENT_PAYOUT_LADDER_SECOND} (u/${names[1]})`);\n  if (names[2] && TOURNAMENT_PAYOUT_LADDER_THIRD > 0)\n    parts.push(`, 3rd +${TOURNAMENT_PAYOUT_LADDER_THIRD} (u/${names[2]})`);\n\n  return parts.join('');\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/progression.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/progression.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 41,
        "column": 9,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 41,
        "endColumn": 40,
        "fix": {
          "range": [1093, 1124],
          "text": "Array<{ member: T2; score: number }>"
        }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 48,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "neverNullish",
        "endLine": 48,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 98,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "neverNullish",
        "endLine": 98,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 144,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "neverNullish",
        "endLine": 144,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { redis, scheduler, context, realtime } from '@devvit/web/server';\nimport { REDIS_KEYS } from '../core/redis';\nimport { getUsername } from '../core/user';\nimport { getLevelByScore as getLevelByScoreUtil } from '@shared/utils/progression';\nimport type { T2 } from '@devvit/shared-types/tid.js';\nimport type { Level } from '@shared/types';\n\n/**\n * Leaderboard and scoring service for Pixelary\n * Handles user scores, levels, and leaderboard operations\n */\n\n/**\n * Get the leaderboard\n * @param limit - The number of entries to return\n * @returns The leaderboard entries\n */\n\nexport async function getLeaderboard(options?: {\n  cursor?: number;\n  limit?: number;\n  reverse?: boolean;\n  by?: 'rank' | 'score' | 'lex';\n}): Promise<{\n  entries: Array<{\n    username: string;\n    userId: T2;\n    score: number;\n    rank: number;\n  }>;\n  nextCursor: number;\n}> {\n  const { cursor = 0, limit = 10, reverse = true, by = 'rank' } = options ?? {};\n\n  // Fetch from Redis\n  const entries = (await redis.zRange(\n    REDIS_KEYS.scores(),\n    cursor,\n    cursor + limit - 1,\n    { reverse, by }\n  )) as { member: T2; score: number }[];\n\n  // Hydrate with usernames (getUsername is already cached for 30 days)\n  const data = await Promise.all(\n    entries.map(async (entry, index) => {\n      const username = await getUsername(entry.member);\n      return {\n        username: username ?? 'Unknown',\n        userId: entry.member,\n        score: entry.score,\n        rank: cursor + index + 1,\n      };\n    })\n  );\n\n  return {\n    entries: data,\n    nextCursor: data.length === limit ? cursor + limit : -1,\n  };\n}\n\n/**\n * Get the score for a user\n * @param userId - The user ID\n * @returns The user score\n */\n\nexport async function getScore(userId: T2): Promise<number> {\n  const key = REDIS_KEYS.scores();\n  const score = await redis.zScore(key, userId);\n  return score ?? 0; // Default to 0 if user not found\n}\n\n/**\n * Set the exact score for a user\n * @param userId - The user ID\n * @param score - The exact score to set\n * @returns The score that was set\n */\n\nexport async function setScore(userId: T2, score: number): Promise<number> {\n  const key = REDIS_KEYS.scores();\n  const oldScore = await getScore(userId);\n  await redis.zAdd(key, { member: userId, score });\n  const level = getLevelByScore(score);\n  const oldLevel = getLevelByScore(oldScore);\n\n  // Update claimed level if user leveled up\n  if (level.rank > oldLevel.rank) {\n    // Keep the old claimed level so the modal will show\n    // Don't update it here - let the user claim the new level\n  } else {\n    // User stayed at same level or went down, update claimed level to match\n    const newClaimedKey = REDIS_KEYS.userLevelUpClaim(userId);\n    await redis.set(newClaimedKey, level.rank.toString());\n  }\n\n  const didUserLevelUp = level.min > (oldScore ?? 0);\n\n  if (didUserLevelUp) {\n    await scheduler.runJob({\n      name: 'USER_LEVEL_UP',\n      data: {\n        userId,\n        score,\n        level,\n        subredditName: context.subredditName,\n      },\n      runAt: new Date(),\n    });\n  }\n\n  return score;\n}\n\n/**\n * Increment the score for a user\n * @param userId - The user ID\n * @param amount - The number of points to increment\n * @returns The new score\n */\n\nexport async function incrementScore(\n  userId: T2,\n  amount: number\n): Promise<number> {\n  const key = REDIS_KEYS.scores();\n  // Apply active score multiplier (non-stacking; highest wins)\n  try {\n    const { getEffectiveScoreMultiplier } = await import(\n      '../services/rewards/consumables'\n    );\n    const multiplier = await getEffectiveScoreMultiplier(userId);\n    if (multiplier > 1) {\n      amount = Math.floor(amount * multiplier);\n    }\n  } catch {\n    // If rewards provider fails, continue without multiplier\n  }\n  const oldScore = await getScore(userId);\n  const score = await redis.zIncrBy(key, userId, amount);\n  const level = getLevelByScore(score);\n  const oldLevel = getLevelByScore(oldScore);\n  const didUserLevelUp = level.min > (oldScore ?? 0);\n\n  // Update claimed level if user leveled up\n  if (level.rank > oldLevel.rank && didUserLevelUp) {\n    // Keep the old claimed level so the modal will show\n    // Don't update it here - let the user claim the new level\n  } else if (level.rank === oldLevel.rank) {\n    // User stayed at same level, update claimed level to match\n    const newClaimedKey = REDIS_KEYS.userLevelUpClaim(userId);\n    await redis.set(newClaimedKey, level.rank.toString());\n  }\n\n  if (didUserLevelUp) {\n    await scheduler.runJob({\n      name: 'USER_LEVEL_UP',\n      data: {\n        userId,\n        score,\n        level,\n        subredditName: context.subredditName,\n      },\n      runAt: new Date(),\n    });\n  }\n\n  return score;\n}\n\n/**\n * Get the level by score (delegates to shared utility)\n * @param score - The score\n * @returns The level\n */\nexport function getLevelByScore(score: number): Level {\n  return getLevelByScoreUtil(score);\n}\n\nexport function getUserLevel(score: number): Level {\n  return getLevelByScore(score);\n}\n\n/**\n * Get the user rank\n * @param userId - The user ID\n * @returns The user rank or -1 if the user is not found\n */\n\nexport async function getRank(userId: T2): Promise<number> {\n  const rank = await redis.zRank(REDIS_KEYS.scores(), userId);\n  return rank ?? -1; // -1 if user not found\n}\n\n/**\n * Calculate level progress percentage for a given score\n * @param score - The user's score\n * @returns Progress percentage (0-100)\n */\nexport function getLevelProgressPercentage(score: number): number {\n  const currentLevel = getLevelByScore(score);\n  const levelProgress = score - currentLevel.min;\n  const levelMax = currentLevel.max - currentLevel.min;\n  return Math.min(100, Math.max(0, (levelProgress / levelMax) * 100));\n}\n\n/**\n * Get the last claimed level rank for a user\n * @param userId - The user ID\n * @returns The last claimed level rank, or null if never claimed\n */\nexport async function getLastClaimedLevel(userId: T2): Promise<number | null> {\n  const key = REDIS_KEYS.userLevelUpClaim(userId);\n  const claimed = await redis.get(key);\n  return claimed ? parseInt(claimed, 10) : null;\n}\n\n/**\n * Check if user has an unclaimed level-up celebration\n * @param userId - The user ID\n * @returns Level data if unclaimed, null otherwise\n */\nexport async function getUnclaimedLevelUp(userId: T2): Promise<{\n  level: number;\n} | null> {\n  const score = await getScore(userId);\n  const currentLevel = getUserLevel(score);\n  const lastClaimed = await getLastClaimedLevel(userId);\n\n  // Don't show level-up for level 1\n  if (currentLevel.rank === 1) {\n    return null;\n  }\n\n  // No level-up if current level hasn't changed\n  if (lastClaimed === currentLevel.rank) {\n    return null;\n  }\n\n  // Has an unclaimed level-up\n  return {\n    level: currentLevel.rank,\n  };\n}\n\n/**\n * Mark level as claimed and broadcast to realtime\n * @param userId - The user ID\n * @param level - The level to claim\n */\nexport async function claimLevelUp(userId: T2, level: number): Promise<void> {\n  const key = REDIS_KEYS.userLevelUpClaim(userId);\n  await redis.set(key, level.toString());\n\n  // Broadcast claim to all open posts for this user\n  await broadcastLevelUpClaimed(userId);\n\n  // Schedule rewards grant to be handled by rewards service\n  try {\n    await scheduler.runJob({\n      name: 'USER_LEVEL_CLAIMED',\n      data: { userId, level },\n      runAt: new Date(),\n    });\n  } catch {\n    // Non-blocking\n  }\n}\n\n/**\n * Broadcast level-up claim to user-scoped realtime channel\n * @param userId - The user ID\n */\nasync function broadcastLevelUpClaimed(userId: T2): Promise<void> {\n  const channelName = `user-${userId}-levelup`;\n  await realtime.send(channelName, {\n    type: 'levelup_claimed',\n    timestamp: Date.now(),\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/activity.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/activity.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/consumables.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/consumables.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-base-to-string",
        "severity": 1,
        "message": "'v || '0'' will use Object's default stringification format ('[object Object]') when stringified.",
        "line": 37,
        "column": 33,
        "nodeType": "LogicalExpression",
        "messageId": "baseToString",
        "endLine": 37,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 37,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 37,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1077, 1079], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 51,
        "column": 14,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 51,
        "endColumn": 32,
        "fix": { "range": [1364, 1382], "text": "Array<Promise<unknown>>" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 65,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "neverNullish",
        "endLine": 65,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
        "severity": 1,
        "message": "Passing a string to String() does not change the type or value of the string.",
        "line": 86,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unnecessaryTypeConversion",
        "endLine": 86,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestRemove",
            "fix": { "range": [2431, 2445], "text": "userId" },
            "desc": "Remove the type conversion."
          },
          {
            "messageId": "suggestSatisfies",
            "data": { "type": "string" },
            "fix": { "range": [2431, 2445], "text": "userId satisfies string" },
            "desc": "Instead, assert that the value satisfies the string type."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { redis, realtime } from '@devvit/web/server';\nimport { REALTIME_CHANNELS } from '@server/core/realtime';\nimport type { T2 } from '@devvit/shared-types/tid.js';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport {\n  type ConsumableId,\n  type ConsumableEffect,\n  getConsumableConfig,\n  SCORE_MULTIPLIER_IDS,\n} from '@shared/consumables';\n\nexport type Inventory = Record<ConsumableId, number>;\n\nexport type GrantedItem = {\n  itemId: ConsumableId;\n  quantity: number;\n};\n\nexport type ActiveEffectEntry = {\n  activationId: string;\n  itemId: ConsumableId;\n  effect: ConsumableEffect;\n  expiresAt: number; // epoch ms\n};\n\nfunction generateActivationId(): string {\n  const rand = Math.random().toString(36).slice(2, 10);\n  return `act_${Date.now()}_${rand}`;\n}\n\nexport async function getInventory(userId: T2): Promise<Inventory> {\n  const key = REDIS_KEYS.userInventory(userId);\n  const raw = await redis.hGetAll(key);\n  const result: Partial<Inventory> = {};\n  Object.entries(raw).forEach(([k, v]) => {\n    const id = k as ConsumableId;\n    const qty = parseInt(String(v || '0'), 10);\n    if (qty > 0) {\n      result[id] = qty;\n    }\n  });\n  return result as Inventory;\n}\n\nexport async function grantItems(\n  userId: T2,\n  items: GrantedItem[]\n): Promise<void> {\n  if (items.length === 0) return;\n  const key = REDIS_KEYS.userInventory(userId);\n  const ops: Promise<unknown>[] = [];\n  for (const { itemId, quantity } of items) {\n    if (quantity <= 0) continue;\n    ops.push(redis.hIncrBy(key, itemId, quantity));\n  }\n  await Promise.all(ops);\n}\n\nexport async function activateConsumable(\n  userId: T2,\n  itemId: ConsumableId\n): Promise<{ activationId: string; expiresAt: number } | null> {\n  // Check inventory first\n  const inv = await getInventory(userId);\n  const currentQty = inv[itemId] ?? 0;\n  if (currentQty <= 0) {\n    return null;\n  }\n\n  const config = getConsumableConfig(itemId);\n  const activationId = generateActivationId();\n  const now = Date.now();\n  const expiresAt = now + config.durationMs;\n\n  // Decrement inventory optimistically\n  const invKey = REDIS_KEYS.userInventory(userId);\n  const newCount = await redis.hIncrBy(invKey, itemId, -1);\n  if (newCount < 0) {\n    // Revert to zero if race produced negative\n    await redis.hSet(invKey, { [itemId]: '0' });\n    return null;\n  }\n\n  const activationKey = REDIS_KEYS.boostActivation(activationId);\n  const setData: Record<string, string> = {\n    userId: String(userId),\n    itemId,\n    expiresAt: String(expiresAt),\n  };\n  await redis.hSet(activationKey, setData);\n  // Set TTL slightly past expiration to allow lazy cleanup\n  await redis.expire(activationKey, Math.ceil(config.durationMs / 1000) + 30);\n\n  // Track in user's active set\n  await redis.zAdd(REDIS_KEYS.userActiveBoosts(userId), {\n    member: activationId as never,\n    score: expiresAt as never,\n  } as never);\n\n  // Broadcast updated active effects to user-scoped realtime channel\n  try {\n    const effects = await getActiveEffects(userId);\n    await realtime.send(REALTIME_CHANNELS.userRewards(userId), {\n      type: 'effects_updated',\n      effects,\n      timestamp: Date.now(),\n    });\n  } catch {\n    // Non-blocking: failures here should not affect activation flow\n  }\n\n  return { activationId, expiresAt };\n}\n\nexport async function getActiveEffects(\n  userId: T2\n): Promise<ActiveEffectEntry[]> {\n  const setKey = REDIS_KEYS.userActiveBoosts(userId);\n  const now = Date.now();\n  const entries = await redis.zRange(setKey, 0, -1, { by: 'rank' });\n  const results: ActiveEffectEntry[] = [];\n  for (const entry of entries) {\n    const activationId = String(entry.member);\n    const expiresAt = Number(entry.score);\n    if (!expiresAt || expiresAt < now) {\n      // Lazy prune expired\n      await redis.zRem(setKey, [activationId]);\n      continue;\n    }\n    const activationData = await redis.hGetAll(\n      REDIS_KEYS.boostActivation(activationId)\n    );\n    const itemId = activationData.itemId as ConsumableId | undefined;\n    const expiresAtStr = activationData.expiresAt;\n    if (!itemId || !expiresAtStr) {\n      // Orphan/missing, prune\n      await redis.zRem(setKey, [activationId]);\n      continue;\n    }\n    const cfg = getConsumableConfig(itemId);\n    results.push({\n      activationId,\n      itemId,\n      effect: cfg.effect,\n      expiresAt: Number(expiresAtStr),\n    });\n  }\n  return results;\n}\n\nexport async function getEffectiveScoreMultiplier(userId: T2): Promise<number> {\n  const active = await getActiveEffects(userId);\n  let maxMultiplier = 1;\n  for (const e of active) {\n    if (e.effect.kind === 'score_multiplier') {\n      if (e.effect.multiplier > maxMultiplier) {\n        maxMultiplier = e.effect.multiplier;\n      }\n    }\n  }\n  return maxMultiplier;\n}\n\nexport async function getActiveExtraDrawingTimeSeconds(\n  userId: T2\n): Promise<number> {\n  const active = await getActiveEffects(userId);\n  let total = 0;\n  for (const e of active) {\n    if (e.effect.kind === 'extra_drawing_time') {\n      total += e.effect.extraSeconds;\n    }\n  }\n  return total;\n}\n\nexport function isScoreMultiplier(id: ConsumableId): boolean {\n  return SCORE_MULTIPLIER_IDS.includes(id);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/index.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/rewards/index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 34,
        "column": 25,
        "nodeType": "ChainExpression",
        "messageId": "neverNullish",
        "endLine": 34,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 34,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 34,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [1006, 1008], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 35,
        "column": 47,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 35,
        "endColumn": 72,
        "fix": { "range": [1099, 1109], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 36,
        "column": 8,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 36,
        "endColumn": 33,
        "fix": { "range": [1133, 1143], "text": "" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import type { T2 } from '@devvit/shared-types/tid.js';\nimport { getScore, getUserLevel } from '@server/services/progression';\nimport { getExtraDrawingTime } from '@shared/rewards';\nimport { getActivityDrawingTimeBonus } from './activity';\nimport {\n  getActiveExtraDrawingTimeSeconds,\n  getEffectiveScoreMultiplier,\n} from './consumables';\n\nexport type EffectiveBonuses = {\n  extraDrawingTimeSeconds: number;\n  scoreMultiplier: number;\n  breakdown: {\n    levelExtra: number;\n    activityExtra: number;\n    consumableExtra: number;\n  };\n};\n\nexport async function getEffectiveBonuses(\n  userId: T2\n): Promise<EffectiveBonuses> {\n  const [score, activity, consumableExtra, scoreMultiplier] = await Promise.all(\n    [\n      getScore(userId),\n      getActivityDrawingTimeBonus(userId),\n      getActiveExtraDrawingTimeSeconds(userId),\n      getEffectiveScoreMultiplier(userId),\n    ]\n  );\n\n  const level = getUserLevel(score);\n  const levelExtra = getExtraDrawingTime(level.rank);\n  const activityExtra = activity?.extraDrawingTimeSeconds ?? 0;\n  const consumableExtraSafe = Number.isFinite(consumableExtra as number)\n    ? (consumableExtra as number)\n    : 0;\n  const extraDrawingTimeSeconds =\n    levelExtra + activityExtra + consumableExtraSafe;\n\n  return {\n    extraDrawingTimeSeconds,\n    scoreMultiplier,\n    breakdown: {\n      levelExtra,\n      activityExtra,\n      consumableExtra: consumableExtraSafe,\n    },\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/telemetry.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/telemetry.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 21,
        "column": 10,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 21,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { redis } from '@devvit/web/server';\nimport { REDIS_KEYS } from '../core/redis';\nimport type { PostType, TelemetryEventType } from '@shared/types';\nimport type { PostData } from '@shared/schema';\n\n/**\n * Telemetry service for tracking UI events\n * Uses Redis hash per day with postType:eventType fields\n */\n\n// Telemetry data retention period (30 days in seconds)\nconst TELEMETRY_TTL_SECONDS = 30 * 24 * 60 * 60;\n\n/**\n * Generate a date key in YYYY-MM-DD format for telemetry\n * @param date - Optional date, defaults to today\n * @returns Date string in YYYY-MM-DD format\n */\nexport function getTelemetryDateKey(date?: Date): string {\n  const targetDate = date ?? new Date();\n  return targetDate.toISOString().split('T')[0]!;\n}\n\nexport async function trackEvent(\n  postType: PostType,\n  eventType: TelemetryEventType,\n  date?: Date,\n  metadata?: Record<string, string | number>\n): Promise<void> {\n  const dateKey = getTelemetryDateKey(date);\n  const key = REDIS_KEYS.telemetry(dateKey);\n  const field = `${postType}:${eventType}`;\n\n  try {\n    const count = await redis.hIncrBy(key, field, 1);\n\n    // Set TTL to 30 days only if this is a new field (count = 1)\n    if (count === 1) {\n      await redis.expire(key, TELEMETRY_TTL_SECONDS);\n    }\n\n    // Store metadata if provided\n    if (metadata && Object.keys(metadata).length > 0) {\n      const metadataKey = `${key}:meta:${field}`;\n      // Convert all values to strings for Redis hash storage\n      const stringifiedMetadata: Record<string, string> = {};\n      for (const [key, value] of Object.entries(metadata)) {\n        stringifiedMetadata[key] = String(value);\n      }\n      await redis.hSet(metadataKey, stringifiedMetadata);\n      await redis.expire(metadataKey, TELEMETRY_TTL_SECONDS);\n    }\n  } catch (error) {\n    // Silently fail - telemetry should never break the app\n  }\n}\n\n/**\n * Track a telemetry event with automatic post type detection from context\n * Fire-and-forget operation that never blocks\n */\nexport async function trackEventFromContext(\n  eventType: TelemetryEventType,\n  postData: PostData | null,\n  metadata?: Record<string, string | number>\n): Promise<void> {\n  // Default to 'pinned' if no postData (e.g., in pinned post context)\n  // For collection posts, treat as 'pinned' for telemetry purposes\n  const postType: PostType =\n    postData?.type === 'drawing'\n      ? 'drawing'\n      : postData?.type === 'collection'\n        ? 'pinned'\n        : 'pinned';\n\n  await trackEvent(postType, eventType, undefined, metadata);\n}\n\n/**\n * Get event stats for a specific date\n */\nexport async function getEventStats(\n  date: string,\n  postType?: PostType\n): Promise<Record<string, number>> {\n  const key = REDIS_KEYS.telemetry(date);\n\n  try {\n    const hash = await redis.hGetAll(key);\n    const result: Record<string, number> = {};\n\n    for (const [field, value] of Object.entries(hash)) {\n      const [fieldPostType] = field.split(':');\n\n      // Filter by postType if specified\n      if (postType && fieldPostType !== postType) {\n        continue;\n      }\n\n      result[field] = parseInt(value as string, 10);\n    }\n\n    return result;\n  } catch (error) {\n    return {};\n  }\n}\n\n/**\n * Clear telemetry data for a specific date\n * Returns the number of records that were deleted\n */\nexport async function clearTelemetryData(date?: string): Promise<number> {\n  const targetDate = date ?? getTelemetryDateKey();\n  const key = REDIS_KEYS.telemetry(targetDate);\n\n  try {\n    // Get count before deletion for logging\n    const hash = await redis.hGetAll(key);\n    const recordCount = Object.keys(hash).length;\n\n    // Delete the entire hash\n    await redis.del(key);\n\n    return recordCount;\n  } catch (error) {\n    return 0;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/dictionary.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/dictionary.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 88,
        "column": 19,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 88,
        "endColumn": 37,
        "fix": { "range": [3210, 3228], "text": "Array<Promise<unknown>>" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { context, redis } from '@devvit/web/server';\nimport { DEFAULT_WORDS, DEFAULT_WORD_SCORE } from '@server/constants';\nimport { normalizeWord } from '@shared/utils/string';\nimport { shuffle } from '@shared/utils/array';\nimport { REDIS_KEYS } from '@server/core/redis';\n\nexport async function addWord(word: string): Promise<boolean> {\n  const subName = context.subredditName;\n  const normalizedWord = normalizeWord(word);\n  const isBanned = await isWordBanned(normalizedWord);\n  if (isBanned) return false;\n  const result = await redis.global.zAdd(REDIS_KEYS.wordsAll(subName), {\n    member: normalizedWord,\n    score: DEFAULT_WORD_SCORE,\n  });\n  return result > 0;\n}\n\nexport async function addWords(words: string[]): Promise<void> {\n  const subName = context.subredditName;\n  const normalizedWords = words.map((word) => normalizeWord(word));\n  const bannedWordsResult = await getBannedWords(0, 10000);\n  const filteredWords = normalizedWords.filter(\n    (word) => !bannedWordsResult.words.includes(word)\n  );\n  await redis.global.zAdd(\n    REDIS_KEYS.wordsAll(subName),\n    ...filteredWords.map((word) => ({\n      member: word,\n      score: DEFAULT_WORD_SCORE,\n    }))\n  );\n}\n\nexport async function removeWord(word: string): Promise<boolean> {\n  const subName = context.subredditName;\n  const normalizedWord = normalizeWord(word);\n  const [removed, _removedUncertainty] = await Promise.all([\n    redis.global.zRem(REDIS_KEYS.wordsAll(subName), [normalizedWord]),\n    redis.zRem(REDIS_KEYS.wordsUncertainty(subName), [normalizedWord]),\n  ]);\n  return removed > 0;\n}\n\nexport async function getWords(\n  subredditName?: string,\n  offset: number = 0,\n  limit: number = 1000\n): Promise<{ words: string[]; total: number; hasMore: boolean }> {\n  const subName = subredditName ?? context.subredditName;\n  const key = REDIS_KEYS.wordsAll(subName);\n  const [entities, total] = await Promise.all([\n    redis.global.zRange(key, offset, offset + limit - 1),\n    redis.global.zCard(key),\n  ]);\n  const words = entities.map((item) => item.member);\n  return { words, total, hasMore: offset + limit < total };\n}\n\nexport async function replaceAllWords(words: string[]): Promise<void> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.wordsAll(subName);\n  await redis.global.del(key);\n  if (words.length === 0) return;\n  await addWords(words);\n}\n\nexport async function updateWordsPreservingScores(\n  words: string[]\n): Promise<void> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.wordsAll(subName);\n  const currentWords = await redis.global.zRange(key, 0, -1);\n  const currentWordMap = new Map(\n    currentWords.map((item) => [item.member, item.score])\n  );\n  const normalizedWords = words.map((word) => normalizeWord(word));\n  const bannedWordsResult = await getBannedWords(0, 10000);\n  const filteredWords = normalizedWords.filter(\n    (word) => !bannedWordsResult.words.includes(word)\n  );\n  const currentWordSet = new Set(currentWordMap.keys());\n  const newWordSet = new Set(filteredWords);\n  const wordsToRemove = [...currentWordSet].filter(\n    (word) => !newWordSet.has(word)\n  );\n  const wordsToAdd = filteredWords.filter((word) => !currentWordSet.has(word));\n  const promises: Promise<unknown>[] = [];\n  if (wordsToRemove.length > 0) {\n    promises.push(redis.global.zRem(key, wordsToRemove));\n  }\n  if (wordsToAdd.length > 0) {\n    promises.push(\n      redis.global.zAdd(\n        key,\n        ...wordsToAdd.map((word) => ({\n          member: word,\n          score: DEFAULT_WORD_SCORE,\n        }))\n      )\n    );\n  }\n  await Promise.all(promises);\n}\n\nexport async function isWordInList(word: string): Promise<boolean> {\n  const normalizedWord = normalizeWord(word);\n  const isInDictionary = await redis.global\n    .zScore(REDIS_KEYS.wordsAll(context.subredditName), normalizedWord)\n    .then((result) => result !== undefined);\n  return isInDictionary;\n}\n\nexport async function banWord(word: string): Promise<void> {\n  const subName = context.subredditName;\n  const normalizedWord = normalizeWord(word);\n  await Promise.all([\n    redis.zAdd(REDIS_KEYS.wordsBanned(subName), {\n      member: normalizedWord,\n      score: DEFAULT_WORD_SCORE,\n    }),\n    redis.global.zRem(REDIS_KEYS.wordsAll(subName), [normalizedWord]),\n    redis.zRem(REDIS_KEYS.wordsUncertainty(subName), [normalizedWord]),\n  ]);\n}\n\nexport async function banWords(words: string[]): Promise<void> {\n  const subName = context.subredditName;\n  const normalizedWords = words.map((word) => normalizeWord(word));\n  await Promise.all([\n    redis.zAdd(\n      REDIS_KEYS.wordsBanned(subName),\n      ...normalizedWords.map((word) => ({\n        member: word,\n        score: DEFAULT_WORD_SCORE,\n      }))\n    ),\n    redis.global.zRem(REDIS_KEYS.wordsAll(subName), normalizedWords),\n    redis.zRem(REDIS_KEYS.wordsUncertainty(subName), normalizedWords),\n  ]);\n}\n\nexport async function unbanWord(word: string): Promise<void> {\n  const subName = context.subredditName;\n  const normalizedWord = normalizeWord(word);\n  await redis.zRem(REDIS_KEYS.wordsBanned(subName), [normalizedWord]);\n}\n\nexport async function getBannedWords(\n  offset: number = 0,\n  limit: number = 1000\n): Promise<{ words: string[]; total: number; hasMore: boolean }> {\n  const subName = context.subredditName;\n  const key = REDIS_KEYS.wordsBanned(subName);\n  const [words, total] = await Promise.all([\n    redis.zRange(key, offset, offset + limit - 1),\n    redis.zCard(key),\n  ]);\n  const wordMembers = words.map((item) => item.member);\n  return { words: wordMembers, total, hasMore: offset + limit < total };\n}\n\nexport async function replaceBannedWords(words: string[]): Promise<void> {\n  const subName = context.subredditName;\n  await redis.del(REDIS_KEYS.wordsBanned(subName));\n  if (words.length === 0) return;\n  const normalizedWords = words.map((word) => normalizeWord(word));\n  await banWords(normalizedWords);\n}\n\nexport async function isWordBanned(word: string): Promise<boolean> {\n  const subName = context.subredditName;\n  const normalizedWord = normalizeWord(word);\n  const result = await redis.zScore(\n    REDIS_KEYS.wordsBanned(subName),\n    normalizedWord\n  );\n  return result !== undefined;\n}\n\nexport async function getRandomWords(count: number = 3): Promise<string[]> {\n  const wordsResult = await getWords(context.subredditName, 0, 10000);\n  const shuffled = shuffle(wordsResult.words);\n  const result = shuffled.slice(0, count);\n  return result;\n}\n\nexport async function initDictionary(): Promise<void> {\n  const subredditName = context.subredditName;\n  const wordsKey = REDIS_KEYS.wordsAll(subredditName);\n  const [words, _communityAdditions] = await Promise.all([\n    redis.global.exists(wordsKey),\n    redis.global.zAdd(REDIS_KEYS.communities(), {\n      member: subredditName,\n      score: Date.now(),\n    }),\n  ]);\n  if (words !== 0) {\n    return;\n  }\n  await redis.global.zAdd(\n    REDIS_KEYS.wordsAll(subredditName),\n    ...DEFAULT_WORDS.map((word) => ({\n      member: word,\n      score: DEFAULT_WORD_SCORE,\n    }))\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/slate.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/slate.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-plus-operands",
        "severity": 1,
        "message": "Invalid operand for a '+' operation. Operands must each be a number or string. Got `any`.",
        "line": 162,
        "column": 23,
        "nodeType": "LogicalExpression",
        "messageId": "invalid",
        "endLine": 162,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 175,
        "column": 26,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 175,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [5415, 5416], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 181,
        "column": 31,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 181,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [5661, 5662], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 187,
        "column": 26,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 187,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [5819, 5820], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 232,
        "column": 19,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 232,
        "endColumn": 37,
        "fix": { "range": [7167, 7185], "text": "Array<Promise<unknown>>" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 265,
        "column": 32,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 265,
        "endColumn": 57,
        "fix": { "range": [8208, 8228], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"slate_posted\" === \"slate_posted\"` is true.",
        "line": 283,
        "column": 14,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 283,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 284,
        "column": 30,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 284,
        "endColumn": 55,
        "fix": { "range": [8729, 8749], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 347,
        "column": 21,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 347,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [10112, 10114], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-optional-chain",
        "severity": 1,
        "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        "line": 351,
        "column": 9,
        "nodeType": null,
        "messageId": "preferOptionalChain",
        "endLine": 351,
        "endColumn": 43,
        "fix": { "range": [10245, 10279], "text": "!wordStat?.drawerScore" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 4,
    "source": "import { context, redis } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport type { T3 } from '@devvit/shared-types/tid.js';\nimport { clamp } from '@shared/utils/numbers';\nimport { shuffle } from '@shared/utils/array';\n\nconst EXPLORATION_RATE = 0.1;\nconst Z_SCORE_CLAMP = 3;\nconst WEIGHT_PICK_RATE = 1;\nconst WEIGHT_POST_RATE = 1;\nconst UCB_CONSTANT = 2;\nconst SCORE_DECAY_RATE = 0.1;\n\nexport type Slate = {\n  slateId: SlateId;\n  words: string[];\n  timestamp: number;\n  word?: string;\n  position?: number;\n  postId?: T3;\n  servedAt?: number;\n  pickedAt?: number;\n  postedAt?: number;\n};\n\nexport type SlateId = `slate_${string}`;\n\nexport type SlateEventServed = {\n  slateId: SlateId;\n  name: 'slate_served';\n  timestamp: string;\n};\n\nexport type SlateEventPicked = {\n  slateId: SlateId;\n  name: 'slate_picked';\n  timestamp: string;\n  word: string;\n  position: number;\n};\n\nexport type SlateEventPosted = {\n  slateId: SlateId;\n  name: 'slate_posted';\n  word: string;\n  postId: T3;\n};\n\nexport type SlateEvent = SlateEventServed | SlateEventPicked | SlateEventPosted;\n\nexport type SlateBanditConfig = {\n  explorationRate: number;\n  zScoreClamp: number;\n  weightPickRate: number;\n  weightPostRate: number;\n  ucbConstant: number;\n  scoreDecayRate: number;\n};\n\nexport async function getSlateBanditConfig(): Promise<SlateBanditConfig> {\n  const configKey = REDIS_KEYS.slateConfig();\n  const config = await redis.hGetAll(configKey);\n  const rawConfig = {\n    explorationRate: config.explorationRate\n      ? parseFloat(config.explorationRate)\n      : EXPLORATION_RATE,\n    zScoreClamp: config.zScoreClamp\n      ? parseFloat(config.zScoreClamp)\n      : Z_SCORE_CLAMP,\n    weightPickRate: config.weightPickRate\n      ? parseFloat(config.weightPickRate)\n      : WEIGHT_PICK_RATE,\n    weightPostRate: config.weightPostRate\n      ? parseFloat(config.weightPostRate)\n      : WEIGHT_POST_RATE,\n    ucbConstant: config.ucbConstant\n      ? parseFloat(config.ucbConstant)\n      : UCB_CONSTANT,\n    scoreDecayRate: config.scoreDecayRate\n      ? parseFloat(config.scoreDecayRate)\n      : SCORE_DECAY_RATE,\n  };\n  const finalConfig = {\n    explorationRate: clamp(rawConfig.explorationRate, 0, 1),\n    zScoreClamp: Math.max(0.1, rawConfig.zScoreClamp),\n    weightPickRate: Math.max(0, rawConfig.weightPickRate),\n    weightPostRate: Math.max(0, rawConfig.weightPostRate),\n    ucbConstant: Math.max(0.1, rawConfig.ucbConstant),\n    scoreDecayRate: clamp(rawConfig.scoreDecayRate, 0, 1),\n  };\n  return finalConfig;\n}\n\nexport async function setSlateBanditConfig(\n  config: SlateBanditConfig\n): Promise<void> {\n  const configKey = REDIS_KEYS.slateConfig();\n  await redis.hSet(configKey, {\n    explorationRate: config.explorationRate.toString(),\n    zScoreClamp: config.zScoreClamp.toString(),\n    weightPickRate: config.weightPickRate.toString(),\n    weightPostRate: config.weightPostRate.toString(),\n    ucbConstant: config.ucbConstant.toString(),\n    scoreDecayRate: config.scoreDecayRate.toString(),\n  });\n}\n\nexport async function initSlateBandit(): Promise<void> {\n  const configKey = REDIS_KEYS.slateConfig();\n  const existingKeys = await redis.exists(configKey);\n  if (existingKeys === 0) {\n    const defaultConfig: SlateBanditConfig = {\n      explorationRate: EXPLORATION_RATE,\n      zScoreClamp: Z_SCORE_CLAMP,\n      weightPickRate: WEIGHT_PICK_RATE,\n      weightPostRate: WEIGHT_POST_RATE,\n      ucbConstant: UCB_CONSTANT,\n      scoreDecayRate: SCORE_DECAY_RATE,\n    };\n    await setSlateBanditConfig(defaultConfig);\n  }\n  const uncertaintyKey = REDIS_KEYS.wordsUncertainty(context.subredditName);\n  const uncertaintyExists = await redis.global.exists(uncertaintyKey);\n  if (uncertaintyExists === 0) {\n    const allWords = await redis.global.zRange(\n      REDIS_KEYS.wordsAll(context.subredditName),\n      0,\n      -1\n    );\n    if (allWords.length > 0) {\n      const initialUncertainty = 1 / Math.sqrt(10);\n      await redis.global.zAdd(\n        uncertaintyKey,\n        ...allWords.map((word) => ({\n          member: word.member,\n          score: initialUncertainty,\n        }))\n      );\n    }\n  }\n}\n\nexport async function pickWordsWithUCB(count: number = 3): Promise<string[]> {\n  const config = await getSlateBanditConfig();\n  const [allWords, uncertainties] = await Promise.all([\n    redis.global.zRange(REDIS_KEYS.wordsAll(context.subredditName), 0, -1),\n    redis.global.zRange(\n      REDIS_KEYS.wordsUncertainty(context.subredditName),\n      0,\n      -1\n    ),\n  ]);\n  if (allWords.length < count) {\n    throw new Error(\n      `Not enough words available. Need ${count}, have ${allWords.length}`\n    );\n  }\n  const ucbScores: Array<{ word: string; ucbScore: number }> = [];\n  for (const word of allWords) {\n    const uncertainty =\n      uncertainties.find((u) => u.member === word.member)?.score ?? 0;\n    const ucbScore = (word.score ?? 0) + config.ucbConstant * uncertainty;\n    ucbScores.push({ word: word.member, ucbScore });\n  }\n  ucbScores.sort((a, b) => b.ucbScore - a.ucbScore);\n  const selectedWords: string[] = [];\n  const remainingWords = [...ucbScores];\n  for (let i = 0; i < count && remainingWords.length > 0; i++) {\n    const totalScore = remainingWords.reduce(\n      (sum, w) => sum + Math.max(0, w.ucbScore),\n      0\n    );\n    if (totalScore === 0) {\n      const randomIndex = Math.floor(Math.random() * remainingWords.length);\n      selectedWords.push(remainingWords[randomIndex]!.word);\n      remainingWords.splice(randomIndex, 1);\n    } else {\n      let random = Math.random() * totalScore;\n      let selectedIndex = 0;\n      for (let j = 0; j < remainingWords.length; j++) {\n        random -= Math.max(0, remainingWords[j]!.ucbScore);\n        if (random <= 0) {\n          selectedIndex = j;\n          break;\n        }\n      }\n      selectedWords.push(remainingWords[selectedIndex]!.word);\n      remainingWords.splice(selectedIndex, 1);\n    }\n  }\n  return selectedWords;\n}\n\nexport async function generateSlate(): Promise<Slate> {\n  const slateId: SlateId = `slate_${crypto.randomUUID()}`;\n  const slateKey = REDIS_KEYS.slate(slateId);\n  const now = Date.now();\n  let slateWords = await pickWordsWithUCB(3);\n  slateWords = Array.from(new Set(slateWords));\n  while (slateWords.length < 3) {\n    const backfill = await redis.global.zRange(\n      REDIS_KEYS.wordsAll(context.subredditName),\n      0,\n      10,\n      { by: 'rank', reverse: true }\n    );\n    for (const candidate of backfill) {\n      if (!slateWords.includes(candidate.member)) {\n        slateWords.push(candidate.member);\n        break;\n      }\n    }\n    if (slateWords.length < 3) break;\n  }\n  if (slateWords.length < 3) {\n    throw new Error(`Unable to fill slate: ${slateWords.join(', ')}`);\n  }\n  slateWords = shuffle(slateWords);\n  const slate: Slate = { slateId, words: slateWords, timestamp: now };\n  await redis.hSet(slateKey, {\n    slateId,\n    words: JSON.stringify(slateWords),\n    timestamp: now.toString(),\n  });\n  await redis.expire(slateKey, 90 * 24 * 60 * 60);\n  return slate;\n}\n\nexport async function handleSlateEvent(event: SlateEvent): Promise<void> {\n  const { slateId, name } = event;\n  const timestamp = getCurrentTimestamp();\n  const promises: Promise<unknown>[] = [];\n  if (name === 'slate_served') {\n    const rawWords = await redis.hGet(REDIS_KEYS.slate(slateId), 'words');\n    if (!rawWords) return;\n    const words = JSON.parse(rawWords) as string[];\n    for (const word of words) {\n      promises.push(\n        redis.hIncrBy(\n          REDIS_KEYS.wordsHourlyStats(context.subredditName, timestamp),\n          `${word}:served`,\n          1\n        ),\n        redis.hIncrBy(\n          REDIS_KEYS.wordsTotalStats(context.subredditName),\n          `${word}:served`,\n          1\n        ),\n        redis.zAdd(REDIS_KEYS.wordsLastServed(context.subredditName), {\n          member: word,\n          score: Date.now(),\n        })\n      );\n    }\n    promises.push(\n      redis.hSet(REDIS_KEYS.slate(slateId), { servedAt: timestamp }),\n      ...words.map((word) =>\n        redis.zAdd(REDIS_KEYS.wordsActive(context.subredditName, timestamp), {\n          member: word,\n          score: 0,\n        })\n      )\n    );\n  } else if (name === 'slate_picked') {\n    const { word, position } = event as SlateEventPicked;\n    promises.push(\n      redis.hIncrBy(\n        REDIS_KEYS.wordsHourlyStats(context.subredditName, timestamp),\n        `${word}:picked`,\n        1\n      ),\n      redis.hIncrBy(\n        REDIS_KEYS.wordsTotalStats(context.subredditName),\n        `${word}:picked`,\n        1\n      ),\n      redis.hSet(REDIS_KEYS.slate(slateId), {\n        word,\n        position: position.toString(),\n        pickedAt: timestamp,\n      })\n    );\n  } else if (name === 'slate_posted') {\n    const { word, postId } = event as SlateEventPosted;\n    promises.push(\n      redis.hIncrBy(\n        REDIS_KEYS.wordsHourlyStats(context.subredditName, timestamp),\n        `${word}:posted`,\n        1\n      ),\n      redis.hIncrBy(\n        REDIS_KEYS.wordsTotalStats(context.subredditName),\n        `${word}:posted`,\n        1\n      ),\n      redis.hSet(REDIS_KEYS.slate(slateId), {\n        word,\n        postId,\n        postedAt: timestamp,\n      })\n    );\n  }\n  await Promise.all(promises);\n}\n\nexport async function applyScoreDecay(\n  wordStats: Record<\n    string,\n    {\n      hourly: {\n        served: number;\n        picked: number;\n        posted: number;\n        pickRate: number;\n        postRate: number;\n      };\n      total: { served: number; picked: number; posted: number };\n      drawerScore?: number;\n      drawerUncertainty?: number;\n    }\n  >,\n  config: SlateBanditConfig\n): Promise<\n  Record<\n    string,\n    {\n      hourly: {\n        served: number;\n        picked: number;\n        posted: number;\n        pickRate: number;\n        postRate: number;\n      };\n      total: { served: number; picked: number; posted: number };\n      drawerScore?: number;\n      drawerUncertainty?: number;\n    }\n  >\n> {\n  const lastServedData = await redis.zRange(\n    REDIS_KEYS.wordsLastServed(context.subredditName),\n    0,\n    -1\n  );\n  const now = Date.now();\n  const lastServedMap = new Map(\n    (lastServedData || []).map((item) => [item.member, item.score])\n  );\n  for (const word in wordStats) {\n    const wordStat = wordStats[word];\n    if (!wordStat || !wordStat.drawerScore) continue;\n    if (wordStat.total.served === 0) continue;\n    const lastServed = lastServedMap.get(word);\n    if (!lastServed) continue;\n    const daysSinceLastServed = (now - lastServed) / (1000 * 60 * 60 * 24);\n    const decayFactor = Math.exp(-config.scoreDecayRate * daysSinceLastServed);\n    wordStat.drawerScore *= decayFactor;\n  }\n  return wordStats;\n}\n\nexport function getCurrentTimestamp(): string {\n  const now = new Date();\n  return now.toISOString().slice(0, 13).replace('T', '-');\n}\n\nfunction getPreviousTimestamp(): string {\n  const now = new Date();\n  const lastHour = new Date(now.getTime() - 60 * 60 * 1000);\n  return lastHour.toISOString().slice(0, 13).replace('T', '-');\n}\n\nexport async function updateWordScores() {\n  const timestamp = getPreviousTimestamp();\n  const [allWords, allHourlyStats, allTotalStats, config] = await Promise.all([\n    redis.zRange(REDIS_KEYS.wordsAll(context.subredditName), 0, -1),\n    redis.hGetAll(\n      REDIS_KEYS.wordsHourlyStats(context.subredditName, timestamp)\n    ),\n    redis.hGetAll(REDIS_KEYS.wordsTotalStats(context.subredditName)),\n    getSlateBanditConfig(),\n  ]);\n  const words = allWords.map((item) => item.member);\n  if (words.length === 0) {\n    return;\n  }\n  const pickRates: number[] = [];\n  const postRates: number[] = [];\n  const wordStats: Record<\n    string,\n    {\n      hourly: {\n        served: number;\n        picked: number;\n        posted: number;\n        pickRate: number;\n        postRate: number;\n      };\n      total: { served: number; picked: number; posted: number };\n      drawerScore?: number;\n      drawerUncertainty?: number;\n    }\n  > = {};\n  for (const word of words) {\n    const hourlyServed = parseInt(allHourlyStats[`${word}:served`] ?? '0');\n    const hourlyPicked = parseInt(allHourlyStats[`${word}:picked`] ?? '0');\n    const hourlyPosted = parseInt(allHourlyStats[`${word}:posted`] ?? '0');\n    const totalServed = parseInt(allTotalStats[`${word}:served`] ?? '0');\n    const totalPicked = parseInt(allTotalStats[`${word}:picked`] ?? '0');\n    const totalPosted = parseInt(allTotalStats[`${word}:posted`] ?? '0');\n    if (hourlyServed === 0) {\n      const drawerUncertainty = 1 / Math.sqrt(Math.max(totalServed, 1));\n      wordStats[word] = {\n        hourly: { served: 0, picked: 0, posted: 0, pickRate: 0, postRate: 0 },\n        total: {\n          served: totalServed,\n          picked: totalPicked,\n          posted: totalPosted,\n        },\n        drawerScore: 0,\n        drawerUncertainty,\n      };\n      continue;\n    }\n    const hourlyPickRate = (hourlyPicked + 5) / (hourlyServed + 100);\n    const hourlyPostRate = (hourlyPosted + 5) / (hourlyPicked + 10);\n    pickRates.push(hourlyPickRate);\n    postRates.push(hourlyPostRate);\n    wordStats[word] = {\n      hourly: {\n        served: hourlyServed,\n        picked: hourlyPicked,\n        posted: hourlyPosted,\n        pickRate: hourlyPickRate,\n        postRate: hourlyPostRate,\n      },\n      total: { served: totalServed, picked: totalPicked, posted: totalPosted },\n    };\n  }\n  let meanPickRate = 0;\n  let stdPickRate = 1;\n  let meanPostRate = 0;\n  let stdPostRate = 1;\n  if (pickRates.length > 1) {\n    meanPickRate = pickRates.reduce((a, b) => a + b, 0) / pickRates.length;\n    const variancePickRate =\n      pickRates.reduce((a, b) => a + Math.pow(b - meanPickRate, 2), 0) /\n      pickRates.length;\n    stdPickRate = Math.sqrt(variancePickRate);\n    if (stdPickRate === 0) {\n      stdPickRate = 1;\n    }\n  }\n  if (postRates.length > 1) {\n    meanPostRate = postRates.reduce((a, b) => a + b, 0) / postRates.length;\n    const variancePostRate =\n      postRates.reduce((a, b) => a + Math.pow(b - meanPostRate, 2), 0) /\n      postRates.length;\n    stdPostRate = Math.sqrt(variancePostRate);\n    if (stdPostRate === 0) {\n      stdPostRate = 1;\n    }\n  }\n  for (const word in wordStats) {\n    const wordStat = wordStats[word];\n    if (!wordStat) continue;\n    let zPickRate = 0;\n    let zPostRate = 0;\n    if (wordStat.hourly.served > 0) {\n      zPickRate = (wordStat.hourly.pickRate - meanPickRate) / stdPickRate;\n      zPostRate = (wordStat.hourly.postRate - meanPostRate) / stdPostRate;\n    }\n    const zPickRateClamped = clamp(\n      zPickRate,\n      -config.zScoreClamp,\n      config.zScoreClamp\n    );\n    const zPostRateClamped = clamp(\n      zPostRate,\n      -config.zScoreClamp,\n      config.zScoreClamp\n    );\n    const drawerScore =\n      config.weightPickRate * zPickRateClamped +\n      config.weightPostRate * zPostRateClamped;\n    const drawerUncertainty = 1 / Math.sqrt(Math.max(wordStat.total.served, 1));\n    wordStats[word] = { ...wordStat, drawerScore, drawerUncertainty };\n  }\n  const decayedWordStats = await applyScoreDecay(wordStats, config);\n  const scoreEntries = words.map((word) => ({\n    member: word,\n    score: decayedWordStats[word]?.drawerScore ?? 0,\n  }));\n  const uncertaintyEntries = words.map((word) => ({\n    member: word,\n    score: decayedWordStats[word]?.drawerUncertainty ?? 0,\n  }));\n  await Promise.all([\n    redis.zAdd(REDIS_KEYS.wordsAll(context.subredditName), ...scoreEntries),\n    redis.zAdd(\n      REDIS_KEYS.wordsUncertainty(context.subredditName),\n      ...uncertaintyEntries\n    ),\n    redis.expire(\n      REDIS_KEYS.wordsHourlyStats(context.subredditName, timestamp),\n      90 * 24 * 60 * 60\n    ),\n  ]);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/word-backing.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/services/words/word-backing.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/array-type",
        "severity": 1,
        "message": "Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.",
        "line": 14,
        "column": 19,
        "nodeType": "TSArrayType",
        "messageId": "errorStringGenericSimple",
        "endLine": 14,
        "endColumn": 37,
        "fix": { "range": [569, 587], "text": "Array<Promise<unknown>>" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { redis, cache } from '@devvit/web/server';\nimport { normalizeWord } from '@shared/utils/string';\nimport { isWordBanned, isWordInList } from './dictionary';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport { isT1, type T1 } from '@devvit/shared-types/tid.js';\n\nexport async function addBacker(word: string, commentId: T1): Promise<void> {\n  const normalizedWord = normalizeWord(word);\n  const [isBanned, currentBacking] = await Promise.all([\n    isWordBanned(normalizedWord),\n    getBacker(normalizedWord),\n  ]);\n  if (isBanned) return;\n  const promises: Promise<unknown>[] = [\n    redis.set(REDIS_KEYS.wordBacking(normalizedWord), commentId),\n    redis.set(REDIS_KEYS.wordBackingComment(commentId), normalizedWord),\n  ];\n  if (currentBacking) {\n    promises.push(redis.del(REDIS_KEYS.wordBackingComment(currentBacking)));\n  }\n  await Promise.all(promises);\n}\n\nexport async function getBacker(word: string): Promise<T1 | null> {\n  const normalizedWord = normalizeWord(word);\n  const key = REDIS_KEYS.wordBacking(normalizedWord);\n  const commentId = await redis.get(key);\n  return commentId && isT1(commentId) ? commentId : null;\n}\n\nexport async function removeBacker(word: string): Promise<void> {\n  const normalizedWord = normalizeWord(word);\n  const commentId = await getBacker(normalizedWord);\n  if (!commentId) return;\n  await Promise.all([\n    redis.del(REDIS_KEYS.wordBacking(normalizedWord)),\n    redis.del(REDIS_KEYS.wordBackingComment(commentId)),\n  ]);\n}\n\nexport async function getBackedWord(\n  commentId: T1\n): Promise<string | undefined> {\n  const word = await redis.get(REDIS_KEYS.wordBackingComment(commentId));\n  return word ? normalizeWord(word) : undefined;\n}\n\nexport async function shouldShowWord(word: string): Promise<boolean> {\n  const normalizedWord = normalizeWord(word);\n  return await cache(\n    async () => {\n      const backer = await getBacker(normalizedWord);\n      if (backer) return true;\n      const inDictionary = await isWordInList(normalizedWord);\n      return inDictionary;\n    },\n    { key: `should_show:${normalizedWord}`, ttl: 15 }\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/test-setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/triggers/app-lifecycle.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/triggers/comment-triggers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/triggers/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/triggers/test-triggers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/trpc/context.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/trpc/router.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/trpc/router.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 253,
        "column": 53,
        "nodeType": "TSAsExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 253,
        "endColumn": 71,
        "fix": { "range": [7962, 7968], "text": "" }
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 488,
        "column": 26,
        "nodeType": "TSAsExpression",
        "messageId": "neverNullish",
        "endLine": 488,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, comparison is always true, since `\"slate_posted\" === \"slate_posted\"` is true.",
        "line": 490,
        "column": 22,
        "nodeType": "BinaryExpression",
        "messageId": "comparisonBetweenLiteralTypes",
        "endLine": 490,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 796,
        "column": 53,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 796,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [25266, 25268], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 809,
        "column": 56,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 809,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [25763, 25765], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { initTRPC } from '@trpc/server';\nimport type { Context } from './context';\n\nimport type { T3, T1 } from '@devvit/shared-types/tid.js';\nimport { assertT3 } from '@devvit/shared-types/tid.js';\nimport { redis } from '@devvit/web/server';\nimport { REDIS_KEYS } from '@server/core/redis';\nimport {\n  getWords,\n  addWord,\n  removeWord,\n  getBannedWords,\n} from '@server/services/words/dictionary';\nimport {\n  generateSlate,\n  handleSlateEvent,\n  getCurrentTimestamp,\n  type SlateId,\n} from '@server/services/words/slate';\nimport {\n  createDrawing,\n  submitGuess,\n  skipDrawing,\n  getDrawing,\n  getDrawings,\n  getGuesses,\n  getUserDrawingsWithData,\n  getUserDrawingStatus,\n  isAuthorFirstView,\n} from '@server/services/posts/drawing';\nimport {\n  getLeaderboard,\n  getScore,\n  getRank,\n  getUserLevel,\n  getLevelProgressPercentage,\n  getUnclaimedLevelUp,\n  claimLevelUp,\n} from '@server/services/progression';\nimport { isAdmin, isModerator } from '@server/core/redis';\nimport { DrawingDataSchema } from '@shared/schema/pixelary';\nimport { trackEventFromContext } from '@server/services/telemetry';\nimport type { TelemetryEventType } from '@shared/types';\nimport { z } from 'zod';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const appRouter = t.router({\n  system: t.router({\n    ping: t.procedure.query(() => ({ ok: true }) as const),\n  }),\n\n  // Pixelary-specific endpoints\n  app: t.router({\n    // System endpoints\n    system: t.router({\n      initialize: t.procedure.mutation(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n\n        // Import initialization functions\n        const { initDictionary } = await import(\n          '@server/services/words/dictionary'\n        );\n        const { initFlairTemplates } = await import('@server/core/flair');\n        const { initSlateBandit } = await import(\n          '@server/services/words/slate'\n        );\n\n        // Run initialization\n        await initDictionary();\n        await initFlairTemplates();\n        await initSlateBandit();\n\n        return { success: true, message: 'Pixelary initialized successfully' };\n      }),\n\n      status: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n\n        // Check if dictionary is initialized\n        const wordsResult = await getWords(ctx.subredditName, 0, 1);\n        const isInitialized = wordsResult.total > 0;\n\n        return {\n          initialized: isInitialized,\n          wordCount: wordsResult.total,\n          subreddit: ctx.subredditName,\n        };\n      }),\n    }),\n\n    // Dictionary endpoints\n    dictionary: t.router({\n      get: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n        const result = await getWords(ctx.subredditName, 0, 10000);\n        return result.words;\n      }),\n\n      add: t.procedure\n        .input(z.object({ word: z.string().min(1).max(50) }))\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.subredditName) throw new Error('Subreddit not found');\n          const success = await addWord(input.word);\n          if (!success) {\n            throw new Error('Failed to add word or word already exists');\n          }\n          return { success: true };\n        }),\n\n      remove: t.procedure\n        .input(z.object({ word: z.string().min(1).max(50) }))\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.subredditName) throw new Error('Subreddit not found');\n          const success = await removeWord(input.word);\n          if (!success) {\n            throw new Error('Failed to remove word or word not found');\n          }\n          return { success: true };\n        }),\n\n      getBanned: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n        const result = await getBannedWords(0, 10000);\n        return result.words;\n      }),\n\n      getCandidates: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n\n        const result = await generateSlate();\n        return result;\n      }),\n    }),\n\n    // Post endpoints\n    post: t.router({\n      getDrawing: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const postId = input.postId;\n          return await getDrawing(postId);\n        }),\n\n      getDrawings: t.procedure\n        .input(z.object({ postIds: z.array(z.string()) }))\n        .query(async ({ input }) => {\n          input.postIds.forEach(assertT3);\n          const postIds = input.postIds as T3[];\n          return await getDrawings(postIds);\n        }),\n\n      getCollection: t.procedure\n        .input(z.object({ collectionId: z.string() }))\n        .query(async ({ input }) => {\n          const { getCollectionData } = await import(\n            '../services/posts/collection'\n          );\n          return await getCollectionData(input.collectionId);\n        }),\n\n      submitDrawing: t.procedure\n        .input(\n          z.object({\n            word: z.string(),\n            dictionary: z.string(),\n            drawing: DrawingDataSchema,\n            imageData: z.string().optional(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId || !ctx.username) {\n            throw new Error('Must be logged in');\n          }\n          if (!ctx.subredditId) {\n            throw new Error('Subreddit not found');\n          }\n\n          const post = await createDrawing({\n            word: input.word,\n            dictionary: input.dictionary,\n            drawing: input.drawing,\n            authorName: ctx.username,\n            authorId: ctx.userId,\n            ...(input.imageData && { imageData: input.imageData }),\n          });\n\n          return {\n            success: true,\n            postId: post.id,\n            navigateTo: `https://reddit.com/r/${ctx.subredditName}/comments/${post.id}`,\n          };\n        }),\n\n      revealGuess: t.procedure\n        .input(\n          z.object({\n            postId: z.string(),\n            guess: z.string(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n\n          // Check if user is admin or moderator\n          const userIsAdmin = await isAdmin(ctx.userId);\n          const userIsModerator = ctx.subredditName\n            ? await isModerator(ctx.userId, ctx.subredditName)\n            : false;\n\n          if (!userIsAdmin && !userIsModerator) {\n            // Silently ignore the request for non-privileged users\n            return { success: false, revealed: false };\n          }\n\n          // Get all guesses for this post to find the original word\n          const { obfuscateString } = await import('../../shared/utils/string');\n\n          // Get the raw guesses (before obfuscation)\n          const rawGuesses = await redis.zRange(\n            REDIS_KEYS.drawingGuesses(input.postId as T3),\n            0,\n            -1,\n            { reverse: true, by: 'rank' }\n          );\n\n          // Find the original word that matches the obfuscated input\n          let originalWord = input.guess;\n          for (const guess of rawGuesses) {\n            if (obfuscateString(guess.member) === input.guess) {\n              originalWord = guess.member;\n              break;\n            }\n          }\n\n          // Return the original word for privileged users\n          return {\n            success: true,\n            revealed: true,\n            guess: originalWord,\n          };\n        }),\n\n      isAuthorFirstView: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) {\n            throw new Error('Must be logged in');\n          }\n\n          assertT3(input.postId);\n          const firstView = await isAuthorFirstView(input.postId as T3);\n\n          return { firstView };\n        }),\n    }),\n\n    // Guess endpoints\n    guess: t.router({\n      submit: t.procedure\n        .input(\n          z.object({\n            postId: z.string(),\n            guess: z.string(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n          assertT3(input.postId);\n          const postId = input.postId;\n\n          const result = await submitGuess({\n            postId,\n            userId: ctx.userId,\n            guess: input.guess,\n          });\n\n          return result;\n        }),\n\n      getStats: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const postId = input.postId;\n          const result = await getGuesses(postId);\n          return result;\n        }),\n\n      skip: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in to skip post');\n          assertT3(input.postId);\n          const postId = input.postId;\n          await skipDrawing(postId, ctx.userId);\n          return { success: true };\n        }),\n    }),\n\n    // User endpoints\n    user: t.router({\n      getProfile: t.procedure\n        .input(z.object({ postId: z.string() }).optional())\n        .query(async ({ ctx, input }) => {\n          if (!ctx.userId) return null;\n\n          const score = await getScore(ctx.userId);\n          const [rank, level] = await Promise.all([\n            getRank(ctx.userId),\n            getUserLevel(score), // Use cached score\n          ]);\n\n          // Get drawing-specific status if postId is provided\n          let drawingStatus = { solved: false, skipped: false, guessCount: 0 };\n          if (input?.postId) {\n            try {\n              assertT3(input.postId);\n              drawingStatus = await getUserDrawingStatus(\n                input.postId,\n                ctx.userId\n              );\n            } catch (error) {\n              // If post doesn't exist or other error, use defaults\n              console.warn('Failed to get drawing status:', error);\n            }\n          }\n\n          return {\n            username: ctx.username ?? '',\n            userId: ctx.userId,\n            score,\n            level: level.rank,\n            levelName: level.name,\n            levelProgressPercentage: getLevelProgressPercentage(score),\n            rank,\n            solved: drawingStatus.solved,\n            skipped: drawingStatus.skipped,\n            guessCount: drawingStatus.guessCount,\n          };\n        }),\n\n      getDrawings: t.procedure\n        .input(\n          z.object({ limit: z.number().int().min(1).max(100).default(20) })\n        )\n        .query(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n          return await getUserDrawingsWithData(ctx.userId, input.limit);\n        }),\n\n      getRank: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) throw new Error('Must be logged in');\n\n        const [score, rank] = await Promise.all([\n          getScore(ctx.userId),\n          getRank(ctx.userId),\n        ]);\n\n        return {\n          rank,\n          score,\n          username: ctx.username ?? '',\n        };\n      }),\n\n      getLevel: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) return { level: 1 };\n        const score = await getScore(ctx.userId);\n        const level = getUserLevel(score);\n        return { level: level.rank };\n      }),\n\n      isModerator: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId || !ctx.subredditName) {\n          return false;\n        }\n\n        return await isModerator(ctx.userId, ctx.subredditName);\n      }),\n\n      isModeratorOrAdmin: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) {\n          return false;\n        }\n\n        // Check if user is admin first\n        const userIsAdmin = await isAdmin(ctx.userId);\n        if (userIsAdmin) {\n          return true;\n        }\n\n        // Check if user is moderator\n        if (!ctx.subredditName) {\n          return false;\n        }\n\n        return await isModerator(ctx.userId, ctx.subredditName);\n      }),\n\n      getUnclaimedLevelUp: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) return null;\n        return await getUnclaimedLevelUp(ctx.userId);\n      }),\n\n      claimLevelUp: t.procedure\n        .input(z.object({ level: z.number().int() }))\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n          await claimLevelUp(ctx.userId, input.level);\n          return { success: true };\n        }),\n    }),\n\n    // Leaderboard endpoints\n    leaderboard: t.router({\n      getTop: t.procedure\n        .input(\n          z.object({\n            limit: z.number().int().min(1).max(100).default(10),\n            cursor: z.number().int().default(0),\n          })\n        )\n        .query(async ({ input }) => {\n          const result = await getLeaderboard({\n            limit: input.limit,\n            cursor: input.cursor,\n          });\n          return result.entries;\n        }),\n\n      getUserRank: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) {\n          return { rank: -1, score: 0, username: '', userId: '' };\n        }\n        const [userRank, score] = await Promise.all([\n          getRank(ctx.userId),\n          getScore(ctx.userId),\n        ]);\n        return {\n          rank: userRank,\n          score,\n          username: ctx.username ?? '',\n          userId: ctx.userId,\n        };\n      }),\n    }),\n\n    // Slate endpoints\n    slate: t.router({\n      trackAction: t.procedure\n        .input(\n          z.object({\n            slateId: z.string(),\n            action: z.enum([\n              'slate_served',\n              'slate_picked',\n              'slate_posted',\n            ] as const),\n            word: z.string().optional(),\n            metadata: z.record(z.union([z.string(), z.number()])).optional(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.subredditName) {\n            throw new Error('Subreddit not found');\n          }\n\n          // Map action names to slate event types\n          const timestamp = getCurrentTimestamp();\n\n          if (input.action === 'slate_served') {\n            await handleSlateEvent({\n              slateId: input.slateId as SlateId,\n              name: 'slate_served',\n              timestamp,\n            });\n          } else if (input.action === 'slate_picked') {\n            if (!input.word) {\n              return { ok: true };\n            }\n            await handleSlateEvent({\n              slateId: input.slateId as SlateId,\n              name: 'slate_picked',\n              timestamp,\n              word: input.word,\n              position: (input.metadata?.position as number) ?? 0,\n            });\n          } else if (input.action === 'slate_posted') {\n            if (!input.word || !ctx.postId) {\n              return { ok: true };\n            }\n            await handleSlateEvent({\n              slateId: input.slateId as SlateId,\n              name: 'slate_posted',\n              word: input.word,\n              postId: ctx.postId,\n            });\n          }\n          // All other events should be handled by telemetry.ts instead\n\n          return { ok: true };\n        }),\n    }),\n\n    // Telemetry endpoints\n    telemetry: t.router({\n      track: t.procedure\n        .input(\n          z.union([\n            z.object({\n              eventType: z.string(),\n              metadata: z.record(z.union([z.string(), z.number()])),\n            }),\n            z.object({\n              eventType: z.string(),\n            }),\n          ])\n        )\n        .mutation(async ({ ctx, input }) => {\n          try {\n            // Fire-and-forget telemetry tracking with automatic post type detection\n            const metadata = 'metadata' in input ? input.metadata : {};\n            await trackEventFromContext(\n              input.eventType as TelemetryEventType,\n              ctx.postData,\n              metadata\n            );\n          } catch (error) {\n            // Silently ignore errors - telemetry should never break the app\n          }\n\n          return { ok: true };\n        }),\n    }),\n\n    // Rewards endpoints\n    rewards: t.router({\n      getInventory: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) throw new Error('Must be logged in');\n        const { getInventory } = await import(\n          '../services/rewards/consumables'\n        );\n        return await getInventory(ctx.userId);\n      }),\n\n      getActiveEffects: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) throw new Error('Must be logged in');\n        const { getActiveEffects } = await import(\n          '../services/rewards/consumables'\n        );\n        return await getActiveEffects(ctx.userId);\n      }),\n\n      activateConsumable: t.procedure\n        .input(\n          z.object({\n            itemId: z.union([\n              z.literal('score_multiplier_2x_4h'),\n              z.literal('score_multiplier_3x_30m'),\n              z.literal('draw_time_boost_30s_2h'),\n            ]),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n          const { activateConsumable } = await import(\n            '../services/rewards/consumables'\n          );\n          const result = await activateConsumable(ctx.userId, input.itemId);\n          if (!result) {\n            return { success: false } as const;\n          }\n          return { success: true, ...result } as const;\n        }),\n\n      getEffectiveBonuses: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.userId) throw new Error('Must be logged in');\n        const { getEffectiveBonuses } = await import('../services/rewards');\n        return await getEffectiveBonuses(ctx.userId);\n      }),\n\n      dispenseItems: t.procedure\n        .input(\n          z.object({\n            username: z.string(),\n            items: z.array(\n              z.object({\n                itemId: z.union([\n                  z.literal('score_multiplier_2x_4h'),\n                  z.literal('score_multiplier_3x_30m'),\n                  z.literal('draw_time_boost_30s_2h'),\n                ]),\n                quantity: z.number().int().min(1),\n              })\n            ),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n          const { isAdmin, isModerator } = await import('../core/redis');\n          const userIsAdmin = await isAdmin(ctx.userId);\n          const userIsModerator = ctx.subredditName\n            ? await isModerator(ctx.userId, ctx.subredditName)\n            : false;\n          if (!userIsAdmin && !userIsModerator) {\n            throw new Error('Not authorized');\n          }\n          const { reddit } = await import('@devvit/web/server');\n          const user = await reddit.getUserByUsername(input.username);\n          if (!user) throw new Error('User not found');\n          const { grantItems } = await import(\n            '../services/rewards/consumables'\n          );\n          await grantItems(user.id as never, input.items as never);\n          return { success: true } as const;\n        }),\n    }),\n\n    // Tournament endpoints\n    tournament: t.router({\n      getTournament: t.procedure.query(async ({ ctx }) => {\n        if (!ctx.subredditName) throw new Error('Subreddit not found');\n\n        // Get tournament info from current post context\n        if (!ctx.postId || ctx.postData?.type !== 'tournament') {\n          throw new Error('Not on a tournament post');\n        }\n\n        const tournamentPostData = ctx.postData as {\n          type: 'tournament';\n          word: string;\n          dictionary: string;\n        };\n\n        return {\n          word: tournamentPostData.word,\n          postId: ctx.postId,\n        };\n      }),\n\n      submitDrawing: t.procedure\n        .input(\n          z.object({\n            postId: z.string(),\n            drawing: DrawingDataSchema,\n            imageData: z.string(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n\n          const { submitTournamentEntry } = await import(\n            '../services/posts/tournament/post'\n          );\n\n          assertT3(input.postId);\n          const commentId = await submitTournamentEntry(\n            input.drawing,\n            input.imageData,\n            input.postId\n          );\n\n          return { success: true, commentId };\n        }),\n\n      getSubmissions: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const { getTournamentEntries } = await import(\n            '../services/posts/tournament/post'\n          );\n          return await getTournamentEntries(input.postId);\n        }),\n\n      getRandomPair: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const { getRandomPair } = await import(\n            '../services/posts/tournament/pairs'\n          );\n          return await getRandomPair(input.postId);\n        }),\n\n      getDrawingPairs: t.procedure\n        .input(\n          z.object({\n            postId: z.string(),\n            count: z.number().int().min(1).max(20).default(5),\n          })\n        )\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const { getDrawingPairs } = await import(\n            '../services/posts/tournament/pairs'\n          );\n          return await getDrawingPairs(input.postId, input.count);\n        }),\n\n      submitVote: t.procedure\n        .input(\n          z.object({\n            postId: z.string(),\n            winnerCommentId: z.string(),\n            loserCommentId: z.string(),\n          })\n        )\n        .mutation(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n\n          const winnerId = input.winnerCommentId as T1;\n          const loserId = input.loserCommentId as T1;\n\n          const { tournamentVote } = await import(\n            '../services/posts/tournament/post'\n          );\n          // Context is used inside the function\n          await tournamentVote(winnerId, loserId);\n\n          return { success: true };\n        }),\n\n      getStats: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ input }) => {\n          assertT3(input.postId);\n          const { getTournament } = await import(\n            '../services/posts/tournament/post'\n          );\n          return await getTournament(input.postId);\n        }),\n\n      getCommentDrawing: t.procedure\n        .input(z.object({ commentId: z.string() }))\n        .query(async ({ input }) => {\n          const { getTournamentEntry } = await import(\n            '../services/posts/tournament/post'\n          );\n          return await getTournamentEntry(input.commentId as T1);\n        }),\n\n      getSubmissionsWithDrawings: t.procedure\n        .input(z.object({ postId: z.string() }))\n        .query(async ({ ctx, input }) => {\n          if (!ctx.userId) throw new Error('Must be logged in');\n\n          assertT3(input.postId);\n          const { getTournamentEntry } = await import(\n            '../services/posts/tournament/post'\n          );\n          const { redis } = await import('@devvit/web/server');\n          const { REDIS_KEYS } = await import('../core/redis');\n          const { getUsername } = await import('../core/user');\n\n          // Get all submissions ordered by Elo rating (highest first)\n          const queryKey = REDIS_KEYS.tournamentEntries(input.postId);\n\n          const rankedSubmissions = await redis.zRange(queryKey, 0, -1, {\n            reverse: true,\n            by: 'rank',\n          });\n\n          if (rankedSubmissions.length === 0) {\n            return [];\n          }\n\n          // Collect all comment IDs and fetch entries in parallel\n          const commentIds = rankedSubmissions.map((item) => item.member as T1);\n          const entryPromises = commentIds.map((id) => getTournamentEntry(id));\n          const entryList = await Promise.all(entryPromises);\n\n          // Build a map of commentId -> entry (filtering undefined)\n          const entryMap = new Map<\n            T1,\n            NonNullable<Awaited<ReturnType<typeof getTournamentEntry>>>\n          >();\n          const userIds: string[] = [];\n          entryList.forEach((entry, idx) => {\n            const commentId = commentIds[idx];\n            if (entry) {\n              entryMap.set(commentId, entry);\n              userIds.push(entry.userId);\n            }\n          });\n\n          // Resolve usernames with de-duplication\n          const uniqueUserIds = Array.from(new Set(userIds));\n          const usernameResults = await Promise.all(\n            uniqueUserIds.map((uid) => getUsername(uid as never))\n          );\n          const usernameMap = new Map<string, string>();\n          uniqueUserIds.forEach((uid, i) => {\n            usernameMap.set(uid, usernameResults[i] || '');\n          });\n\n          // Assemble results in the same rank order, skipping missing entries\n          const results = rankedSubmissions\n            .map((item) => {\n              const commentId = item.member as T1;\n              const data = entryMap.get(commentId);\n              if (!data) return null;\n              return {\n                commentId,\n                drawing: data.drawing,\n                userId: data.userId,\n                username: usernameMap.get(data.userId) || '',\n                postId: data.postId,\n                score: item.score,\n                rating: item.score,\n                votes: data.votes,\n                views: data.views,\n              };\n            })\n            .filter(Boolean) as Array<{\n            commentId: T1;\n            drawing: unknown;\n            userId: string;\n            username: string;\n            postId: string;\n            score: number;\n            rating: number;\n            votes: number;\n            views: number;\n          }>;\n\n          return results;\n        }),\n\n      incrementViews: t.procedure\n        .input(z.object({ commentId: z.string() }))\n        .mutation(async ({ input }) => {\n          const { incrementEntryViews } = await import(\n            '../services/posts/tournament/post'\n          );\n          await incrementEntryViews(input.commentId as T1);\n          return { success: true };\n        }),\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/server/vite.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/consumables.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/consumables.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/realtime.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/realtime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/rewards.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/rewards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/schema/drawing.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 21,
        "column": 10,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 21,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [562, 563], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 29,
        "column": 10,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 29,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestOptionalChain",
            "fix": { "range": [756, 757], "text": "?" },
            "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 97,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 97,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2649, 2651], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 98,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 98,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [2666, 2707],
              "text": "(v3.colors[colorIndex] ?? v3.colors[v3.bg])"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 98,
        "column": 54,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 98,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [2708, 2710], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 210,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 210,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": {
              "range": [5565, 5606],
              "text": "(v3.colors[colorIndex] ?? v3.colors[v3.bg])"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 210,
        "column": 61,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 210,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [5607, 5609], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\n\n// Declare global variables for cross-environment compatibility\ndeclare const atob: ((data: string) => string) | undefined;\ndeclare const btoa: ((data: string) => string) | undefined;\ndeclare const Buffer:\n  | {\n      from(\n        data: string,\n        encoding: string\n      ): { toString(encoding: string): string };\n    }\n  | undefined;\n\n// Browser/Node.js compatible base64 encoding\nconst encodeBase64 = (str: string): string => {\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n  // Node.js fallback\n  return Buffer!.from(str, 'binary').toString('base64');\n};\n\nconst decodeBase64 = (str: string): string => {\n  if (typeof atob !== 'undefined') {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer!.from(str, 'base64').toString('binary');\n};\n\n// Optimized drawing schema for maximum efficiency\nexport const DrawingDataSchema = z.object({\n  // Bit-packed data: each pixel = 8 bits (256 colors max)\n  // Each byte represents one pixel's color index\n  data: z.string(), // Base64 encoded bit-packed data\n\n  // Color palette (max 256 colors)\n  colors: z.array(z.string()).max(256),\n\n  // Background color index in palette\n  bg: z.number().int().min(0),\n\n  // Grid size (square grid)\n  size: z.number().int().min(1).max(64).default(16),\n});\n\nexport type DrawingData = z.infer<typeof DrawingDataSchema>;\n\n// Utility functions for drawing format\nexport const DrawingUtils = {\n  /**\n   * Create blank drawing\n   */\n  createBlank: (size = 16): DrawingData => {\n    const totalPixels = size * size;\n    const data = new Uint8Array(totalPixels);\n    data.fill(0); // All pixels set to background color (0)\n\n    return {\n      data: encodeBase64(String.fromCharCode.apply(null, Array.from(data))),\n      colors: ['#FFFFFF'], // Default white background\n      bg: 0,\n      size,\n    };\n  },\n\n  /**\n   * Efficiently decode base64 data to Uint8Array\n   */\n  _decodeData: (base64Data: string): Uint8Array => {\n    const binaryString = decodeBase64(base64Data);\n    const bytes = new Uint8Array(binaryString.length);\n    let idx = 0;\n    for (const ch of binaryString) {\n      bytes[idx++] = ch.charCodeAt(0);\n    }\n    return bytes;\n  },\n\n  /**\n   * Efficiently encode Uint8Array to base64\n   */\n  _encodeData: (data: Uint8Array): string => {\n    let binaryString = '';\n    for (const byte of data) {\n      binaryString += String.fromCharCode(byte);\n    }\n    return encodeBase64(binaryString);\n  },\n\n  /**\n   * Get pixel color at position\n   */\n  getPixelColor: (v3: DrawingData, pixelIndex: number): string => {\n    const data = DrawingUtils._decodeData(v3.data);\n    const colorIndex = data[pixelIndex] || 0;\n    return v3.colors[colorIndex] || v3.colors[v3.bg] || '#FFFFFF';\n  },\n\n  /**\n   * Set pixel color\n   */\n  setPixel: (\n    v3: DrawingData,\n    pixelIndex: number,\n    color: string\n  ): DrawingData => {\n    // Find color index (optimized lookup)\n    let colorIndex = v3.colors.indexOf(color);\n    if (colorIndex === -1) {\n      if (v3.colors.length >= 256) {\n        throw new Error('Maximum 256 colors allowed');\n      }\n      colorIndex = v3.colors.length;\n      v3.colors.push(color);\n    }\n\n    // Decode current data efficiently\n    const data = DrawingUtils._decodeData(v3.data);\n\n    // Set pixel color\n    data[pixelIndex] = colorIndex;\n\n    return {\n      ...v3,\n      data: DrawingUtils._encodeData(data),\n    };\n  },\n\n  /**\n   * Get storage size estimate\n   */\n  getStorageSize: (v3: DrawingData): number => {\n    // Rough estimate: colors + data + metadata\n    const colorsSize = v3.colors.join('').length;\n    const dataSize = v3.data.length; // Base64 encoded\n    const metadataSize = 15; // bg, size\n    return colorsSize + dataSize + metadataSize;\n  },\n\n  /**\n   * Check if drawing is empty (all pixels are background)\n   */\n  isEmpty: (v3: DrawingData): boolean => {\n    const data = DrawingUtils._decodeData(v3.data);\n    return data.every((byte) => byte === v3.bg);\n  },\n\n  /**\n   * Get total number of colored pixels (non-background)\n   */\n  getPixelCount: (v3: DrawingData): number => {\n    const data = DrawingUtils._decodeData(v3.data);\n    let count = 0;\n    for (const byte of data) {\n      if (byte !== v3.bg) count++;\n    }\n    return count;\n  },\n\n  /**\n   * Batch operations for multiple pixels (more efficient)\n   */\n  setPixels: (\n    v3: DrawingData,\n    pixels: Array<{ index: number; color: string }>\n  ): DrawingData => {\n    if (pixels.length === 0) return v3;\n\n    const data = DrawingUtils._decodeData(v3.data);\n    const colors = [...v3.colors];\n    const colorMap = new Map<string, number>();\n\n    // Build color map for O(1) lookups\n    colors.forEach((color, index) => {\n      colorMap.set(color, index);\n    });\n\n    // Process all pixels\n    for (const { index, color } of pixels) {\n      let colorIndex = colorMap.get(color);\n      if (colorIndex === undefined) {\n        if (colors.length >= 256) {\n          throw new Error('Maximum 256 colors allowed');\n        }\n        colorIndex = colors.length;\n        colors.push(color);\n        colorMap.set(color, colorIndex);\n      }\n      data[index] = colorIndex;\n    }\n\n    return {\n      ...v3,\n      colors,\n      data: DrawingUtils._encodeData(data),\n    };\n  },\n\n  /**\n   * Get all pixel colors as a flat array (for rendering)\n   */\n  getAllPixelColors: (v3: DrawingData): string[] => {\n    const data = DrawingUtils._decodeData(v3.data);\n    const result: string[] = new Array(data.length);\n\n    for (const [i, colorIndexRaw] of data.entries()) {\n      const colorIndex = colorIndexRaw || 0;\n      result[i] = v3.colors[colorIndex] || v3.colors[v3.bg] || '#FFFFFF';\n    }\n\n    return result;\n  },\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/schema/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/schema/pixelary.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/schema/pixelary.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/test-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/array.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/array.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 13,
        "column": 18,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 13,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 14,
        "column": 17,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 14,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Split array into chunks of specified length\n */\n\n/**\n * Shuffle array using Fisher-Yates algorithm\n */\n\nexport function shuffle<T>(items: T[]): T[] {\n  const result = [...items];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i]!;\n    result[i] = result[j]!;\n    result[j] = temp;\n  }\n  return result;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/color.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/color.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 11,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 11,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 13,
        "column": 21,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 13,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { HEX, RGB } from '../types';\n\n/**\n * Convert hex color to RGB values\n */\n\nfunction hexToRgb(hex: HEX): RGB | null {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1]!, 16),\n        g: parseInt(result[2]!, 16),\n        b: parseInt(result[3]!, 16),\n      }\n    : null;\n}\n\n/**\n * Calculate relative luminance using WCAG 2.1 formula\n * Returns value between 0 (black) and 1 (white)\n * Based on sRGB color space and ITU-R BT.709 standard\n */\n\nfunction getRelativeLuminance(color: HEX): number {\n  const rgb = hexToRgb(color);\n  if (!rgb) return 0.5; // Default to middle gray for invalid colors\n\n  // Convert to linear RGB using sRGB transfer function\n  const linearize = (c: number) => {\n    c = c / 255;\n    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n  };\n\n  const rLinear = linearize(rgb.r);\n  const gLinear = linearize(rgb.g);\n  const bLinear = linearize(rgb.b);\n\n  // Calculate relative luminance using ITU-R BT.709 coefficients\n  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;\n}\n\n/**\n * Get contrasting color (black or white) for optimal readability\n * Uses WCAG 2.1 contrast guidelines with perceptual lightness threshold\n * @param backgroundColor Background color\n * @param threshold Threshold for determining lightness (0-1), default 0.5\n * @returns '#000000' for light backgrounds, '#FFFFFF' for dark backgrounds\n */\nexport function getContrastColor(\n  backgroundColor: HEX,\n  threshold: number = 0.5\n): HEX {\n  const luminance = getRelativeLuminance(backgroundColor);\n  return luminance > threshold ? '#000000' : '#FFFFFF';\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/drawing.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/drawing.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 15,
        "column": 5,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 15,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 1,
        "message": "Unnecessary conditional, value is always truthy.",
        "line": 24,
        "column": 18,
        "nodeType": "MemberExpression",
        "messageId": "alwaysTruthy",
        "endLine": 24,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 37,
        "column": 35,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 37,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [987, 989], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 57,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 57,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "" },
            "fix": { "range": [1482, 1484], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Render DrawingData to canvas (bit-packed format)\n */\n\n// Declare global variables for cross-environment compatibility\ndeclare const atob: ((data: string) => string) | undefined;\ndeclare const console: Console | undefined;\n\nexport function renderDrawingToCanvas(\n  drawingData: { data: string; colors: string[]; bg: number; size: number },\n  canvas: HTMLCanvasElement\n): void {\n  // Validate input data\n  if (\n    !drawingData ||\n    typeof drawingData.data !== 'string' ||\n    !Array.isArray(drawingData.colors)\n  ) {\n    return;\n  }\n\n  const resolution = drawingData.size || 16;\n  const bgIndex = drawingData.bg || 0;\n  const colors = drawingData.colors || ['#FFFFFF'];\n\n  // Set canvas size to match drawing resolution\n  canvas.width = resolution;\n  canvas.height = resolution;\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return;\n\n  // Disable image smoothing for crisp pixels\n  ctx.imageSmoothingEnabled = false;\n\n  // Fill background\n  ctx.fillStyle = colors[bgIndex] || '#FFFFFF';\n  ctx.fillRect(0, 0, resolution, resolution);\n\n  // Validate and decode data\n  let data: Uint8Array;\n  try {\n    if (typeof atob === 'undefined') {\n      throw new Error('atob not available');\n    }\n    data = new Uint8Array(\n      atob(drawingData.data)\n        .split('')\n        .map((c) => c.charCodeAt(0))\n    );\n  } catch (error) {\n    return;\n  }\n\n  // Draw pixels\n  for (let pixelIndex = 0; pixelIndex < data.length; pixelIndex++) {\n    const colorIndex = data[pixelIndex] || 0;\n    const color = colors[colorIndex];\n\n    if (color && colorIndex !== bgIndex) {\n      const x = pixelIndex % resolution;\n      const y = Math.floor(pixelIndex / resolution);\n      ctx.fillStyle = color;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/numbers.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/numbers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/progression.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/progression.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 12,
        "column": 24,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 12,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-non-null-assertion",
        "severity": 1,
        "message": "Forbidden non-null assertion.",
        "line": 34,
        "column": 8,
        "nodeType": "TSNonNullExpression",
        "messageId": "noNonNull",
        "endLine": 34,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-type-assertion",
        "severity": 1,
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "line": 34,
        "column": 8,
        "nodeType": "TSNonNullExpression",
        "messageId": "unnecessaryAssertion",
        "endLine": 34,
        "endColumn": 18,
        "fix": { "range": [811, 812], "text": "" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { LEVELS } from '../constants';\nimport type { Level } from '../types';\n\n/**\n * Generate level data for any rank (supports infinite levels)\n * @param rank - The level rank (1-based)\n * @returns Level data with name, min/max points\n */\nexport function generateLevel(rank: number): Level {\n  // Handle named levels (1-10)\n  if (rank >= 1 && rank <= LEVELS.length) {\n    const namedLevel = LEVELS[rank - 1]!;\n    return {\n      ...namedLevel,\n    };\n  }\n\n  // Handle bonus levels (11+)\n  if (rank > LEVELS.length) {\n    const bonusNumber = rank - LEVELS.length;\n    const min = Math.pow(10, rank);\n    const max = Math.pow(10, rank + 1) - 1;\n\n    return {\n      rank,\n      name: `Bonus ${bonusNumber}`,\n      min,\n      max,\n    };\n  }\n\n  // Fallback to level 1 for invalid ranks\n  return {\n    ...LEVELS[0]!,\n  };\n}\n\n/**\n * Get level by score using mathematical calculation (supports infinite levels)\n * @param score - The user's score\n * @returns The level data for the given score\n */\nexport function getLevelByScore(score: number = 0): Level {\n  // Handle edge case: score 0-99 should be level 1\n  if (score < 100) {\n    return generateLevel(1);\n  }\n\n  // Calculate rank using log10\n  // 100-999  log10(100) = 2, so rank = 2\n  // 1000-9999  log10(1000) = 3, so rank = 3\n  const rank = Math.floor(Math.log10(score));\n\n  return generateLevel(rank);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/string.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/knut/Developer/pixelary/src/shared/utils/string.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
